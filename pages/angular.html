<!DOCTYPE html>
<html lang="en-US">
<head>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Angular tutorials and examples, Web Engineer Book">
  <meta name="keywords" content="Angular, javascript, js, tutorials, examples, cheat sheet, help, documentation, web, engineer, book, @vipssystems, #vipssystems, #WebEngineerBook">
  <meta name="author" content="Andrei, andreivinyl@gmail.com">

  <link rel="manifest" href="../manifest.webmanifest">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">

  <link rel="stylesheet" href="../js/highlight/styles/default.css">
  <link rel="stylesheet" href="../css/css.css">

  <script src="../js/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script src="../js/utils.js"></script>

  <title>Angular tutorials and examples - Web Engineer Book</title>

</head>

<body>

<h1>Angular</h1>

<h2 id="arch">Architecture</h2>
  <ul>
    <li>Angular app is defined by a set of JS modules and NgModules(basic building blocks) which provide a compilation context for <strong>components</strong> and collect related code into functional sets</li>
    <li>NgModule (modularity system, <code>@NgModule()</code> decorator contains metadata properties object) declares a compilation context for a set of components that is dedicated to an application domain, a workflow, or a closely related set of capabilities, can associate its components with related code, such as services, to form functional units</li>
    <li>app always has at least <strong>root module</strong> (AppModule - app.module.ts, connects a component hierarchy with the page DOM) that enables bootstrapping, and typically has many more <strong>feature modules</strong></li>
    <li>components defines a class that contains application data and logic and control patch of screen called <strong>views</strong>, which are sets of screen elements that Angular can choose among and modify according to your program logic and data, components are created, updated, and destroyed as the user moves through the application</li>
    <li><code>@Component()</code> decorator identifies the class immediately below it as a component, and provides the template and related component-specific metadata</li>
    <li>metadata for a component class associates it with a <strong>template</strong> (combines ordinary HTML with Angular <strong>directives</strong> and <strong>binding markup</strong>) that defines a view</li>
    <li>app component can contain a <strong>view hierarchy</strong> (with host (root) view), which allows you to define arbitrarily complex areas of the screen that can be created, modified, and destroyed as a unit, and can mix views defined in components that belong to different NgModules</li>
    <li>template <strong>data binding</strong>: event and property binding</li>
    <li>component is technically a directive, <code>@Component()</code> decorator extends the <code>@Directive()</code> decorator with template-oriented features, in addition to components, there are two other kinds of directives: structural(alter layout: *ngFor, *ngIf) and attribute(alter the appearance or behavior: [(ngModel)], ngSwitch, ngStyle, ngClass)</li>
    <li>use <strong>pipes</strong> (class with the <code>@Pipe</code> decorator) to improve the user experience by transforming values for display</li>
    <li>components use <strong>services</strong>, which provide specific functionality not directly related to views, such as fetching data from the server, validating user input, or logging directly to the console, definition is immediately preceded by the <code>@Injectable()</code> decorator which provides metadata inject service into client components as a dependency through dependency injection (DI)</li>
    <li>Angular creates an application-wide <strong>injector</strong> during the bootstrap process, and additional injectors as needed, injector creates dependencies, and maintains a <strong>container</strong> of dependency instances that it reuses if possible, <strong>provider</strong> is an object that tells an injector how to obtain or create a dependency</li>
    <li>for dependency that you need in your app, you must register a provider with the app injector, so that the injector can use the provider to create new instances, for a service the provider is typically the service class itself</li>
    <li><strong>Router</strong> service helps you define navigation paths among views</li>
    <li>Angular can only find the parameter information if the class has a decorator of some kind</li>
    <li>Angular loads as a collection of JS modules (library modules), each Angular library name begins with the @angular prefix, install them <strong>npm</strong> and import parts of them with JS <strong>import</strong> statements</li>
  </ul>

  <img src="../images/angular-arc.png"
  style="position:relative;width:80%;margin-left:10%;">

  <pre><code class="ts">
    // you cant refer directly to a class until its been defined
    // break the circularity
    providers: [{ provide: Parent, useExisting: forwardRef(() => AlexComponent) }],
  </code></pre>



<h2 id="ngmodule">NgModule</h2>

  <ul>
    <li>describes how application parts fit together, organize related things together</li>
    <li>a class with the @NgModule decorator - takes a metadata object that describes how to compile a component template and how to create an injector at runtime, identifies the module own components, directives, and pipes, making some of them public, through the exports property, can also add service providers to the application dependency injectors</li>
    <li>Angular libraries are NgModules</li>
    <li>JS modules dont have to have the @NgModule decorator (and metadata), use <code>export class AppComponent { â€¦ }</code> in file, then <code>import { AppComponent } from './app.component';</code></li>
    <li>every application has at least one Angular module, root module, that bootstrap to launch the application, by convention called AppModule</li>
    <li><strong>entry component</strong> - any component that Angular loads imperatively, by type (included in the template - declarative), you are not referencing it in the template, specify by bootstrapping it in an NgModule, or including it in a routing definition
      <ul>
        <li><strong>bootstrapped component</strong> is an entry component that Angular loads into the DOM during the bootstrap process (application launch)</li>
        <li><strong>routed entry component</strong> - occurs in a route definition</li>
      </ul>
    </li>
    <li><strong>feature modules</strong> are NgModules for the purpose of organizing code
      <ul>
        <li><code>ng generate module CustomerDashboard</code></li>
        <li><code>ng generate component customer-dashboard/CustomerDashboard</code></li>
        <li>and import in root module</li>
        <li>must declare all the components, directives and pipe it needs</li>
        <li>must import CommonModule instead of BrowserModule</li>
        <li>it does not bootstrap anything</li>
      </ul>
    </li>
    <li><strong>provider</strong> is an instruction to the DI system on how to obtain a value for a dependency, most of the time, these dependencies are services that you create and provide
      <ul>
        <li><code>@Injectable({ providedIn: UserModule })</code> - make unavailable until OneModule is loaded, preferred way, enables tree-shaking of the service if nothing injects it</li>
        <li><code>@NgModule({ providers: [UserService] })</code> - declare a provider for the service within the module</li>
        <li><code>@Injectable({ providedIn: 'any' })</code> - all eagerly loaded modules share a singleton instance and lazy loaded modules each get their own unique instance</li>
        <li><code>@Component({ providers: [UserService] })</code> - limit provider scope by adding the service to providers array, component providers and NgModule providers are independent of each other, helpful when you want to eagerly load a module that needs a service all to itself, limits the service ONLY to that component and its descendant</li>
        <li>provide services the whole application needs in the root module, and scope services by providing them in lazy loaded modules</li>
      </ul>
    </li>
    <li>service as a singleton
      <ul>
        <li>declare that the service should be provided in the application root (<code>providedIn:'root'</code>)</li>
        <li>include the service in the AppModule or in a module that is only imported by the AppModule</li>
      </ul>
    </li>
    <li>to avoid duplication of provider instances (singleton pattern) separate providers out of the module so that same module can be imported into the root module with providers and child modules without providers
      <ul>
        <li>1 - create a static method <strong>forRoot()</strong> (by convention from Router) on the module</li>
        <li>2 - place the providers into the forRoot method</li>
      </ul>
    </li>
    <li>use @SkipSelf (start dependency resolution from the parent injector) and @Optional (optional dependency, which should expect "null" when used apart) decorators in constructor to avoid re-import</li>
    <li><strong>lazy loading</strong> - load modules only when you need them
      <ul>
        <li>load feature areas only when requested by the user, speed up load time for users that only visit certain areas of the application, continue expanding lazy loaded feature areas without increasing the size of the initial load bundle</li>
        <li>it will be a <u>different bundle and module, loaded only on demand by default</u>, its not included in the global scope your app</li>
        <li>you still have access to services already provided in the app (like HttpClient and own services), but the services provided in lazy-loaded module will only be available in this lazy-loaded module, not everywhere in app</li>
        <li>created with own <strong>child injector</strong>, a child of the root injector, <u>scoped to the lazy module injector</u>, if a lazy-loaded module also provides the UserService, any component created within that module context (such as by router navigation) gets the <u>local instance of the service</u>, not the instance in the root application injector, components in external modules continue to receive the instance provided by their injectors</li>
        <li>not all services can be lazy loaded, some modules only work in the root module, such as the Router (works with the global location object in the browser)</li>
        <li>for components, it doesnt change anything: import again the CommonModule and other modules of components, like in any submodule</li>
      </ul>
    </li>
    <li>steps to setting up a lazy loaded feature module:
      <ul>
        <li>create the feature module and its routing module</li>
        <li>configure the routes</li>
        <li>add feature module component into "<strong>declarations:[CustomerListComponent]</strong> and use "<strong>component:CustomerListComponent</strong>" to addres feature module component in its *-routing.module.ts routes</li>
        <li>(<strong>loadChildren:()=>import('IMPORT_STRING').then(M=>M.EXPORT_NAME)</strong>) : ()=>import('./lazy/lazy.module').then(m=>m.LazyModule) to addres feature module in root *-routing.module.ts routes (app root router,...), <strong>, with "default" export, the ".then" can be omitted</strong></li>
        <li><i>feature module is like a connector between the AppRoutingModule and the feature routing module</i></li>
        <li><i>CLI adds RouterModule.forChild(routes) to feature routing modules, route list is only responsible for providing additional routes and is intended for feature modules</i></li>
      </ul>
    </li>
    <li>import modules when you want to use directives, pipes, and components, importing a module with services means that you will have a new instance of that service, use DI for services</li>
    <li>components, directives, and pipes must belong to exactly one module, <strong>do not re-declare a class that is imported directly or indirectly from another module</strong>
      <ul>
        <li>if the <u>module is imported for components</u> - import it in each module needing them:     CommonModule (all the basics of Angular templating: bindings, *ngIf, *ngFor, ...), except in the first app module, because its already part of the BrowserModule, FormsModule/ReactiveFormsModule, MatXModule, any other module giving you components, directives or pipes</li>
        <li>if the <u>module is imported for services</u> - import it only once, in the first app module: HttpClientModule, BrowserAnimationsModule or NoopAnimationsModule, any other module <u>providing services only</u></li>
      </ul>
    </li>
    <li><strong>import BrowserModule only in the root AppModule, CommonModule in feature modules</strong></li>
    <li>avoid circular references when importing modules</li>
    <li><strong>dont export private module things</strong> components, directives, services, pure services (HttpClient), functions, configurations, entity models, and pipes that you need only within components declared in this NgModule</li>
    <li>when two imported modules, loaded at the same time, list a provider with the same token, the second module provider "wins"</li>
    <li>service provided by the root AppModule takes precedence over services provided by imported NgModules</li>
    <li>creating shared modules allows organization and streamline code, put commonly used directives, pipes, and components into one module and then import just that module wherever you need it in other parts of your app, <u>first separate each feature</u></li>
    <li>possible modules separation
      <ul>
        <li><strong>pages</strong> - modules with routing, separate and organize the different areas of app, loaded only once, either in the AppModule or via lazy-loading</li>
        <li>contain 3 things:
          <ul>
            <li>/shared - services and interfaces</li>
            <li>/pages - routed components, display the data directly in the component template but do not transfer data to another component via an attribute</li>
            <li>/components - pure presentation components, retrieves the transferred data with the Input decorator, and displays it in the template, also referred as pure components, can be reused in different pages, change detection can be optimized with <a href="https://angular.io/api/core/ChangeDetectionStrategy">ChangeDetection</a></li>
          </ul>
        </li>
        <li><strong>global services</strong> - services needed through the whole app, loaded only once in the AppModule (services have generally a global scope), and then services are accessible everywhere (including in lazy-loaded modules)
          <ul>
            <li>reusable through different projects if you take care to have no specific dependency in them (no UI or app specific code), and if you separate each features in different modules (do not put every service in just one big global module)</li>
            <li>as such a module will be used from outside, you should do an entry point, where you export the NgModule, the services and maybe interfaces and injection tokens</li>
            <li>HttpClient module, and a very common case is an AuthModule to store the user connection status (as this data is needed everywhere in the app) and save the token</li>
            <li>NOTE: since Angular 6, no need of module anymore for services, as they are auto-providing themselves, but it doesnt change the architecture described</li>
          </ul>
        </li>
        <li><strong>reusable components</strong> - UI components to reuse in different projects
          <ul>
            <li><u>components have a local scope</u>, these modules are imported in each pages modules, like Material, NgBootstrap or PrimeNg</li>
            <li>pure presentation components</li>
            <li>work same as modules of pages: data should come from the Input decorator (and sometimes from ng-content in advanced cases)</li>
            <li>components are in local scope, export public ones in the NgModule, internal sub components can stay private</li>
            <li>can also be about directives or pipes, same as components, need to be exported if they are public</li>
            <li>services, can be relevant for data manipulation if they contain nothing specific, but then, be sure to provide them in the component, so they have a local/private scope, and certainly not in the NgModule</li>
            <li>extra code for each public service to prevent them to be loaded several times</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <pre><code class="ts">
    // --- APP.MODULE.TS

    import { NgModule } from '@angular/core';
    // when you want to run your app in a browser
    import { BrowserModule } from '@angular/platform-browser';
    // when you want to use pipes and directives like NgIf, NgFor
    // import { CommonModule } from '@angular/common'; // for feature modules
    // when you want to build template driven forms (includes NgModel)
    import { FormsModule } from '@angular/forms';
    // when you want to build reactive forms
    import { ReactiveFormsModule } from '@angular/forms';
    // when you want to use RouterLink, .forRoot(), and .forChild()
    import { RouterModule } from '@angular/router';
    // when you want to talk to a server
    import { HttpClientModule } from '@angular/common/http';

    import { AppComponent } from './app.component'; // App Root

    // Feature Modules
    // import to add to the imports array below
    import {
      CustomerDashboardModule
    } from './customer-dashboard/customer-dashboard.module';
    import { CoreModule } from './core/core.module';

    import { UserService } from './user.service';

    // UI module case
    export function SOME_SERVICE_FACTORY(parentService: SomeService) {
      return parentService || new SomeService();
    }

    @NgModule({

      // --- Static, compiler configuration
      // which components, directives, and pipes belong to module, local scope (private visibility)
      // declare every component in exactly one NgModule class
      // error - if you declare same class in more than one module
      // invisible to components in a different module unless they are exported
      // import the module when you need it elsewhere
      declarations: [
        AppComponent // new app project root NgModule has only one component
      ], // Configure the selectors

      // --- Composability / Grouping
      // other NgModules that this module needs to function properly
      // those that export components, directives, or pipes that component templates in this module reference
      // composing NgModules together
      imports: [
        CommonModule,
        BrowserModule, // use browser-specific services
        FormsModule,
        HttpClientModule,
        ...
        CustomerDashboardModule
        // CustomerDashboardModule.forRoot({userName: 'Miss Marple'})
      ],

      // --- Runtime, or injector configuration
      // services the application needs
      // they become available app-wide
      // global scope (public visibility)
      // specify providers at the component level (preferred)
      // scope them when using feature modules and lazy loading
      providers: [
        UserService,
        Logger
        // UI module case
        {
          provide: SomeService,
          deps: [[new Optional(), new SkipSelf(), SomeService]],
          useFactory: SOME_SERVICE_FACTORY
        }
      ],

      // subset of declarations that should be visible and usable
      // in the component templates of other NgModules
      // making NgModules available to other parts of the app
      exports: [
        AppComponent
      ],

      // components that are automatically bootstrapped
      // usually the root component of the application
      // Angular can launch with multiple bootstrap components,
      // each with its own location in the host web page
      bootstrap: [ AppComponent ]

      // root NgModule has no reason to export anything
      // because other modules dont need to import the root NgModule

    })
    export class AppModule { }

    // --- APP.COMPONENT.TS

    import { Component } from '@angular/core';
    @Component({
      selector: 'app-root',
      templateUrl: './app.component.html',
      styleUrls: ['./app.component.css']
    })
    export class AppComponent {
      title = 'app works!';
    }

    // --- APP.COMPONENT.TS

    &lt;h1&gt;
      {{title}}
    &lt;/h1&gt;
    // selector from CustomerDashboardComponent
    &lt;app-customer-dashboard&gt;&lt;/app-customer-dashboard&gt;

    // --- CUSTOMER-DASHBOARD/CUSTOMER-DASHBOARD.MODULE.TS - feature module

    import {
      NgModule, ModuleWithProviders, Optional, SkipSelf
    } from '@angular/core';
    //import { CommonModule } from '@angular/common';
    @NgModule({
      imports: [
        //CommonModule,
        SharedModule
      ],
      exports: [
        // export this module inner component
        // for &lt;app-customer-dashboard&gt; usage in root module
        CustomerDashboardComponent
      ],
      declarations: [
        CustomerDashboardComponent
      ],
    })
    export class CustomerDashboardModule {
      constructor (@Optional() @SkipSelf() parentModule: CustomerDashboardModule) {
        if (parentModule) {
          throw new Error(
            'CustomerDashboardModule is already loaded. Import it in the AppModule only');
        }
      }
      static forRoot(config: UserServiceConfig): ModuleWithProviders&lt;CoreModule&gt; {
        return {
          ngModule: CoreModule,
          providers: [
            { provide: UserServiceConfig, useValue: config }
          ]
        };
      }
    }

    // --- CUSTOMER-DASHBOARD/CUSTOMER-DASHBOARD.COMPONENT.TS

    import { Component } from '@angular/core';
    @Component({
      selector: 'app-customer-dashboard',
      templateUrl: './customer-dashboard.component.html',
      styleUrls: ['./customer-dashboard.component.css']
    })
    export class CustomerDashboardComponent { }

    // --- CUSTOMER-DASHBOARD/CUSTOMER-DASHBOARD.COMPONENT.HTML

    &lt;p&gt;
      customer-dashboard works!
    &lt;/p&gt;

    // --- USER.SERVICE.TS

    import { Injectable, Optional } from '@angular/core';
    let nextId = 1;
    export class UserServiceConfig {
      userName = 'Philip Marlowe';
    }
    @Injectable({
      // make automatically available to the whole application, singleton by default
      providedIn: 'root'
      // UserService is unavailable to applications unless UserModule is imported
      providedIn: UserModule,
    })
    export class UserService {
      id = nextId++;
      private _userName = 'Sherlock Holmes';
      constructor(@Optional() config: UserServiceConfig) {
        if (config) { this._userName = config.userName; }
      }
      get userName() {
        // Demo: add a suffix if this service has been created more than once
        const suffix = this.id > 1 ? ` times ${this.id}` : '';
        return this._userName + suffix;
      }
    }

    // --- SHARED/SHARED.MODULE.TS

    import { NgModule }            from '@angular/core';
    import { CommonModule }        from '@angular/common';
    import { FormsModule }         from '@angular/forms';
    import { AwesomePipe }         from './awesome.pipe';
    import { HighlightDirective }  from './highlight.directive';
    @NgModule({
      imports:      [ CommonModule ],
      declarations: [ AwesomePipe, HighlightDirective ],
      exports:      [ AwesomePipe, HighlightDirective,
                      CommonModule, FormsModule ]
    })
    export class SharedModule { }
  </code></pre>

  <h3>possible modules separation</h3>
  <pre><code class="ts">
    app/
    |-- app.module.ts
    |-- app-routing.module.ts
    |-- core/
        |-- auth/
          |-- auth.module.ts (optional since Angular 6)
          |-- auth.service.ts
          |-- index.ts
        |-- othermoduleofglobalservice/
    |-- ui/
        |-- carousel/
          |-- carousel.module.ts
          |-- index.ts
          |-- carousel/
              |-- carousel.component.ts
              |-- carousel.component.css
        |-- othermoduleofreusablecomponents/
    |-- heroes/
        |-- heroes.module.ts
        |-- heroes-routing.module.ts
        |-- shared/
          |-- heroes.service.ts
          |-- hero.ts
        |-- pages/
          |-- heroes/
              |-- heroes.component.ts
              |-- heroes.component.css
          |-- hero/
              |-- hero.component.ts
              |-- hero.component.css
        |-- components/
          |-- heroes-list/
              |-- heroes-list.component.ts
              |-- heroes-list.component.css
          |-- hero-details/
              |-- hero-details.component.ts
              |-- hero-details.component.css
    |-- othermoduleofpages/

    // --- MODULES OF PAGES, will contain 3 things

    @NgModule({
      imports: [CommonModule, MatCardModule, PagesRoutingModule],
      declarations: [PageComponent, PresentationComponent]
    })
    export class PagesModule {}
    // - /shared - services and interfaces
    @Injectable({ providedIn: 'root' })
    export class SomeService {
      constructor(protected http: HttpClient) {}
      getData() {
        return this.http.get&lt;SomeData&gt;('/path/to/api');
      }
    }
    // - /pages - routed components
    @Component({
      template: `&lt;app-presentation *ngIf="data" [data]="data"&gt;&lt;/app-presentation&gt;`
    })
    export class PageComponent {
      data: SomeData;
      constructor(protected someService: SomeService) {}
      ngOnInit() {
        this.someService.getData().subscribe((data) =&gt; {
          this.data = data;
        });
      }
    }
    // - /components - pure presentation components
    @Component({
      selector: 'app-presentation',
      template: `&lt;h1&gt;{{data.title}}&lt;/h1&gt;`
    })
    export class PresentationComponent {
      @Input() data: SomeData;
    }

    // --- MODULES OF REUSABLE COMPONENTS

    @NgModule({
      imports: [CommonModule],
      declarations: [PublicComponent, PrivateComponent],
      exports: [PublicComponent]
    })
    export class UiModule {}
    // - extra code for each public UI service to prevent them to be loaded several times
    export function SOME_SERVICE_FACTORY(parentService: SomeService) {
      return parentService || new SomeService();
    }
    @NgModule({
      providers: [{
        provide: SomeService,
        deps: [[new Optional(), new SkipSelf(), SomeService]],
        useFactory: SOME_SERVICE_FACTORY
      }]
    })
    export class UiModule {}
    // - entry point, export the NgModule, the public/exported components
    // (and maybe directives, pipes, public services, interfaces and injection tokens)
    export { SomeUiComponent }  from './some-ui/some-ui.component';
    export { UiModule } from './ui.module';

    // --- MODULES OF GLOBAL SERVICES, not necessary since Angular 6

    @NgModule({
      providers: [SomeService]
    })
    export class SomeModule {}
  </code></pre>

  <table>
    <caption>use of each feature module type and their typical characteristics, in real world apps, you may see hybrids</caption>
    <tbody><tr>
      <th> Feature Module </th>
      <th> Guidelines </th>
    </tr>
    <tr>
      <td>Domain</td>
      <td>
        deliver a user experience dedicated to a particular application domain like editing a customer or placing an order, typically have a top component that acts as the feature root and private, supporting sub-components descend from it, consist mostly of declarations, only the top component is exported, rarely have providers, when they do, the lifetime of the provided services should be the same as the lifetime of the module, typically imported exactly once by a larger feature module, might be imported by the root <strong>AppModule</strong> of a small application that lacks routing</p>
      </td>
    </tr>
    <tr>
      <td>Routed</td>
      <td>
        domain feature modules whose top components are the targets of router navigation routes, all lazy-loaded modules are routed feature modules by definition, dont export anything because their components never appear in the template of an external componentm lazy-loaded routed feature module should not be imported by any module, doing so would trigger an eager load, defeating the purpose of lazy loading that means you wont see them mentioned among the <code>AppModule</code> imports, an eager loaded routed feature module must be imported by another module so that the compiler learns about its components, rarely have providers, when they do, the lifetime of the provided services should be the same as the lifetime of the module, dont provide application-wide singleton services in a routed feature module or in a module that the routed module imports</p>
      </td>
    </tr>
    <tr>
      <td>Routing</td>
      <td>
        provides routing configuration for another module and separates routing concerns from its companion module, typically does the following: - defines routes, - adds router configuration to the modules imports, - adds guard and resolver service providers to the module providers, - name of the routing module should parallel the name of its companion module, using the suffix "Routing": <code>FooModule</code> in <code>foo.module.ts</code> has a routing module named <code>FooRoutingModule</code> in <code>foo-routing.module.ts</code>, if the companion module is the root <code>AppModule</code>, the <code>AppRoutingModule</code> adds router configuration to its imports with <code>RouterModule.forRoot(routes)</code>, all other routing modules are children that import <code>RouterModule.forChild(routes)</code> - routing module re-exports the <code>RouterModule</code> as a convenience so that components of the companion module have access to router directives such as <code>RouterLink</code> and <code>RouterOutlet</code>. does not have its own declarations, components, directives, and pipes are the responsibility of the feature module, not the routing module, routing module should only be imported by its companion module</p>
      </td>
    </tr>
    <tr>
      <td>Service</td>
      <td>
        provide utility services such as data access and messaging, they consist entirely of providers and have no declarations, HttpClientModule is a good example of a service module, root <code>AppModule</code> is the only module that should import service modules
      </td>
    </tr>
    <tr>
      <td>Widget</td>
      <td>
        makes components, directives, and pipes available to external modules, many third-party UI component libraries are widget modules, widget module should consist entirely of declarations, most of them exported, should rarely have providers, import widget modules in any module whose component templates need the widgets
      </td>
    </tr>
    <tr>
      <td>Shared</td>
      <td>
        commonly used directives, pipes, and components in one NgModule, typically named SharedModule, then import just that NgModule in other parts of app, import the shared NgModule in domain NgModules, including lazy-loaded NgModules, shared NgModules should not include providers, nor should any of its imported or re-exported NgModules include providers
      </td>
    </tr>
  </tbody></table>

  <table>
    <caption>key characteristics of each feature module group</caption>
    <tbody><tr>
      <th>
        Feature Module
      </th>
      <th>
        Declarations
      </th>
      <th>
        Providers
      </th>
      <th>
        Exports
      </th>
      <th>
        Imported by
      </th>
    </tr>
    <tr>
      <td>Domain</td>
      <td>Yes</td>
      <td>Rare</td>
      <td>Top component</td>
      <td>Feature, AppModule</td>
    </tr>
    <tr>
      <td>Routed</td>
      <td>Yes</td>
      <td>Rare</td>
      <td>No</td>
      <td>None</td>
    </tr>
    <tr>
      <td>Routing</td>
      <td>No</td>
      <td>Yes (Guards)</td>
      <td>RouterModule</td>
      <td>Feature (for routing)</td>
    </tr>
    <tr>
      <td>Service</td>
      <td>No</td>
      <td>Yes</td>
      <td>No</td>
      <td>AppModule</td>
    </tr>
    <tr>
      <td>Widget</td>
      <td>Yes</td>
      <td>Rare</td>
      <td>Yes</td>
      <td>Feature</td>
    </tr>
  </tbody></table>



<h2 id="componentdirs">Component/Directives</h2>

  <ul>
    <li><strong>components are in local scope, do not forget to export them in the NgModule, export public ones, internal sub components can stay private</strong></li>
    <li>lifecycle hooks - directive and component lifecycle as Angular creates, updates, and destroys them</li>
    <li>directive/component hook method is called if it is defined, interface dont have them, use them only for strong typing and editor tooling</li>
    <li>after creating a component/directive by calling its constructor, Angular calls the lifecycle hook methods in the following sequence at specific moments
      <ul>
        <li><strong>ngOnChanges()</strong> - respond when Angular (re)sets data-bound input properties (@Input()), receives a SimpleChanges object of current and previous property values, called <u>before ngOnInit() and whenever one or more data-bound input properties change</u></li>
        <li><strong>ngOnInit()</strong> - initialize the directive/component after Angular first displays the data-bound properties and sets the directive/component input properties, called <u>once, after the first ngOnChanges()</u>, use to perform complex initializations and initial fetching after construction and set up the component after Angular sets the input properties</li>
        <li><strong>ngDoCheck()</strong> - detect and act upon changes that Angular cant or wont detect on its own, called during every change detection run, <u>immediately after ngOnChanges() and ngOnInit()</u></li>
        <li><strong>ngAfterContentInit()</strong> - respond after Angular projects external content into the component view / the view that a directive is in, called <u>once after the first ngDoCheck()</u></li>
        <li><strong>ngAfterContentChecked()</strong> - respond after Angular checks the content projected into the directive/component, called <u>after the ngAfterContentInit() and every subsequent ngDoCheck()</u></li>
        <li><strong>ngAfterViewInit()</strong> - respond after Angular initializes the component views and child views / the view that a directive is in, called <u>once after the first ngAfterContentChecked()</u></li>
        <li><strong>ngAfterViewChecked()</strong> - respond after Angular checks the component views and child views / the view that a directive is in, called <u>after the ngAfterViewInit() and every subsequent ngAfterContentChecked()</u></li>
        <li><strong>ngOnDestroy()</strong> - cleanup just before Angular destroys the directive/component, unsubscribe Observables and detach event handlers to avoid memory leaks, called just <u>before Angular destroys the directive/component</u>, notify another part of the application that the component is going away, unsubscribe from Observables and DOM events, stop interval timers, unregister all callbacks that this directive registered with global or application services</li>
        <li>3rd party libraries might implement their hooks</li>
      </ul>
    </li>
    <li>directives data-bound input properties are not set until after construction, if you need to initialize the directive based on those properties use ngOnInit()</li>
    <li>styles are applied only to component content, and not inherited</li>
    <li>styles
      <ul>
        <li>styleUrls: [...</li>
        <li>styles: [...</li>
        <li>inline with style-tag</li>
        <li>link-tag</li>
        <li>import CSS files into the CSS files using @import rule, URL is relative to the CSS file into which you are importing</li>
        <li>configure angular.json to include all external assets, including external style files</li>
        <li>register global style files in the styles section which, by default, is pre-configured with the global styles.css file</li>
        <li>extra attributes of styles encapsulation: _nghost-* , _ngcontent-*</li>
      </ul>
    <li>special styles selectors
      <ul>
        <li><strong>:host</strong><i>(.active)</i>  - the only way to target the host element</li>
        <li><strong>:host-context</strong><i>(.theme-light) h2</i> - look for a CSS class in any ancestor of the component host element, up to the document root</li>
      </ul>
    </li>
    <li><strong>custom elements</strong> from directive
      <ul>
        <li><code>ng add @angular/elements --name=PROJECT_NAME</code></li>
        <li>register in app.module.ts</li>
        <li>register in app.component.ts with createCustomElement()</li>
        <li>call in app</li>
        <li>can require ES6 TS output or polyfill</li>
      </ul>
    </li>
    <li>navigate down the view hierarchy: Query, QueryList, ViewChildren, and ContentChildren</li>
    <li><strong>directives</strong> are declared in Angular Modules in the same manner as components, can also be added to host elements with hostDirectives</li>
    <li><strong>Components</strong> - directives with a template and both share same descriptors</li>
    <li><strong>Attribute directives</strong> - change the appearance or behavior of an element, component, or another directive
      <ul>
        <li><code>&lt;p [appHighlight]="color"&gt;Highlight me!&lt;/p&gt;</code></li>
        <li><code>[appHighlight]="color"</code> sends current component value into directive when defined as <code>@Input('appHighlight') highlightColor: string;</code></li>
      </ul>
    </li>
    <li><strong>Structural directives</strong> - change the DOM layout by adding and removing DOM elements
      <ul>
        <li>directive class is spelled in UpperCamelCase (NgIf)</li>
        <li>directive attribute name is spelled in lowerCamelCase (ngIf)</li>
        <li>use &lt;ng-container&gt; to group multiple nested structural directives</li>
      </ul>
    </li>
    <li><strong>hostDirectives, directive composition API</strong></h3>
      <ul>
        <li><strong>only works with standalone directives</strong></li>
        <li>apply directives to a component host element from within the component TS class</li>
        <li>go through the same lifecycle as components and directives used directly in a template and always execute their constructor, lifecycle hooks, and bindings before the component or directive on which they are applied</li>
        <li>can override any host bindings specified by a host directive</li>
        <li>component or directive that specifies hostDirectives can inject the instances of those host directives and vice versa</li>
        <li>both the component and host directives can define providers</li>
        <li>if a component or directive with hostDirectives and those host directives both provide the same injection token, the providers defined by class with hostDirectives take precedence over providers defined by the host directives</li>
        <li><strong>many host directives balloon the memory used by application</strong></li>
      </ul>
    </li>
    <li><strong>pipe</strong> takes in data as input and transforms it to a desired output</li>
    <li>components, directives, and pipes can be marked as <code>standalone: true</code>:
      <ul>
        <li>classes marked as standalone do not need to be declared in an NgModule</li>
        <li>standalone components specify their dependencies directly instead of getting them through NgModule</li>
        <li>use standalone components with existing NgModule-based libraries or dependencies in your template, take full advantage of the existing ecosystem of Angular libraries</li>
        <li>see Routing for routes examples</li>
      </ul>
    </li>
    <li></li>


    <li><strong>Built-in directive</strong>: <a href="https://angular.io/api/common#directives">angular.io/api/common#directives</a></li>
  </ul>

  <pre><code class="ts">
    import {
      AfterContentChecked,
      AfterContentInit,
      AfterViewChecked,
      AfterViewInit,
      DoCheck,
      OnChanges,
      OnDestroy,
      OnInit,
      SimpleChanges
    } from '@angular/core';
    import { Component, Input } from '@angular/core';
    import { LoggerService }    from './logger.service';

    // class Hero {
    //   constructor(public name: string) {}
    // }
    import { Hero } from './hero';

    let nextId = 1;
    export class PeekABoo implements OnInit {
      constructor(private logger: LoggerService) { }
      // implement OnInit's `ngOnInit` method
      ngOnInit() { this.logIt(`OnInit`); }
      logIt(msg: string) {
        this.logger.log(`#${nextId++} ${msg}`);
      }
    }

    @Component({
      // supported selectors include: element, [attribute], .class, and :not()
      selector:    'app-hero-list', // component tag
      templateUrl: './hero-list.component.html', // host view: link OR inline template
      // template: `
      //   &lt;h1&gt;{{title}}&lt;/h1&gt;
      //   &lt;h2&gt;My favorite hero is: {{myHero}}&lt;/h2&gt;`,
      // template: ` // for child view hooks
      // &lt;div&gt;-- child view begins --&lt;/div&gt;
      //   &lt;app-child-view&gt;&lt;/app-child-view&gt;
      // &lt;div&gt;-- child view ends --&lt;/div&gt;
      // &lt;p *ngIf="comment" class="comment"&gt;
      //   {{comment}}
      // &lt;/p&gt;`,
      // template: ` // for content hooks
      // &lt;div&gt;-- projected content begins --&lt;/div&gt;
      //   &lt;ng-content&gt;&lt;/ng-content&gt;
      // &lt;div&gt;-- projected content ends --&lt;/div&gt;
      // &lt;p *ngIf="comment" class="comment"&gt;
      //   {{comment}}
      // &lt;/p&gt;`
      providers:  [ HeroService ], // array of services providers for component
      styles: ['p {background: LightYellow; padding: 8px}'],
      styleUrls: ['./hero-app.component.css'], // .scss, .less, .styl
      // encapsulation: ViewEncapsulation.Emulated|None|ShadowDom
    })
    // Don't HAVE to mention the Lifecycle Hook interfaces
    // unless we want typing and tool support.
    export class PeekABooComponent extends PeekABoo implements
                  OnChanges, OnInit, DoCheck,
                  AfterContentInit, AfterContentChecked,
                  AfterViewInit, AfterViewChecked,
                  OnDestroy {

      // --------------------------------

      @Input() name: string;
      @Input() hero: Hero;
      @Input() power: string;
      private verb = 'initialized';
      private logger: LoggerService;

      title = 'Tour of Heroes';
      myHero = 'Windstorm';
      // OR
      // title: string;
      // myHero: string;
      // constructor() {
      //   this.title = 'Tour of Heroes';
      //   this.myHero = 'Windstorm';
      // }

      heroes = ['Windstorm', 'Bombasto', 'Magneta', 'Tornado'];
      // OR
      // heroes = [
      //   new Hero(1, 'Windstorm'),
      //   new Hero(13, 'Bombasto'),
      //   new Hero(15, 'Magneta'),
      //   new Hero(20, 'Tornado')
      // ];
      // myHero = this.heroes[0];

      constructor(logger: LoggerService) {
        super(logger);
        let is = this.name ? 'is' : 'is not';
        this.logIt(`name ${is} known at construction`);
      }
      // only called for/if there is an @input variable set by parent.
      ngOnChanges(changes: SimpleChanges) {
        let changesMsgs: string[] = [];
        for (let propName in changes) {
          if (propName === 'name') {
            let name = changes['name'].currentValue;
            changesMsgs.push(`name ${this.verb} to "${name}"`);
          } else {
            changesMsgs.push(propName + ' ' + this.verb);
          }
          // let chng = changes[propName];
          // let cur  = JSON.stringify(chng.currentValue);
          // let prev = JSON.stringify(chng.previousValue);
          // this.changeLog.push(`${propName}: current = ${cur}, prev = ${prev}`);
        }
        this.logIt(`OnChanges: ${changesMsgs.join('; ')}`);
        this.verb = 'changed'; // next time it will be a change
      }
      oldPower = '';
      ngDoCheck() { // Called frequently!
        this.changeDetected = false;
        if (this.power !== this.oldPower) {
          this.changeDetected = true;
          this.changeLog.push(`to "${this.power}" from "${this.oldPower}"`);
          this.oldPower = this.power;
        }
      }

      // following are called frequently!
      /*
        @Component({
          selector: 'app-child-view',
          template: '&lt;input [(ngModel)]="hero"&gt;'
        })
        export class ChildViewComponent {
          hero = 'Magneta';
        }
      */
      @ContentChild(ChildViewComponent) ontentChild: ChildViewComponent;
      ngAfterContentChecked() {
        if (this.prevHero === this.contentChild.hero) {
          this.logIt('AfterContentChecked (no change)');
        } else {
          this.prevHero = this.contentChild.hero;
          this.logIt('AfterContentChecked');
          this.doSomething();
        }
      }
      ngAfterContentInit() {
        this.logIt('AfterContentInit');
        this.doSomething();
      }
      // hooks that Angular calls after it creates a component child views
      // Query for a VIEW child of type
      @ViewChild(ChildViewComponent) viewChild: ChildViewComponent;
      ngAfterViewChecked() {
        // viewChild is updated after the view has been checked
        if (this.prevHero === this.viewChild.hero) {
          this.logIt('AfterViewChecked (no change)');
        } else {
          this.prevHero = this.viewChild.hero;
          this.logIt('AfterViewChecked');
          this.doSomething();
        }
      }
      ngAfterViewInit() {
        // viewChild is set after the view has been initialized
        this.logIt('AfterViewInit');
        this.doSomething();
      }
      // surrogate for real business logic sets the `comment`
      private doSomething() {
        let c = this.viewChild.hero.length > 10 ? `That's a long name` : '';
        if (c !== this.comment) {
          // Wait a tick (!) because the component view has already been checked
          this.logger.tick_then(() => this.comment = c);
        }
        // logger tick functions, schedules a view refresh to ensure display catches up
        // tick() {  this.tick_then(() => { }); }
        // tick_then(fn: () => any) { setTimeout(fn, 0); }
        // ---
        this.comment = this.contentChild.hero.length > 10 ? `That's a long name` : '';
      }
      reset() {
        this.logger.clear();
        // quickly remove/reload AfterView/ContentComponent which recreates it
        this.show = false;
        this.logger.tick_then(() => this.show = true);
      }

      ngOnDestroy() { this.logIt(`OnDestroy`); }

      // --------------------------------
      hasChild = false;
      hookLog: string[];
      heroName = 'Windstorm';
      private logger: LoggerService;
      constructor(logger: LoggerService) {
        this.logger = logger;
        this.hookLog = logger.logs;
      }
      toggleChild() {
        this.hasChild = !this.hasChild;
        if (this.hasChild) {
          this.heroName = 'Windstorm';
          this.logger.clear(); // clear log on create
        }
        this.hookLog = this.logger.logs;
        this.logger.tick();
      }
      updateHero() {
        this.heroName += '!';
        this.logger.tick();
      }
      // --------------------------------
    }
  </code></pre>

  <h3>setting component inputs</h3>
  <pre><code class="ts">
    @Component({
      selector: 'app-bank-account',
      inputs: ['bankName', 'id: account-id'],
      template: `
        Bank Name: {{ bankName }}
        Account Id: {{ id }}`
    })
    export class BankAccountComponent {
      bankName: string|null = null;
      id: string|null = null;
      // this property is not bound, and wont be automatically updated by Angular
      normalizedBankName: string|null = null;
    }

    @Component({
      selector: 'app-my-input',
      template: `
        &lt;app-bank-account
          bankName="RBC"
          account-id="4747"&gt;
        &lt;/app-bank-account&gt;`
    })
    export class MyInputComponent { }
  </code></pre>

  <h3>setting component outputs</h3>
  <pre><code class="ts">
    // two event emitters that emit on an interval
    // emit an output every second, while the other emits every five seconds
    @Directive({
      selector: 'app-interval-dir',
      outputs: ['everySecond', 'fiveSecs: everyFiveSeconds']
    })
    export class IntervalDirComponent {
      everySecond = new EventEmitter&lt;string&gt;();
      fiveSecs = new EventEmitter&lt;string&gt;();
      constructor() {
        setInterval(() =&gt; this.everySecond.emit('event'), 1000);
        setInterval(() =&gt; this.fiveSecs.emit('event'), 5000);
      }
    }

    @Component({
      selector: 'app-my-output',
      template: `
        &lt;app-interval-dir
          (everySecond)="onEverySecond()"
          (everyFiveSeconds)="onEveryFiveSeconds()"&gt;
        &lt;/app-interval-dir&gt;`
    })
    export class MyOutputComponent {
      onEverySecond() { console.log('second'); }
      onEveryFiveSeconds() { console.log('five seconds'); }
    }
  </code></pre>

  <h3>injecting a class with a view provider</h3>
  <pre><code class="ts">
    class Greeter {
      greet(name:string) { return 'Hello ' + name + '!'; }
     }

     @Directive({
       selector: 'needs-greeter'
     })
     class NeedsGreeter {
       greeter:Greeter;
       constructor(greeter:Greeter) { this.greeter = greeter; }
     }

     @Component({
       selector: 'greet',
       viewProviders: [ Greeter ],
       template: `&lt;needs-greeter&gt;&lt;/needs-greeter&gt;`
     })
     class HelloWorld { }
  </code></pre>

  <h3>navigate the component tree with DI</h3>
  <pre><code class="ts">
    export abstract class Parent { name: string; }
    const DifferentParent = Parent;
    // Helper method to provide the current component instance in the name of a "parentType"
    // The "parentType" defaults to "Parent" when omitting the second parameter
    export function provideParent (component: any, parentType?: any) {
      return {
        provide: parentType || Parent,
        useExisting: forwardRef(() => component)
      };
    }

    @Component({
      selector: 'alice',
      template: `
        &lt;div class="a"&gt;
          &lt;h3&gt;{{name}}&lt;/h3&gt;
          &lt;barry&gt;&lt;/barry&gt;
          &lt;beth&gt;&lt;/beth&gt;
          &lt;bob&gt;&lt;/bob&gt;
          &lt;carol&gt;&lt;/carol&gt;
        &lt;/div&gt; `,
      providers:  [ provideParent(AliceComponent) ]
    })
    export class AliceComponent implements Parent {
      name = 'Alice';
    }

    const templateB = `
    &lt;div class="b"&gt;
      &lt;div&gt;
        &lt;h3&gt;{{name}}&lt;/h3&gt;
        &lt;p&gt;My parent is {{parent?.name}}&lt;/p&gt;
      &lt;/div&gt;
      &lt;carol&gt;&lt;/carol&gt;
      &lt;chris&gt;&lt;/chris&gt;
    &lt;/div&gt;`;
    @Component({
      selector:   'barry',
      template:   templateB,
      providers:  [{
        // token
        provide: Parent,
        // break circular reference by having refer to itself
        useExisting: forwardRef(() => BarryComponent)
      }]
    })
    export class BarryComponent implements Parent {
      name = 'Barry';
      constructor( @SkipSelf() @Optional() public parent: Parent ) { }
    }
    @Component({
      selector:   'bob',
      template:   templateB,
      providers:  [ provideParent(BobComponent) ]
    })
    export class BobComponent implements Parent {
      name = 'Bob';
      constructor( @SkipSelf() @Optional() public parent: Parent ) { }
    }
    @Component({
      selector:   'beth',
      template:   templateB,
      providers:  [ provideParent(BethComponent, DifferentParent) ]
    })
    export class BethComponent implements Parent {
      name = 'Beth';
      constructor( @SkipSelf() @Optional() public parent: Parent ) { }
    }

    // Alice
    // - Barry, My parent is Alice
    // - - Carol, My parent is Barry
    // - - Chris, My parent is Barry
    // - Beth, My parent is Alice
    // - - Carol, My parent is Beth
    // - - Chris, My parent is Beth
    // - Bob, My parent is Alice
    // - - Carol, My parent is Bob
    // - - Chris, My parent is Bob
    // - Carol, My parent is Alice
  </code></pre>

  <br>
  <ul>
    <li>if the base component has injected dependencies, you must re-provide and re-inject them in the derived class and then pass them down to the base class through the constructor, when writing a component that inherits from another component</li>
    <li>Angular calls the derived class ngOnInit before calling the base class ngOnInit so you be using an array before he arrived</li>
  </ul>
  <br>

  <h3>inject into a derived class</h3>
  <pre><code class="ts">
    @Component({
      selector: 'app-unsorted-heroes',
      template: `&lt;div *ngFor="let hero of heroes"&gt;{{hero.name}}&lt;/div&gt;`,
      providers: [HeroService]
    })
    export class HeroesBaseComponent implements OnInit {
      constructor(private heroService: HeroService) { }
      heroes: Array&lt;Hero&gt;;
      ngOnInit() {
        this.heroes = this.heroService.getAllHeroes();
        this.afterGetHeroes();
      }
      // Post-process heroes in derived class override.
      protected afterGetHeroes() {}
    }
    //--------------------------------
    @Component({
      selector: 'app-sorted-heroes',
      template: `&lt;div *ngFor="let hero of heroes"&gt;{{hero.name}}&lt;/div&gt;`,
      providers: [HeroService]
    })
    export class SortedHeroesComponent extends HeroesBaseComponent {
      constructor(heroService: HeroService) {
        super(heroService);
      }
      protected afterGetHeroes() {
        this.heroes = this.heroes.sort((h1, h2) => {
          return h1.name &lt; h2.name ? -1 :
                (h1.name > h2.name ? 1 : 0);
        });
      }
    }
  </code></pre>

  <h3>custom directive</h3>
  <pre><code class="ts">
    import { Directive, OnInit, OnDestroy } from '@angular/core';
    import { LoggerService } from './logger.service';
    let nextId = 1;
    // Spy on any element to which it is applied, usage:
    // &lt;div mySpy&gt;...&lt;/div&gt;
    // &lt;div *ngFor="let hero of heroes" mySpy class="heroes"&gt;&lt;/div&gt;
    @Directive({
      // supported selectors include: element, [attribute], .class, and :not()
      selector: '[mySpy]'
    })
    export class SpyDirective implements OnInit, OnDestroy {
      constructor(private logger: LoggerService) { }
      ngOnInit()    { this.logIt(`onInit`); }
      ngOnDestroy() { this.logIt(`onDestroy`); }
      private logIt(msg: string) {
        this.logger.log(`Spy #${nextId++} ${msg}`);
      }
    }
  </code></pre>

  <h3>standalone components</h3>
  <pre><code class="ts">
    // --- PhotoGalleryComponent can directly import another standalone component ImageGridComponent
    @Component({
      standalone: true,
      selector: 'photo-gallery',
      imports: [ImageGridComponent], // used to reference standalone directives and pipes
      template: `
        ... &lt;image-grid [images]="imageList"&gt;&lt;/image-grid&gt;
      `,
    })
    export class PhotoGalleryComponent {
      // component logic
    }

    // --- using existing NgModules in a standalone component:
    // not marked as standalone, but instead declared and exported by an existing NgModule
    // import the NgModule directly into the standalone component
    @Component({
      standalone: true,
      selector: 'photo-gallery',
      // an existing module is imported directly into a standalone component
      imports: [MatButtonModule],
      template: `
        ... &lt;button mat-button&gt;Next Page&lt;/button&gt;
      `,
    })
    export class PhotoGalleryComponent {
      // logic
    }

    // --- using standalone components in NgModule-based applications
    // imported into existing NgModules-based contexts
    @NgModule({
      declarations: [AlbumComponent],
      exports: [AlbumComponent],
      imports: [PhotoGalleryComponent],
    })
    export class AlbumModule {}

    // --- bootstrapping an application using a standalone component
    // bootstrap Angular app without any NgModule by using a standalone component as the app root component.
    // in the main.ts file
    import {bootstrapApplication} from '@angular/platform-browser';
    import {PhotoAppComponent} from './app/photo.app.component';
    bootstrapApplication(PhotoAppComponent);
    // configuring dependency injection
    // is based on explicitly configuring a list of Providers for dependency injection
    // "provide"-prefixed functions can be used to configure different systems without needing to import NgModules
    bootstrapApplication(PhotoAppComponent, {
      providers: [
        {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},
        provideRouter([ /* app routes */ ]), // in place of RouterModule.forRoot, to configure the router
        // ...
      ]
    });
    // existing libraries may rely on NgModules for configuring DI
    // Angular router uses the RouterModule.forRoot() helper to set up routing in an application
    // use existing NgModules in bootstrapApplication via the importProvidersFrom utility
    bootstrapApplication(PhotoAppComponent, {
      providers: [
        {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},
        importProvidersFrom(
          RouterModule.forRoot([/* app routes */]),
        ),
        // ...
      ]
    });
  </code></pre>

  <h3>directive composition API, hostDirectives</h3>
  <pre><code class="ts">
    // instantiated: MenuBehavior - AdminMenu
    // receives inputs (ngOnInit): MenuBehavior - AdminMenu
    // applies host bindings: MenuBehavior - AdminMenu
    @Component({
      selector: 'admin-menu',
      template: 'admin-menu.html',
      hostDirectives: [MenuBehavior],
    })
    export class AdminMenu { }
    @Component({
      selector: 'mat-menu',
      hostDirectives: [
        HasColor, // reuses all the inputs, outputs, and associated logic
        {
          directive: CdkMenu, // reuse only the logic and the selected inputs
          inputs: ['cdkMenuDisabled: disabled'],
          outputs: ['cdkMenuClosed: closed']
        }
      ]
    })
    class MatMenu {}
    // order of operations extends to nested chains of host directives:
    // instantiated: Tooltip - CustomTooltip - EvenMoreCustomTooltip
    // receives inputs: Tooltip - CustomTooltip - EvenMoreCustomTooltip
    // applies host bindings: Tooltip - CustomTooltip - EvenMoreCustomTooltip
    @Directive({...})
    export class Tooltip { }
    @Directive({
      hostDirectives: [Tooltip],
    })
    export class CustomTooltip { }
    @Directive({
      hostDirectives: [CustomTooltip],
    })
    export class EvenMoreCustomTooltip { }
  </code></pre>

  <h3>class field decorators for directives and components</h3>

  <h4>@HostBinding</h4>
  <pre><code class="ts">
    // marks a DOM property as a host-binding property
    // and supplies configuration metadata.
    // create a directive that sets the valid and invalid properties
    //on the DOM element that has an ngModel directive on it:

    @Directive({selector: '[ngModel]'})
    class NgModelStatus {
      constructor(public control: NgModel) {}
      @HostBinding('class.valid') get valid() { return this.control.valid; }
      @HostBinding('class.invalid') get invalid() { return this.control.invalid; }
    }

    @Component({
      selector: 'app',
      template: `&lt;input [(ngModel)]="prop"&gt;`,
    })
    class App {
      prop;
    }
  </code></pre>

  <h4>@HostListener</h4>
  <pre><code class="ts">
    // declares a DOM event to listen for,
    // and provides a handler method to run when that event occurs
    // - eventName - CSS event to listen for
    // - args - set of arguments to pass to the handler method when the event occurs
    // attach a click listener to a button and counts clicks:
    @Directive({selector: 'button[counting]'})
    class CountClicks {
      numberOfClicks = 0;
      @HostListener('click', ['$event.target'])
      onClick(btn) {
        console.log('button', btn, 'number of clicks:', this.numberOfClicks++);
     }
    }
    @Component({
      selector: 'app',
      template: '&lt;button counting&gt;Increment&lt;/button&gt;'
    })
    class App {}
  </code></pre>

  <h4>@ViewChildren</h4>
  <pre><code class="ts">
    // get the QueryList of elements or directives from the view DOM
    // any time a child element is added/removed/moved, the query list will be updated,
    // and the changes observable of the query list will emit a new value
    // view queries are set before the ngAfterViewInit callback is called
    // metadata properties:
    // selector - the directive type or the name used for querying
    // read - read a different token from the queried elements
    // --- ---
    import {
      AfterViewInit, Component, Directive, QueryList, ViewChildren
    } from '@angular/core';
    @Directive({selector: 'child-directive'})
    class ChildDirective { }
    @Component({selector: 'someCmp', templateUrl: 'someCmp.html'})
    class SomeCmp implements AfterViewInit {
      // TODO(issue/24571): remove '!'.
      @ViewChildren(ChildDirective) viewChildren !: QueryList&lt;ChildDirective&gt;;
      ngAfterViewInit() {
        // viewChildren is set
      }
    }
    // --- ---
    import {
      AfterViewInit, Component, Directive, Input, QueryList, ViewChildren
    } from '@angular/core';
    @Directive({selector: 'pane'})
    export class Pane {
      // TODO(issue/24571): remove '!'.
      @Input() id !: string;
    }
    @Component({
      selector: 'example-app',
      template: `
        &lt;pane id="1"&gt;&lt;/pane&gt;
        &lt;pane id="2"&gt;&lt;/pane&gt;
        &lt;pane id="3" *ngIf="shouldShow"&gt;&lt;/pane&gt;
        &lt;button (click)="show()"&gt;Show 3&lt;/button&gt;
        &lt;div&gt;panes: {{serializedPanes}}&lt;/div&gt;`,
    })
    export class ViewChildrenComp implements AfterViewInit {
      // TODO(issue/24571): remove '!'.
      @ViewChildren(Pane) panes !: QueryList&lt;Pane&gt;;
      serializedPanes: string = '';
      shouldShow = false;
      show() { this.shouldShow = true; }
      ngAfterViewInit() {
        this.calculateSerializedPanes();
        this.panes.changes.subscribe((r) =&gt; { this.calculateSerializedPanes(); });
      }
      calculateSerializedPanes() {
        setTimeout(() =&gt; { this.serializedPanes = this.panes.map(p =&gt; p.id).join(', '); }, 0);
      }
    }
  </code></pre>

  <h4>@ViewChild</h4>
  <pre><code class="ts">
    // looks for the first element or the directive matching the selector in the view DOM
    // updated on changes
    // view queries are set before the ngAfterViewInit callback is called
    // metadata properties:
    // selector - the directive type or the name used for querying
    // read - read a different token from the queried elements
    // static - whether or not to resolve query results before change detection runs
    //   default is false (i.e. return static results only)
    //   uses query results to determine the timing of query resolution
    //   if any query results are inside a nested view (e.g. *ngIf),
    //   the query will be resolved after change detection runs
    //   otherwise, it will be resolved before change detection runs
    //
    // supported selectors include:
    // - any class with the @Component or @Directive decorator
    // - template reference variable as a string
    // (e.g. query &lt;my-component #cmp&gt;&lt;/my-component&gt; with @ViewChild('cmp'))
    // - any provider defined in the child component tree of the current component
    // (e.g. @ViewChild(SomeService) someService: SomeService)
    // - any provider defined through a string token
    // (e.g. @ViewChild('someToken') someTokenVal: any)
    // - TemplateRef (e.g. query &lt;ng-template&gt;&lt;/ng-template&gt; with @ViewChild(TemplateRef) template;)
    // --- ---
    import {Component, Directive, Input, ViewChild} from '@angular/core';
    @Directive({selector: 'pane'})
    export class Pane {
      // TODO(issue/24571): remove '!'.
      @Input() id !: string;
    }
    @Component({
      selector: 'example-app',
      template: `
        &lt;pane id="1" *ngIf="shouldShow"&gt;&lt;/pane&gt;
        &lt;pane id="2" *ngIf="!shouldShow"&gt;&lt;/pane&gt;
        &lt;button (click)="toggle()"&gt;Toggle&lt;/button&gt;
        &lt;div&gt;Selected: {{selectedPane}}&lt;/div&gt;
      `,
    })
    export class ViewChildComp {
      @ViewChild(Pane, {static: false})
      set pane(v: Pane) {
        setTimeout(() =&gt; { this.selectedPane = v.id; }, 0);
      }
      selectedPane: string = '';
      shouldShow = true;
      toggle() { this.shouldShow = !this.shouldShow; }
    }
    // --- ---
    import {AfterViewInit, Component, Directive, ViewChild} from '@angular/core';
    @Directive({selector: 'child-directive'})
    class ChildDirective { }
    @Component({selector: 'someCmp', templateUrl: 'someCmp.html'})
    class SomeCmp implements AfterViewInit {
      // TODO(issue/24571): remove '!'.
      @ViewChild(ChildDirective, {static: false}) child !: ChildDirective;
      ngAfterViewInit() {
        // child is set
      }
    }
    // --- ---
    import {Component, Directive, Input, ViewChild} from '@angular/core';
    @Directive({selector: 'pane'})
    export class Pane {
      // TODO(issue/24571): remove '!'.
      @Input() id !: string;
    }
    @Component({
      selector: 'example-app',
      template: `
        &lt;pane id="1" *ngIf="shouldShow"&gt;&lt;/pane&gt;
        &lt;pane id="2" *ngIf="!shouldShow"&gt;&lt;/pane&gt;
        &lt;button (click)="toggle()"&gt;Toggle&lt;/button&gt;
        &lt;div&gt;Selected: {{selectedPane}}&lt;/div&gt;
      `,
    })
    export class ViewChildComp {
      @ViewChild(Pane, {static: false})
      set pane(v: Pane) {
        setTimeout(() =&gt; { this.selectedPane = v.id; }, 0);
      }
      selectedPane: string = '';
      shouldShow = true;
      toggle() { this.shouldShow = !this.shouldShow; }
    }
  </code></pre>

  <h4>@ContentChildren</h4>
  <pre><code class="ts">
    // get the QueryList of elements/directives from the view DOM, updated on changes
    // content queries are set before the ngAfterContentInit callback is called
    // metadata properties:
    // selector - the directive type or the name used for querying
    // descendants - include only direct children or all descendants
    // read - read a different token from the queried elements
    // --- ---
    import {AfterContentInit, ContentChildren, Directive, QueryList} from '@angular/core';
    @Directive({selector: 'child-directive'})
    class ChildDirective { }
    @Directive({selector: 'someDir'})
    class SomeDir implements AfterContentInit {
      // TODO(issue/24571): remove '!'.
      @ContentChildren(ChildDirective) contentChildren !: QueryList&lt;ChildDirective&gt;;
      ngAfterContentInit() {
        // contentChildren is set
      }
    }
    // --- --- implement a tab pane component
    import {Component, ContentChildren, Directive, Input, QueryList} from '@angular/core';
    @Directive({selector: 'pane'})
    export class Pane {
      // TODO(issue/24571): remove '!'.
      @Input() id !: string;
    }
    @Component({
      selector: 'tab',
      template: `
        &lt;div class="top-level"&gt;Top level panes: {{serializedPanes}}&lt;/div&gt;
        &lt;div class="nested"&gt;Arbitrary nested panes: {{serializedNestedPanes}}&lt;/div&gt;`
    })
    export class Tab {
      @ContentChildren(Pane) topLevelPanes !: QueryList&lt;Pane&gt;;
      @ContentChildren(Pane, {descendants: true}) arbitraryNestedPanes !: QueryList&lt;Pane&gt;;

      get serializedPanes(): string {
        return this.topLevelPanes ? this.topLevelPanes.map(p =&gt; p.id).join(', ') : '';
      }
      get serializedNestedPanes(): string {
        return this.arbitraryNestedPanes ?
          this.arbitraryNestedPanes.map(p =&gt; p.id).join(', ') : '';
      }
    }
    @Component({
      selector: 'example-app',
      template: `
        &lt;tab&gt;
          &lt;pane id="1"&gt;&lt;/pane&gt;
          &lt;pane id="2"&gt;&lt;/pane&gt;
          &lt;pane id="3" *ngIf="shouldShow"&gt;
            &lt;tab&gt;
              &lt;pane id="3_1"&gt;&lt;/pane&gt;
              &lt;pane id="3_2"&gt;&lt;/pane&gt;
            &lt;/tab&gt;
          &lt;/pane&gt;
        &lt;/tab&gt;
        &lt;button (click)="show()"&gt;Show 3&lt;/button&gt;`,
    })
    export class ContentChildrenComp {
      shouldShow = false;
      show() { this.shouldShow = true; }
    }
  </code></pre>

  <h4>@ContentChild</h4>
  <pre><code class="ts">
    // first element/directive matching the selector, updated on changes
    // metadata properties:
    // selector - the directive type or the name used for querying
    // read - read a different token from the queried elements
    // --- ---
    import {AfterContentInit, ContentChild, Directive} from '@angular/core';
    @Directive({selector: 'child-directive'})
    class ChildDirective { }
    @Directive({selector: 'someDir'})
    class SomeDir implements AfterContentInit {
      @ContentChild(ChildDirective) contentChild !: ChildDirective;
      ngAfterContentInit() {
        // contentChild is set
      }
    }
    // --- ---
    import {Component, ContentChild, Directive, Input} from '@angular/core';
    @Directive({selector: 'pane'})
    export class Pane {
      // TODO(issue/24571): remove '!'.
      @Input() id !: string;
    }
    @Component({
      selector: 'tab',
      template: `
        &lt;div&gt;pane: {{pane?.id}}&lt;/div&gt;`
    })
    export class Tab {
      // TODO(issue/24571): remove '!'.
      @ContentChild(Pane) pane !: Pane;
    }
    @Component({
      selector: 'example-app',
      template: `
        &lt;tab&gt;
          &lt;pane id="1" *ngIf="shouldShow"&gt;&lt;/pane&gt;
          &lt;pane id="2" *ngIf="!shouldShow"&gt;&lt;/pane&gt;
        &lt;/tab&gt;
        &lt;button (click)="toggle()"&gt;Toggle&lt;/button&gt;`
    })
    export class ContentChildComp {
      shouldShow = true;
      toggle() { this.shouldShow = !this.shouldShow; }
    }
  </code></pre>



<h2 id="inter">Interaction + tests</h2>

  <details><summary>pass data from parent to child with input binding</summary>
  <pre><code class="ts">
    @Component({
      selector: 'app-hero-child',
      template: `
        &lt;h3&gt;{{hero.name}} says:&lt;/h3&gt;
        &lt;p&gt;I, {{hero.name}}, am at your service, {{masterName}}.&lt;/p&gt;
      `
    })
    export class HeroChildComponent {
      @Input() hero: Hero;
      @Input('master') masterName: string;
    }
    // -----------------------------
    @Component({
      selector: 'app-hero-parent',
      template: `
        &lt;h2&gt;{{master}} controls {{heroes.length}} heroes&lt;/h2&gt;
        &lt;app-hero-child *ngFor="let hero of heroes"
          [hero]="hero"
          [master]="master"&gt;
        &lt;/app-hero-child&gt;
      `
    })
    export class HeroParentComponent {
      heroes = HEROES;
      master = 'Master';
    }
    //--------------------------------
    // ...
    let _heroNames = ['Mr. IQ', 'Magneta', 'Bombasto'];
    let _masterName = 'Master';

    it('should pass properties to children properly', function () {
      let parent = element.all(by.tagName('app-hero-parent')).get(0);
      let heroes = parent.all(by.tagName('app-hero-child'));

      for (let i = 0; i &lt; _heroNames.length; i++) {
        let childTitle = heroes.get(i).element(by.tagName('h3')).getText();
        let childDetail = heroes.get(i).element(by.tagName('p')).getText();
        expect(childTitle).toEqual(_heroNames[i] + ' says:');
        expect(childDetail).toContain(_masterName);
      }
    });
    // ...
  </code></pre></details>

  <details><summary>intercept input property changes with a setter</summary>
  <pre><code class="ts">
    @Component({
      selector: 'app-name-child',
      template: '&lt;h3&gt;"{{name}}"&lt;/h3&gt;'
    })
    export class NameChildComponent {
      private _name = '';
      @Input()
      set name(name: string) {
        this._name = (name && name.trim()) || '&lt;no name set&gt;';
      }
      get name(): string { return this._name; }
    }
    //--------------------------------
    @Component({
      selector: 'app-name-parent',
      template: `
      &lt;h2&gt;Master controls {{names.length}} names&lt;/h2&gt;
      &lt;app-name-child *ngFor="let name of names" [name]="name"&gt;&lt;/app-name-child&gt;
      `
    })
    export class NameParentComponent {
      // Displays 'Mr. IQ', '&lt;no name set&gt;', 'Bombasto'
      names = ['Mr. IQ', '   ', '  Bombasto  '];
    }
    //--------------------------------
    // ...
    it('should display trimmed, non-empty names', function () {
      let _nonEmptyNameIndex = 0;
      let _nonEmptyName = '"Mr. IQ"';
      let parent = element.all(by.tagName('app-name-parent')).get(0);
      let hero = parent.all(by.tagName('app-name-child')).get(_nonEmptyNameIndex);

      let displayName = hero.element(by.tagName('h3')).getText();
      expect(displayName).toEqual(_nonEmptyName);
    });
    it('should replace empty name with default name', function () {
      let _emptyNameIndex = 1;
      let _defaultName = '"&lt;no name set&gt;"';
      let parent = element.all(by.tagName('app-name-parent')).get(0);
      let hero = parent.all(by.tagName('app-name-child')).get(_emptyNameIndex);

      let displayName = hero.element(by.tagName('h3')).getText();
      expect(displayName).toEqual(_defaultName);
    });
    // ...
  </code></pre></details>

  <details><summary>intercept input property changes with ngOnChanges()</summary>
  <pre><code class="ts">
    //--------------------------------
    // prefer this approach to the property setter
    // when watching multiple, interacting input properties
    //--------------------------------
    import { Component, Input, OnChanges, SimpleChange } from '@angular/core';
    @Component({
      selector: 'app-version-child',
      template: `
        &lt;h3&gt;Version {{major}}.{{minor}}&lt;/h3&gt;
        &lt;h4&gt;Change log:&lt;/h4&gt;
        &lt;ul&gt;
          &lt;li *ngFor="let change of changeLog"&gt;{{change}}&lt;/li&gt;
        &lt;/ul&gt;
      `
    })
    export class VersionChildComponent implements OnChanges {
      @Input() major: number;
      @Input() minor: number;
      changeLog: string[] = [];
      ngOnChanges(changes: {[propKey: string]: SimpleChange}) {
        let log: string[] = [];
        for (let propName in changes) {
          let changedProp = changes[propName];
          let to = JSON.stringify(changedProp.currentValue);
          if (changedProp.isFirstChange()) {
            log.push(`Initial value of ${propName} set to ${to}`);
          } else {
            let from = JSON.stringify(changedProp.previousValue);
            log.push(`${propName} changed from ${from} to ${to}`);
          }
        }
        this.changeLog.push(log.join(', '));
      }
    }
    //--------------------------------
    import { Component } from '@angular/core';
    @Component({
      selector: 'app-version-parent',
      template: `
        &lt;h2&gt;Source code version&lt;/h2&gt;
        &lt;button (click)="newMinor()"&gt;New minor version&lt;/button&gt;
        &lt;button (click)="newMajor()"&gt;New major version&lt;/button&gt;
        &lt;app-version-child [major]="major" [minor]="minor"&gt;&lt;/app-version-child&gt;
      `
    })
    export class VersionParentComponent {
      major = 1;
      minor = 23;
      newMinor() { this.minor++; }
      newMajor() { this.major++; this.minor = 0; }
    }
    //--------------------------------
    // ...
    // Test must all execute in this exact order
    it('should set expected initial values', function () {
      let actual = getActual();
      let initialLabel = 'Version 1.23';
      let initialLog = 'Initial value of major set to 1, Initial value of minor set to 23';
      expect(actual.label).toBe(initialLabel);
      expect(actual.count).toBe(1);
      expect(actual.logs.get(0).getText()).toBe(initialLog);
    });
    it('should set expected values after clicking \'Minor\' twice', function () {
      let repoTag = element(by.tagName('app-version-parent'));
      let newMinorButton = repoTag.all(by.tagName('button')).get(0);
      newMinorButton.click().then(function() {
        newMinorButton.click().then(function() {
          let actual = getActual();
          let labelAfter2Minor = 'Version 1.25';
          let logAfter2Minor = 'minor changed from 24 to 25';
          expect(actual.label).toBe(labelAfter2Minor);
          expect(actual.count).toBe(3);
          expect(actual.logs.get(2).getText()).toBe(logAfter2Minor);
        });
      });
    });
    it('should set expected values after clicking \'Major\' once', function () {
      let repoTag = element(by.tagName('app-version-parent'));
      let newMajorButton = repoTag.all(by.tagName('button')).get(1);
      newMajorButton.click().then(function() {
        let actual = getActual();
        let labelAfterMajor = 'Version 2.0';
        let logAfterMajor = 'major changed from 1 to 2, minor changed from 25 to 0';
        expect(actual.label).toBe(labelAfterMajor);
        expect(actual.count).toBe(4);
        expect(actual.logs.get(3).getText()).toBe(logAfterMajor);
      });
    });
    function getActual() {
      let versionTag = element(by.tagName('app-version-child'));
      let label = versionTag.element(by.tagName('h3')).getText();
      let ul = versionTag.element((by.tagName('ul')));
      let logs = ul.all(by.tagName('li'));
      return {
        label: label,
        logs: logs,
        count: logs.count()
      };
    }
    // ...
  </code></pre></details>

  <details><summary>parent listens for child event</summary>
  <pre><code class="ts">
    import { Component, EventEmitter, Input, Output } from '@angular/core';
    @Component({
      selector: 'app-voter',
      template: `
        &lt;h4&gt;{{name}}&lt;/h4&gt;
        &lt;button (click)="vote(true)"  [disabled]="didVote"&gt;Agree&lt;/button&gt;
        &lt;button (click)="vote(false)" [disabled]="didVote"&gt;Disagree&lt;/button&gt;
      `
    })
    export class VoterComponent {
      @Input()  name: string;
      @Output() voted = new EventEmitter&lt;boolean&gt;();
      didVote = false;
      vote(agreed: boolean) {
        this.voted.emit(agreed);
        this.didVote = true;
      }
    }
    //--------------------------------
    import { Component }      from '@angular/core';
    @Component({
      selector: 'app-vote-taker',
      template: `
        &lt;h2&gt;Should mankind colonize the Universe?&lt;/h2&gt;
        &lt;h3&gt;Agree: {{agreed}}, Disagree: {{disagreed}}&lt;/h3&gt;
        &lt;app-voter *ngFor="let voter of voters"
          [name]="voter"
          (voted)="onVoted($event)"&gt;
        &lt;/app-voter&gt;
      `
    })
    export class VoteTakerComponent {
      agreed = 0;
      disagreed = 0;
      voters = ['Mr. IQ', 'Ms. Universe', 'Bombasto'];
      onVoted(agreed: boolean) {
        agreed ? this.agreed++ : this.disagreed++;
      }
    }
    //--------------------------------
    // ...
    it('should not emit the event initially', function () {
      let voteLabel = element(by.tagName('app-vote-taker'))
        .element(by.tagName('h3')).getText();
      expect(voteLabel).toBe('Agree: 0, Disagree: 0');
    });
    it('should process Agree vote', function () {
      let agreeButton1 = element.all(by.tagName('app-voter')).get(0)
        .all(by.tagName('button')).get(0);
      agreeButton1.click().then(function() {
        let voteLabel = element(by.tagName('app-vote-taker'))
          .element(by.tagName('h3')).getText();
        expect(voteLabel).toBe('Agree: 1, Disagree: 0');
      });
    });
    it('should process Disagree vote', function () {
      let agreeButton1 = element.all(by.tagName('app-voter')).get(1)
        .all(by.tagName('button')).get(1);
      agreeButton1.click().then(function() {
        let voteLabel = element(by.tagName('app-vote-taker'))
          .element(by.tagName('h3')).getText();
        expect(voteLabel).toBe('Agree: 1, Disagree: 1');
      });
    });
    // ...
  </code></pre></details>

  <details><summary>parent interacts with child via local variable</summary>
  <pre><code class="ts">
    //--------------------------------
    // read child properties or invoke child methods
    // by creating a template reference variable
    // for the child element and then reference that variable within the parent template
    //
    // parent component cannot data bind to the child start and stop methods
    // nor to its seconds property
    //
    // wire parent buttons to the child start and stop
    // and use interpolation to display the child seconds property
    //--------------------------------
    import { Component, OnDestroy, OnInit } from '@angular/core';
    @Component({
      selector: 'app-countdown-timer',
      template: '&lt;p&gt;{{message}}&lt;/p&gt;'
    })
    export class CountdownTimerComponent implements OnInit, OnDestroy {
      intervalId = 0;
      message = '';
      seconds = 11;
      clearTimer() { clearInterval(this.intervalId); }
      ngOnInit()    { this.start(); }
      ngOnDestroy() { this.clearTimer(); }
      start() { this.countDown(); }
      stop()  {
        this.clearTimer();
        this.message = `Holding at T-${this.seconds} seconds`;
      }
      private countDown() {
        this.clearTimer();
        this.intervalId = window.setInterval(() =&gt; {
          this.seconds -= 1;
          if (this.seconds === 0) {
            this.message = 'Blast off!';
          } else {
            if (this.seconds &lt; 0) { this.seconds = 10; } // reset
            this.message = `T-${this.seconds} seconds and counting`;
          }
        }, 1000);
      }
    }
    //--------------------------------
    import { Component }                from '@angular/core';
    import { CountdownTimerComponent }  from './countdown-timer.component';
    @Component({
      selector: 'app-countdown-parent-lv',
      template: `
      &lt;h3&gt;Countdown to Liftoff (via local variable)&lt;/h3&gt;
      &lt;button (click)="timer.start()"&gt;Start&lt;/button&gt;
      &lt;button (click)="timer.stop()"&gt;Stop&lt;/button&gt;
      &lt;div class="seconds"&gt;{{timer.seconds}}&lt;/div&gt;
      &lt;app-countdown-timer #timer&gt;&lt;/app-countdown-timer&gt;
      `,
      styleUrls: ['../assets/demo.css']
    })
    export class CountdownLocalVarParentComponent { }
    //--------------------------------
    // ...
    it('timer and parent seconds should match', function () {
      let parent = element(by.tagName(parentTag));
      let message = parent.element(by.tagName('app-countdown-timer')).getText();
      browser.sleep(10); // give `seconds` a chance to catchup with `message`
      let seconds = parent.element(by.className('seconds')).getText();
      expect(message).toContain(seconds);
    });
    it('should stop the countdown', function () {
      let parent = element(by.tagName(parentTag));
      let stopButton = parent.all(by.tagName('button')).get(1);
      stopButton.click().then(function() {
        let message = parent.element(by.tagName('app-countdown-timer')).getText();
        expect(message).toContain('Holding');
      });
    });
    // ...
  </code></pre></details>

  <details><summary>parent calls an @ViewChild()</summary>
  <pre><code class="ts">
    // if an instance of the parent component class must
    // read or write child component values or must call child component methods
    // inject the child component into the parent as a ViewChild
    //--------------------------------
    import { AfterViewInit, ViewChild } from '@angular/core';
    import { Component }                from '@angular/core';
    import { CountdownTimerComponent }  from './countdown-timer.component';
    @Component({
      selector: 'app-countdown-parent-vc',
      template: `
      &lt;h3&gt;Countdown to Liftoff (via ViewChild)&lt;/h3&gt;
      &lt;button (click)="start()"&gt;Start&lt;/button&gt;
      &lt;button (click)="stop()"&gt;Stop&lt;/button&gt;
      &lt;div class="seconds"&gt;{{ seconds() }}&lt;/div&gt;
      &lt;app-countdown-timer&gt;&lt;/app-countdown-timer&gt;
      `,
      styleUrls: ['../assets/demo.css']
    })
    export class CountdownViewChildParentComponent implements AfterViewInit {
      @ViewChild(CountdownTimerComponent)
      private timerComponent: CountdownTimerComponent;
      seconds() { return 0; }
      ngAfterViewInit() {
        // Redefine `seconds()` to get from the `CountdownTimerComponent.seconds` ...
        // but wait a tick first to avoid one-time devMode
        // unidirectional-data-flow-violation error
        setTimeout(() =&gt; this.seconds = () =&gt; this.timerComponent.seconds, 0);
      }
      start() { this.timerComponent.start(); }
      stop() { this.timerComponent.stop(); }
    }
    //--------------------------------
    // same E2E countdown timer tests as before
  </code></pre></details>

  <details><summary>parent and children communicate via a service</summary>
  <pre><code class="ts">
    //--------------------------------
    // share a service whose interface enables bi-directional communication
    //--------------------------------
    import { Injectable } from '@angular/core';
    import { Subject }    from 'rxjs';
    @Injectable()
    export class MissionService {
      // Observable string sources
      private missionAnnouncedSource = new Subject&lt;string&gt;();
      private missionConfirmedSource = new Subject&lt;string&gt;();
      // Observable string streams
      missionAnnounced$ = this.missionAnnouncedSource.asObservable();
      missionConfirmed$ = this.missionConfirmedSource.asObservable();
      // Service message commands
      announceMission(mission: string) {
        this.missionAnnouncedSource.next(mission);
      }
      confirmMission(astronaut: string) {
        this.missionConfirmedSource.next(astronaut);
      }
    }
    //--------------------------------
    import { Component }          from '@angular/core';
    import { MissionService }     from './mission.service';
    @Component({
      selector: 'app-mission-control',
      template: `
        &lt;h2&gt;Mission Control&lt;/h2&gt;
        &lt;button (click)="announce()"&gt;Announce mission&lt;/button&gt;
        &lt;app-astronaut *ngFor="let astronaut of astronauts"
          [astronaut]="astronaut"&gt;
        &lt;/app-astronaut&gt;
        &lt;h3&gt;History&lt;/h3&gt;
        &lt;ul&gt;
          &lt;li *ngFor="let event of history"&gt;{{event}}&lt;/li&gt;
        &lt;/ul&gt;
      `,
      providers: [MissionService]
    })
    export class MissionControlComponent {
      astronauts = ['Lovell', 'Swigert', 'Haise'];
      history: string[] = [];
      missions = ['Fly to the moon!',
                  'Fly to mars!',
                  'Fly to Vegas!'];
      nextMission = 0;
      constructor(private missionService: MissionService) {
        missionService.missionConfirmed$.subscribe(
          astronaut =&gt; {
            this.history.push(`${astronaut} confirmed the mission`);
          });
      }
      announce() {
        let mission = this.missions[this.nextMission++];
        this.missionService.announceMission(mission);
        this.history.push(`Mission "${mission}" announced`);
        if (this.nextMission &gt;= this.missions.length) { this.nextMission = 0; }
      }
    }
    //--------------------------------
    import { Component, Input, OnDestroy } from '@angular/core';
    import { MissionService } from './mission.service';
    import { Subscription }   from 'rxjs';
    @Component({
      selector: 'app-astronaut',
      template: `
        &lt;p&gt;
          {{astronaut}}: &lt;strong&gt;{{mission}}&lt;/strong&gt;
          &lt;button
            (click)="confirm()"
            [disabled]="!announced || confirmed"&gt;
            Confirm
          &lt;/button&gt;
        &lt;/p&gt;
      `
    })
    export class AstronautComponent implements OnDestroy {
      @Input() astronaut: string;
      mission = '&lt;no mission announced&gt;';
      confirmed = false;
      announced = false;
      subscription: Subscription;
      constructor(private missionService: MissionService) {
        this.subscription = missionService.missionAnnounced$.subscribe(
          mission =&gt; {
            this.mission = mission;
            this.announced = true;
            this.confirmed = false;
        });
      }
      confirm() {
        this.confirmed = true;
        this.missionService.confirmMission(this.astronaut);
      }
      ngOnDestroy() {
        // prevent memory leak when component destroyed
        this.subscription.unsubscribe();
      }
    }
    //--------------------------------
    // ...
    it('should announce a mission', function () {
      let missionControl = element(by.tagName('app-mission-control'));
      let announceButton = missionControl.all(by.tagName('button')).get(0);
      announceButton.click().then(function () {
        let history = missionControl.all(by.tagName('li'));
        expect(history.count()).toBe(1);
        expect(history.get(0).getText()).toMatch(/Mission.* announced/);
      });
    });
    it('should confirm the mission by Lovell', function () {
      testConfirmMission(1, 2, 'Lovell');
    });
    it('should confirm the mission by Haise', function () {
      testConfirmMission(3, 3, 'Haise');
    });
    it('should confirm the mission by Swigert', function () {
      testConfirmMission(2, 4, 'Swigert');
    });
    function testConfirmMission(buttonIndex: number, expectedLogCount: number, astronaut: string) {
      let _confirmedLog = ' confirmed the mission';
      let missionControl = element(by.tagName('app-mission-control'));
      let confirmButton = missionControl.all(by.tagName('button')).get(buttonIndex);
      confirmButton.click().then(function () {
        let history = missionControl.all(by.tagName('li'));
        expect(history.count()).toBe(expectedLogCount);
        expect(history.get(expectedLogCount - 1).getText()).toBe(astronaut + _confirmedLog);
      });
    }
    // ...
  </code></pre></details>



<h2 id="template">Template</h2>

  <ul>
    <li>backticks (`) for inline html-template readability</li>
    <li>&lt;script&gt; element is exception</li>
    <li>interpolation, embedding expressions - {{...}}</li>
    <li>expressions limitations
      <ul>
        <li>assignments (<strong>=</strong>, <strong>+=</strong>, <strong>-=</strong>, <strong>...</strong>)</li>
        <li>operators such as <strong>new</strong>, <strong>typeof</strong>, <strong>instanceof</strong>, etc.</li>
        <li>chaining expressions with <strong>;</strong> or <strong>,</strong></li>
        <li>the increment and decrement operators <strong>++</strong> and <strong>--</strong></li>
        <li>some of the ES2015+ operators</li>
        <li>no support for the bitwise operators such as <strong>|</strong> and <strong>&amp;</strong></li>
        <li>new template expression operators, such as <strong>|</strong>, <strong>?.</strong> and <strong>!</strong></li>
        <li>etc.</li>
      </ul>
    </li>
    <li>template expression should not change any application state other than the value of the target property</li>
    <li>consider caching values when their computation is expensive</li>
    <li>template statements cannot refer to anything in the global namespace, window or document, console.log or Math.max</li>
    <li>you are not setting attributes, you are <strong>setting the properties of DOM elements, components, and directives</strong></li>
    <li>HTML attribute and the DOM property are not the same thing, even when they have the same name
      <ul>
        <li>attributes are defined by HTML, properties are defined by the DOM (Document Object Model)</li>
        <li>attributes initialize DOM properties and then they are done, property values can change; attribute values cant</li>
        <li>HTML attribute value specifies the initial value; the DOM value property is the current value</li>
        <li><strong>template binding works with properties and events, not attributes</strong></li>
        <li>in Angular the only role of attributes is to initialize element and directive state, when you write a data binding, you are dealing exclusively with properties and events of the target object, HTML attributes effectively disappear</li>
      </ul>
    </li>
    <li>stick to data properties and to methods that return values and do no more</li>
    <li>return and send the proper type</li>
    <li>brackets ([]) tell Angular to evaluate the template expression, omiteed brackets are treated the string as a constant and initializes the target property with that string, omit the brackets when all of the following are true
      <ul>
        <li>target property accepts a string value</li>
        <li>string is a fixed value that you can bake into the template</li>
        <li>initial value never changes</li>
      </ul>
    </li>
    <li>interpolation and property binding can set only properties, not attributes</li>
    <li>all data bound properties must be TypeScript public properties</li>
    <li>Angular updates the bindings (and therefore the screen) <strong>only if the app does something in response to asynchronous</strong> events, such as keystrokes</li>
    <li>&lt;ng-template&gt; is an Angular element for rendering HTML</li>
    <li>use &lt;ng-container&gt; to group multiple nested structural directives</li>
  </ul>

  <h3>binding syntax</h3>
  <table>
    <colgroup><col width="25%">
    <col width="50%">
    <col width="20%">
    </colgroup>
    <tbody>
    <tr>
      <th>Data direction</th>
      <th>Syntax</th>
      <th>Type</th>
    </tr>
    <tr>
      <td>One-way<br>from data source<br>to view target</td>
      <td><code>{{expression}}<br>
        [target]="expression"<br>
        bind-target="expression"</code></td>
      <td>Interpolation<br>
        Property<br>
        Attribute<br>
        Class<br>Style</td>
    </tr>
    <tr>
      <td>One-way<br>
        from view target<br>
        to data source</td>
      <td><code>(target)="statement"<br>
        on-target="statement"</code></td>
      <td>Event</td>
    </tr>
    <tr>
      <td>Two-way</td>
      <td><code>[(target)]="expression"<br>
        bindon-target="expression"</code></td>
      <td>Two-way</td>
    </tr>
  </tbody></table>

  <h3>binding target</h3>
  <table>
    <colgroup><col width="10%">
    <col width="15%">
    <col width="70%">
    </colgroup>
    <tbody>
    <tr>
    <th>Type</th>
    <th>Target</th>
    <th>Examples</th>
    </tr>
    <tr>
    <td>Property</td>
    <td>Element | Component | Directive property</td>
    <td>
    <pre>
    &lt;img [src]="heroImageUrl"&gt;<br>
    &lt;button [disabled]="isUnchanged"&gt;Cancel&lt;/button&gt;<br>
    &lt;app-hero-detail [hero]="currentHero"&gt;<br>...
    &lt;/app-hero-detail&gt;<br>
    &lt;div [ngClass]="{'special': isSpecial}"&gt;<br>...
    &lt;/div&gt;
    </pre>
    </td>
    </tr>
    <tr>
    <td>Event</td>
    <td>Element | Component | Directive event</td>
    <td>
    <pre>
    &lt;button (click)="onSave()"&gt;Save&lt;/button&gt;<br>
    &lt;app-hero-detail (deleteRequest)="deleteHero()"&gt;<br>...
    &lt;/app-hero-detail&gt;<br>
    &lt;div (myClick)="clicked=$event" clickable&gt;click me&lt;/div&gt;
    </pre>
    </td>
    </tr>
    <tr>
    <td>Two-way</td>
    <td>Event and property</td>
    <td>
    <pre>&lt;input [(ngModel)]="name"&gt;</pre>
    </td>
    </tr>
    <tr>
    <td>Attribute</td>
    <td>Attribute (the exception)</td>
    <td>
    <pre>&lt;button [attr.aria-label]="help"&gt;help&lt;/button&gt;</pre>
    </td>
    </tr>
    <tr>
    <td>Class</td>
    <td><code>class</code> property</td>
    <td>
    <pre>&lt;div [class.special]="isSpecial"&gt;Special&lt;/div&gt;</pre>
    </td>
    </tr>
    <tr>
    <td>Style</td>
    <td><code>style</code> property</td>
    <td>
    <pre>&lt;button [style.color]="isSpecial ? 'red' : 'green'"&gt;</pre>
    </td>
    </tr>
  </tbody></table>

  <h3>ATTRIBUTE binding - the only binding that creates and sets an attribute</h3>
  <pre><code class="html">
    &lt;td colspan="{{1 + 1}}"&gt;Three-Four&lt;/td&gt; &lt;!-- WRONG for interpolation --&gt;
    &lt;td [attr.colspan]="1 + 1"&gt;One-Two&lt;/td&gt;
    &lt;button [attr.aria-label]="actionName"&gt;{{actionName}} with Aria&lt;/button&gt;
  </code></pre>

  <h3>CLASS binding - add or remove a single class, NgClass is usually preferred</h3>
  <pre><code class="html">
    &lt;!-- reset/override all class names with a binding  --&gt;
    &lt;div [class]="badCurly"&gt;Bad curly&lt;/div&gt;
    &lt;!-- toggle --&gt;
    &lt;div [class.special]="isSpecial"&gt;binding is special&lt;/div&gt;
    &lt;div class="special" [class.special]="!isSpecial"&gt;not so special&lt;/div&gt;
    NgClass
    &lt;div [ngClass]="currentClasses"&gt;
      div is initially saveable, unchanged, and special
    &lt;/div&gt;
    &lt;!--
      currentClasses: {};
      setCurrentClasses() {
        // CSS classes: added/removed per current state of component properties
        this.currentClasses =  {
          'saveable': this.canSave,
          'modified': !this.isUnchanged,
          'special':  this.isSpecial
        };
      }
    --&gt;
  </code></pre>

  <h3>STYLE binding - set a single style value, NgStyle is generally preferred</h3>
  <pre><code class="html">
    &lt;!-- dash-case OR camelCase --&gt;
    &lt;button [style.color]="isSpecial ? 'red': 'green'"&gt;Red&lt;/button&gt;
    &lt;button [style.background-color]="canSave ? 'cyan': 'grey'" &gt;Save&lt;/button&gt;
    &lt;button [style.font-size.em]="isSpecial ? 3 : 1" &gt;Big&lt;/button&gt;
    &lt;button [style.font-size.%]="!isSpecial ? 150 : 50" &gt;Small&lt;/button&gt;
    NgStyle
    &lt;div [ngStyle]="currentStyles"&gt;
      div is initially italic, normal weight, and extra large (24px)
    &lt;/div&gt;
    &lt;!--
      currentStyles: {};
      setCurrentStyles() {
        // CSS styles: set per current state of component properties
        this.currentStyles = {
          'font-style':  this.canSave      ? 'italic' : 'normal',
          'font-weight': !this.isUnchanged ? 'bold'   : 'normal',
          'font-size':   this.isSpecial    ? '24px'   : '12px'
        };
      }
    --&gt;
  </code></pre>

  <h3>TWO-WAY binding - [(...)], NgModel</h3>
  <pre><code class="html">
    &lt;!--  --&gt;
    &lt;app-sizer [(size)]="fontSizePx"&gt;&lt;/app-sizer&gt;
    &lt;div [style.font-size.px]="fontSizePx"&gt;Resizable Text&lt;/div&gt;
    &lt;app-sizer [size]="fontSizePx" (sizeChange)="fontSizePx=$event"&gt;&lt;/app-sizer&gt;
    &lt;!-- NgModel, FormsModule import into component is required to use it--&gt;
    &lt;input [(ngModel)]="currentHero.name"&gt;
    &lt;input
        [ngModel]="currentHero.name"
        (ngModelChange)="currentHero.name=$event"&gt;
  </code></pre>

  <h3>TEMPLATE REFERENCE VARIABLES - #var</h3>
  <pre><code class="html">
    &lt;!-- template becomed completely self contained, component does nothing: --&gt;
    &lt;!-- passing value directly --&gt;
    &lt;!-- reference #phone from any sibling or child of element --&gt;
    &lt;!-- user presses Enter + blur event = UX --&gt;
    &lt;input #box
      (keyup.enter)="add_OR_update(box.value)"
      (blur)="add_OR_update(box.value); newHero.value=''"&gt;
    &lt;button (click)="add_OR_update(box.value)"&gt;Add&lt;/button&gt;
    &lt;ul&gt;&lt;li *ngFor="let box of boxes"&gt;{{box}}&lt;/li&gt;&lt;/ul&gt;

    &lt;!-- --&gt;
    &lt;form (ngSubmit)="onSubmit(heroForm)" #heroForm="ngForm"&gt;
      &lt;div class="form-group"&gt;
        &lt;label for="name"&gt;Name
          &lt;input class="form-control" name="name" required [(ngModel)]="hero.name"&gt;
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;button type="submit" [disabled]="!heroForm.form.valid"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
    &lt;div [hidden]="!heroForm.form.valid"&gt;{{submitMessage}}&lt;/div&gt;
    &lt;!-- ref- prefix alternative to # --&gt;
    &lt;input ref-fax placeholder="fax number"&gt;
    &lt;button (click)="callFax(fax.value)"&gt;Fax&lt;/button&gt;
  </code></pre>

  <h3>EVENT binding - from an element to a component, any DOM event</h3>
  <pre><code class="html">
    &lt;button (click)="onSave()"&gt;Save&lt;/button&gt;
    &lt;input [value]="currentHero.name"
      (input)="currentHero.name=$event.target.value" &gt; &lt;!-- event object --&gt;
    &lt;input (keyup)="onKey($event)"&gt;
    onKey(event: any) { ... &lt; without type info &gt;
    onKey(event: KeyboardEvent) { ... &lt; with type info &gt;

    &lt;!-- custom events with EventEmitter --&gt;
    &lt;app-hero-detail (deleteRequest)="deleteHero($event)" [hero]="currentHero"&gt;
    &lt;/app-hero-detail&gt;
  </code></pre>

  <h3>STRUCTURAL DIRECTIVES</h3>
  <pre><code class="html">
    // YOU MAY APPLY ONLY ONE STRUCTURAL DIRECTIVE TO AN ELEMENT !!!
    // use &lt;ng-container&gt; for that cases

    &lt;!-- *ngIf - remove DOM element completely --&gt;
    &lt;app-hero-detail *ngIf="isActive"&gt;&lt;/app-hero-detail&gt;
    &lt;!-- ... hiding ONLY ! --&gt;
    &lt;div [class.hidden]="!isSpecial"&gt;Show with class&lt;/div&gt;
    &lt;div [class.hidden]="isSpecial"&gt;Hide with class&lt;/div&gt;
    &lt;div [style.display]="isSpecial ? 'block' : 'none'"&gt;Show with style&lt;/div&gt;
    &lt;!-- HeroDetail is in the DOM but hidden --&gt;
    &lt;app-hero-detail [class.hidden]="isSpecial"&gt;&lt;/app-hero-detail&gt;
    &lt;!-- --&gt;
    &lt;ng-template [ngIf]="hero"&gt;
      &lt;div class="name"&gt;{{hero.name}}&lt;/div&gt;
    &lt;/ng-template&gt;

    &lt;div class="course-detail" *ngIf="courseObs | async as course; else loading"&gt;
      &lt;div class="course-field"&gt;
          {{course.shortDescription}}
      &lt;/div&gt;
      ...
    &lt;/div&gt;
    &lt;ng-template #loading&gt;
      &lt;div&gt;Loading ...&lt;/div&gt;
    &lt;/ng-template&gt;

    &lt;div *ngIf="user$ | async; let user"&gt;
      &lt;h3&gt; {{user.name}}
    &lt;/div&gt;
    &lt;ng-container *ngIf="user$ | async; let user"&gt;...&lt;/ng-container&gt;
    &lt;div *ngIf="(user$ | async) || {}; let user"&gt;
      &lt;h3&gt; {{user?.name}}
    &lt;/div&gt;
    &lt;div *ngIf="(primitive$ | async) || ' '; let primitive"&gt;
      &lt;h3&gt; {{primitive}}
    &lt;/div&gt;

    &lt;!-- *NgFor...of --&gt;
    &lt;div *ngFor="let hero of heroes"&gt;{{hero.name}}&lt;/div&gt;
    &lt;app-hero-detail
      *ngFor="let hero of heroes; let odd=odd"
      [class.odd]="odd"
      [hero]="hero"&gt;
    &lt;/app-hero-detail&gt;
    &lt;!--
      track changes only for specific property, avoid rerender
      trackBy(index: number, hero: Hero): number { return hero.id; }
    --&gt;
    &lt;div *ngFor="let hero of heroes; let i=index; trackBy: trackByFn"&gt;
      {{i + 1}} - {{hero.name}}
    &lt;/div&gt;
    &lt;li *ngFor="let user of userObservable | async as users; index as i; first as isFirst"&gt;
      {{i}}/{{users.length}}. {{user}} &lt;span *ngIf="isFirst"&gt;default&lt;/span&gt;
    &lt;/li&gt;
    &lt;!--
      $implicit: T - value of the individual items in the iterable (ngForOf)
      ngForOf: NgIterable&lt;T&gt; - value of the iterable expression,
        when the expression is more complex then a property access,
        for example when using the async pipe (userStreams | async)
      index: number - index of the current item in the iterable
      first: boolean - True when the item is the first item in the iterable
      last: boolean - True when the item is the last item in the iterable
      even: boolean - True when the item has an even index in the iterable
      odd: boolean - True when the item has an odd index in the iterable
    --&gt;
    &lt;div
      *ngFor="let hero of heroes; let i=index; let odd=odd; trackBy: trackById"
      [class.odd]="odd"&gt;
      ({{i}}) {{hero.name}}
    &lt;/div&gt;
    &lt;ng-template
      ngFor let-hero [ngForOf]="heroes"
      let-i="index" let-odd="odd"
      [ngForTrackBy]="trackById"&gt;
      &lt;div [class.odd]="odd"&gt;({{i}}) {{hero.name}}&lt;/div&gt;
    &lt;/ng-template&gt;

    &lt;!-- NgSwitch, work as well with native elements and web components too --&gt;
    &lt;div [ngSwitch]="currentHero.emotion"&gt;
      &lt;app-happy-hero    *ngSwitchCase="'happy'"    [hero]="currentHero"&gt;
      &lt;/app-happy-hero&gt;
      &lt;app-sad-hero      *ngSwitchCase="'sad'"      [hero]="currentHero"&gt;
      &lt;/app-sad-hero&gt;
      &lt;app-confused-hero *ngSwitchCase="'confused'" [hero]="currentHero"&gt;
      &lt;/app-confused-hero&gt;
      &lt;app-unknown-hero  *ngSwitchDefault           [hero]="currentHero"&gt;
      &lt;/app-unknown-hero&gt;
    &lt;/div&gt;
    &lt;div [ngSwitch]="hero?.emotion"&gt;
      &lt;ng-template [ngSwitchCase]="'happy'"&gt;
        &lt;app-happy-hero [hero]="hero"&gt;&lt;/app-happy-hero&gt;
      &lt;/ng-template&gt;
      &lt;ng-template [ngSwitchCase]="'sad'"&gt;
        &lt;app-sad-hero [hero]="hero"&gt;&lt;/app-sad-hero&gt;
      &lt;/ng-template&gt;
      &lt;ng-template [ngSwitchCase]="'confused'"&gt;
        &lt;app-confused-hero [hero]="hero"&gt;&lt;/app-confused-hero&gt;
      &lt;/ng-template &gt;
      &lt;ng-template ngSwitchDefault&gt;
        &lt;app-unknown-hero [hero]="hero"&gt;&lt;/app-unknown-hero&gt;
      &lt;/ng-template&gt;
    &lt;/div&gt;

    &lt;!-- &lt;ng-container&gt; --&gt;
    &lt;select [(ngModel)]="hero"&gt;
      &lt;ng-container *ngFor="let h of heroes"&gt;
        &lt;ng-container *ngIf="showSad || h.emotion !== 'sad'"&gt;
          &lt;option [ngValue]="h"&gt;{{h.name}} ({{h.emotion}})&lt;/option&gt;
        &lt;/ng-container&gt;
      &lt;/ng-container&gt;
    &lt;/select&gt;
  </code></pre>

  <h3>INPUT AND OUTPUT PROPERTIES, binding to a different component</h3>
  <pre><code class="html">
    &lt;!-- other component property is to the left of the (=) --&gt;
    &lt;app-hero-detail [hero]="currentHero" (deleteRequest)="deleteHero($event)"&gt;
    &lt;/app-hero-detail&gt;
    &lt;!--
      @Input()  hero: Hero;
      @Output() deleteRequest = new EventEmitter&lt;Hero&gt;();
      ---
      @Component({
        inputs: ['hero'],
        outputs: ['deleteRequest'],
      })
      --- @Output(alias) propertyName = ...
      @Output('myClick') clicks = new EventEmitter&lt;string&gt;();
      ---
      @Directive({
        outputs: ['clicks:myClick']  // propertyName:alias
      })
    --&gt;
  </code></pre>

  <h3>TEMPLATE EXPRESSION OPERATORS</h3>
  <pre><code class="html">
    &lt;!-- pipe operator - | --&gt;
    &lt;div&gt;Title through uppercase pipe: {{title | uppercase}}&lt;/div&gt;
    &lt;!-- chaining --&gt;
    &lt;div&gt;Title through a pipe chain: {{title | uppercase | lowercase}}&lt;/div&gt;
    &lt;!-- apply parameters, pipe with configuration argument =&gt; "February 25, 1970" --&gt;
    &lt;div&gt;Birthdate: {{currentHero?.birthdate | date:'longDate'}}&lt;/div&gt;
    &lt;div&gt;{{currentHero | json}}&lt;/div&gt;

    &lt;!-- safe navigation operator ( ?. ) guards against null and undefined, a?.b?.c?.d --&gt;
    &lt;span&gt;The current hero name is {{currentHero?.name}}&lt;/span&gt;

    &lt;!-- isabling type checking --&gt;
    {{$any(person).addresss.street}}

    &lt;span *ngIf="person && address"&gt; {{person.name}} lives on {{address.street}} &lt;/span&gt;

    &lt;!-- non-null assertion operator ( ! ) --&gt;
    &lt;!--
      suspend strict null checks for a specific property expression
      required when -strictNullChecks
    --&gt;
    &lt;div *ngIf="hero"&gt;The hero's name is {{hero!.name}}&lt;/div&gt;

    &lt;!-- $any type cast function, silence the error - $any(&lt;expression&gt;) --&gt;
    &lt;!-- prevents TS reporting that 'marker' is not a member of the Hero interface --&gt;
    &lt;div&gt;The hero marker is {{$any(hero).marker}}&lt;/div&gt;
    &lt;!-- access to undeclared members of the component --&gt;
    &lt;div&gt;Undeclared members is {{$any(this).member}}&lt;/div&gt;
  </code></pre>

  <pre><code class="html">
    &lt;!-- set constant and dynamic property --&gt;
    &lt;app-hero-detail prefix="You are my" [hero]="currentHero"&gt;&lt;/app-hero-detail&gt;

    &lt;!-- same things --&gt;
    &lt;img src="{{heroImageUrl}}"&gt;
    &lt;img [src]="heroImageUrl"&gt;
    &lt;img bind-src="heroImageUrl"&gt;
    &lt;!-- OR --&gt;
    &lt;span&gt;"{{title}}" is the interpolated title&lt;/span&gt;
    &lt;span [innerHTML]="title"&gt;&lt;/span&gt;" is the property bound title
  </code></pre>

  <br><br><br>
  <img src="../images/component-tree.png"
  style="position:relative;width:50%;margin-left:25%;"><br><br><br>

  <img src="../images/databinding.png"
  style="position:relative;width:50%;margin-left:25%;"><br><br><br>
  <img src="../images/component-databinding.png"
  style="position:relative;width:50%;margin-left:25%;"><br><br><br>
  <img src="../images/parent-child-binding.png"
  style="position:relative;width:50%;margin-left:25%;">



<h2 id="pipes">Pipes</h2>

  <ul>
    <li><strong>pure pipes</strong> - executed only when a pure change detected to the input value: change to a primitive input value (String, Number, Boolean, Symbol) or a changed object reference (Date, Array, Function, Object), ignores changes within (composite) objects: change an input month, add to an input array, or update an input object property</li>
    <li><strong>impure pipe</strong> - executed during every component change detection cycle, as often as every keystroke or mouse-move, the only change is <i>pure:false</i> in <i>@Pipe metadata</i>, useful <strong>when array or composite objects are updated partially</strong>, not fully replaced</li>
    <li>pure pipe uses pure functions (process inputs and return values without detectable side effects,given the same input, they should always return the same output), try always implement a pure pipe with a pure function, otherwise youll see errors</li>
    <li>AsyncPipe accepts a Promise or Observable as input and subscribes to the input automatically, eventually returning the emitted values, is also stateful, maintains a subscription to the input Observable and keeps delivering values from that Observable as they arrive, returns the latest value they has emitted</li>
    <li>move filtering and sorting logic into the component itself</li>
    <li>chain by adding another at the end: <code>birthday | date:'fullDate' | uppercase</code></li>
  </ul>

  <table style="margin-left:1em;"><tbody>
    <tr><td>UpperCasePipe</td>
      <td><code>{{ <i>value</i> | uppercase }}</code></td>
    </tr>
    <tr><td>LowerCasePipe</td>
      <td><code>{{ <i>value</i> | lowercase }}</code></td>
    </tr>
    <tr><td>TitleCasePipe</td>
      <td><code>{{ <i>value</i> | titlecase }}</code></td>
    </tr>
    <tr><td>DatePipe</td>
      <td><code>{{ <i>value</i> | date [ : format [ : timezone [ : locale ] ] ] }}</code></td>
      </tr>
      <tr>
      <td colspan=2>
        <code>
          {{ dateObj | date }}               // output is 'Jun 15, 2015'<br>
          {{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM'<br>
          {{ dateObj | date:'shortTime' }}   // output is '9:43 PM'<br>
          {{ dateObj | date:'mmss' }}        // output is '43:11'<br>
          'short': equivalent to 'M/d/yy, h:mm a' (6/15/15, 9:03 AM)<br>
          'medium': equivalent to 'MMM d, y, h:mm:ss a' (Jun 15, 2015, 9:03:01 AM)<br>
          'long': equivalent to 'MMMM d, y, h:mm:ss a z' (June 15, 2015 at 9:03:01 AM GMT+1)<br>
          'full': equivalent to 'EEEE, MMMM d, y, h:mm:ss a zzzz' (Monday, June 15, 2015 at 9:03:01 AM GMT+01:00)<br>
          'shortDate': equivalent to 'M/d/yy' (6/15/15)<br>
          'mediumDate': equivalent to 'MMM d, y' (Jun 15, 2015)<br>
          'longDate': equivalent to 'MMMM d, y' (June 15, 2015)<br>
          'fullDate': equivalent to 'EEEE, MMMM d, y' (Monday, June 15, 2015)<br>
          'shortTime': equivalent to 'h:mm a' (9:03 AM)<br>
          'mediumTime': equivalent to 'h:mm:ss a' (9:03:01 AM)<br>
          'longTime': equivalent to 'h:mm:ss a z' (9:03:01 AM GMT+1)<br>
          'fullTime': equivalent to 'h:mm:ss a zzzz' (9:03:01 AM GMT+01:00)
        </code>
      </td>
    </tr>
    <tr><td>DecimalPipe</td>
      <td><code>{{ <i>value</i> | number [ : digitsInfo [ : locale ] ] }}</code></td>
      </tr>
      <tr>
      <td colspan=2>
        <code>
          {{epsilon | number}}<br>
          {{pi | number:'3.1-5'}}<br>
          {{epsilon | number:'4.5-5':'fr'}}<br>
          {{epsilon | number}}<br>
          {{epsilon | number}}<br>
          {{epsilon | number}}<br>
          {{epsilon | number}}
        </code>
      </td>
    </tr>
    <tr><td>PercentPipe</td>
      <td><code>{{ <i>value</i> | percent [ : digitsInfo [ : locale ] ] }}</code></td>
      </tr>
      <tr>
      <td colspan=2>
        <code>
          {{a | percent}}<br>
          {{b | percent:'4.3-5':'fr'}}
        </code>
      </td>
    </tr>
    <tr><td>CurrencyPipe</td>
      <td>
        <code>
          {{ <i>value</i> | currency [ : currencyCode [ : display [ : digitsInfo [ : locale ] ] ] ] }}
        </code>
      </td>
      </tr>
      <tr>
      <td colspan=2>
        <code>
          {{a | currency}}<br>
          {{a | currency:'CAD'}}<br>
          {{a | currency:'CAD':'code'}}<br>
          {{b | currency:'CAD':'symbol':'4.2-2'}}<br>
          {{b | currency:'CAD':'symbol-narrow':'4.2-2'}}<br>
          {{b | currency:'CAD':'symbol':'4.2-2':'fr'}}
        </code>
      </td>
    </tr>
    <tr><td>SlicePipe</td>
      <td><code>{{ <i>value</i> | slice : start [ : end ] }}</code></td>
      </tr>
      <tr>
      <td colspan=2>
        <code>
          &lt;li *ngFor="let i of collection | slice:1:3"&gt;{{i}}&lt;/li&gt;<br>
          <br>
          {{str | slice:0:4}}<br>
          {{str | slice:4:0}}<br>
          {{str | slice:-4}}<br>
          {{str | slice:-4:-2}}
        </code>
      </td>
    </tr>
    <tr><td>KeyValuePipe</td>
      <td><code>{{ input_expression | keyvalue [ : compareFn ] }}</code></td>
      </tr>
      <tr>
      <td colspan=2>
        <code>&lt;div *ngFor="let item of object | keyvalue"&gt; {{item.key}}:{{item.value}} &lt;/div&gt;</code>
      </td>
    </tr>
    <tr><td>JsonPipe</td>
      <td><code>{{ <i>value</i> | json }} , &lt;pre&gt;{{object | json}}&lt;/pre&gt;</code></td>
    </tr>
    <tr><td>AsyncPipe</td>
      <td>
        <code>
          {{ message$ | async }}<br>
          // ---<br>
          message$: Observable&lt;string&gt;;
        </code>
      </td>
    </tr>
    <tr><td>I18nPluralPipe</td>
      <td><code>{{ <i>value</i> | i18nPlural : pluralMap [ : locale ] }}</code></td>
      </tr>
      <tr>
      <td colspan=2>
        <pre>
        @Component({
          selector: "i18n-select-pipe",
          template: "{{gender | i18nSelect: inviteMap}}"
        })
        export class I18nSelectPipeComponent {
          gender: string = 'male';
          inviteMap: any = {
            'male': 'Invite him.',
            'female': 'Invite her.',
            'other': 'Invite them.'
          };
        }
        </pre>
      </td>
    </tr>
    <tr><td>I18nSelectPipe</td>
      <td><code>{{ <i>value</i> | i18nSelect : mapping }}</code></td>
      </tr>
      <tr>
      <td colspan=2>
        <pre>
        @Component({
          selector: "i18n-plural-pipe",
          template: "{{ messages.length | i18nPlural: messageMapping }}"
        })
        export class I18nPluralPipeComponent {
          messages: any[] = ['Message 1'];
          messageMapping:
            {[k: string]: string} = {
              '=0': 'No messages.',
              '=1': 'One message.',
              'other': '# messages.'
            };
        }
        </pre>
      </td>
    </tr>
  </tbody></table>

  <pre><code class="ts">
    // ---
    // pipe calls the server when the requested URL changes
    // and it caches the server response
    // ---
    import { HttpClient }          from '@angular/common/http';
    import { Pipe, PipeTransform } from '@angular/core';
    @Pipe({
      name: 'fetch',
      pure: false
    })
    export class FetchJsonPipe implements PipeTransform {
      private cachedData: any = null;
      private cachedUrl = '';
      constructor(private http: HttpClient) { }
      transform(url: string): any {
        if (url !== this.cachedUrl) {
          this.cachedData = null;
          this.cachedUrl = url;
          this.http.get(url).subscribe(result => this.cachedData = result);
        }
        return this.cachedData;
      }
    }
    // ---
    // requesting the heroes from the heroes.json file
    // ---
    import { Component } from '@angular/core';
    @Component({
      selector: 'app-hero-list',
      template: `
        &lt;h2&gt;Heroes from JSON File&lt;/h2&gt;
        &lt;div *ngFor="let hero of ('assets/heroes.json' | fetch) "&gt;
          {{hero.name}}
        &lt;/div&gt;
        &lt;p&gt;Heroes as JSON:
          {{'assets/heroes.json' | fetch | json}}
        &lt;/p&gt;`
    })
    export class HeroListComponent { }
  </code></pre>



<h2 id="dis">DI and services</h2>

  <ul>
    <li>each injector creates a singleton instance of a dependency, same instance is injected wherever that injector provides that service, particular service can be provided and created at any level of the injector hierarchy, which means that there can be multiple instances of a service if it is provided by multiple injectors</li>
    <li>if the injector does not have any existing instances of required service, injector makes one using the registered provider, and adds it to the injector before returning the service to Angular, when all requested services have been resolved and returned, Angular can call the component constructor with those services as arguments</li>
    <li>dependency doesnt have to be a service, it could be a function, for example, or a value</li>
    <li>DI system is hierarchical</li>
    <li>all providers from root AppModule when app is in dev-mode, write in console: <i>ng.probe(getAllAngularRootElements()[0]).injector.view.root.ngModule._providers</i></li>
    <li>register at least one provider of any service you are going to use, provider can be part of the service own metadata (in @Injectable()|@NgModule()|@Component() decorator), making that service available everywhere, or you can register providers with specific modules or components, registering a service provider:
      <ul>
        <li>in the <strong>@Injectable() decorator metadata "providedIn" option</strong> (root level, <code>ng generate service</code> performs this or with the injector for a specific NgModule), Angular creates a single, shared instance of service and injects it into any class that asks for it, also allows Angular to optimize an app by removing the service from the compiled app if it isnt used</li>
        <li>inside <strong>providers property of the @NgModule() decorator</strong>, the same instance of a service is available to all components in that NgModule</li>
        <li>in the <strong>providers property of the @Component() metadata</strong>, at the component level, you get a new instance of the service with each new instance of that component. At the component level</li>
        <li>Angular always adds a component instance to its own injector</li>
        <li>first registration is picked first on lookup</li>
        <li>inject specialized service (which extends original for example) at required level</li>
        <li>make a provider tree-shakable by specifying it in the @Injectable() decorator on the service itself, rather than in the metadata for the NgModule or component that depends on the service which overrides a tree-shakable provider</li>
      </ul>
    </li>
    <li>configure an injector with an alternative provider, in order to deliver some other object that provides the needed functionality, provide:
      <ul>
        <li>substitute class</li>
        <li>same class-like object</li>
        <li>call a same class factory function</li>
      </ul>
    </li>
    <li>built-in injection-token constants that you can use to customize the behavior of various systems
      <ul>
        <li>PLATFORM_INITIALIZER - invoked when a platform is initialized</li>
        <li>APP_BOOTSTRAP_LISTENER - invoked for each component that is bootstrapped, handler function receives the ComponentRef instance of the bootstrapped component</li>
        <li>APP_INITIALIZE - invoked before an app is initialized, all registered initializers can optionally return a Promise, all initializer functions that return Promises must be resolved before the application is bootstrapped, if one of the initializers fails to resolves, the application is not bootstrapped</li>
      </ul>
    </li>
    <li>make a service a singleton:
      <ul>
        <li>declare that the service should be provided in the application root (providedIn:'root')</li>
        <li>include the service in the AppModule or in a module that is only imported by the AppModule, use forwardRef() to address future definition</li>
        <li>provide only in specific component</li>
      </ul>
    </li>
    <li>service as component provider for multiple edit sessions
      <ul>
        <li>cache component into service local variables (curent and original state)</li>
        <li>component expects in @Input() data for his clone via service</li>
        <li>getter and setter configures interaction and service data</li>
      </ul>
    </li>
    <li>if you do combine a component and service in the same file - to define the service first, and then the component</li>
    <li>service can inject other service same DI way, in constructor</li>
    <li>when you configure an injector with a provider, you associate that provider with a DI token - key to the map of injectors internal token-provider references</li>
    <li>qualify service-valued parameter of the component constructor with decorators
      <ul>
        <li><strong>@Optional</strong> property decorator tells Angular to return null when it cant find the dependency</li>
        <li><strong>@Host</strong> property decorator stops the upward search at the host component, host component is typically the component requesting the dependency, however, when this component is projected into a parent component, that parent component becomes the host</li>
      </ul>
    </li>
  </ul>

  <pre><code class="ts">
    import { Injectable } from '@angular/core';
    import { UserModule } from './user.module';

    @Injectable({ // Injectable-level configuration
      providedIn: 'root',
    })
    export class UserService { }

    //--------------------------------

    @NgModule({ // NgModule-level injectors
      providers: [
        UserService,
        Logger
        // { provide: Logger, useClass: Logger }
      ],
      ...
    })

    //--------------------------------

    @Component({ // component-level injectors
      selector:    'app-hero-list',
      templateUrl: './hero-list.component.html',
      providers:  [ HeroService ]
    })
    export someCompnent {
      constructor(private logger: Logger) {
        this.logger.log(some_message);
      }
    }
  </code></pre>

  <details><summary>hierachical class inheritance</summary>
  <pre><code class="ts">
    // --- car.component.ts
    import { Component } from '@angular/core';
    import { Car, Engine, Tires }  from './car';
    import { Car as CarNoDi }      from './car-no-di';
    import { CarFactory }          from './car-factory';
    import { testCar, simpleCar, superCar } from './car-creations';
    import { useInjector } from './car-injector';
    @Component({
      selector: 'app-car',
      template: `
      &lt;h2&gt;Cars&lt;/h2&gt;
      &lt;div id="di"&gt;{{car.drive()}}&lt;/div&gt;
      &lt;div id="nodi"&gt;{{noDiCar.drive()}}&lt;/div&gt;
      &lt;div id="injector"&gt;{{injectorCar.drive()}}&lt;/div&gt;
      &lt;div id="factory"&gt;{{factoryCar.drive()}}&lt;/div&gt;
      &lt;div id="simple"&gt;{{simpleCar.drive()}}&lt;/div&gt;
      &lt;div id="super"&gt;{{superCar.drive()}}&lt;/div&gt;
      &lt;div id="test"&gt;{{testCar.drive()}}&lt;/div&gt;`,
      providers: [Car, Engine, Tires]
    })
    export class CarComponent {
      factoryCar  = (new CarFactory).createCar();
      injectorCar = useInjector();
      noDiCar     = new CarNoDi;
      simpleCar   = simpleCar();
      superCar    = superCar();
      testCar     = testCar();
      constructor(public car: Car) {}
    }

    // --- car.ts
    import { Injectable } from '@angular/core';
    export class Engine { public cylinders = 4; }
    export class Tires {
      public make  = 'Flintstone';
      public model = 'Square';
    }
    @Injectable()
    export class Car {
      public description = 'DI';
      constructor(public engine: Engine, public tires: Tires) { }
      // Method using the engine and tires
      drive() {
        return `${this.description} car with ` +
          `${this.engine.cylinders} cylinders and ${this.tires.make} tires.`;
      }
    }

    // --- car-factory.ts
    import { Engine, Tires, Car } from './car';
    // BAD pattern!
    export class CarFactory {
      createCar() {
        let car = new Car(this.createEngine(), this.createTires());
        car.description = 'Factory';
        return car;
      }
      createEngine() {
        return new Engine();
      }
      createTires() {
        return new Tires();
      }
    }

    // --- car-creations.ts
    import { Car, Engine, Tires } from './car';
    // - 1
    export function simpleCar() {
      // Simple car with 4 cylinders and Flintstone tires.
      let car = new Car(new Engine(), new Tires());
      car.description = 'Simple';
      return car;
    }
    // - 2
    class Engine2 { constructor(public cylinders: number) { } }
    export function superCar() {
      // Super car with 12 cylinders and Flintstone tires.
      let bigCylinders = 12;
      let car = new Car(new Engine2(bigCylinders), new Tires());
      car.description = 'Super';
      return car;
    }
    // - 3
    class MockEngine extends Engine { cylinders = 8; }
    class MockTires  extends Tires  { make = 'YokoGoodStone'; }
    export function testCar() {
      // Test car with 8 cylinders and YokoGoodStone tires.
      let car = new Car(new MockEngine(), new MockTires());
      car.description = 'Test';
      return car;
    }

    // --- car-injector.ts
    import { Injector } from '@angular/core';
    import { Car, Engine, Tires } from './car';
    import { Logger }             from '../logger.service';
    export function useInjector() {
      let injector: Injector;
      /*
      // Cannot instantiate an Injector like this!
      let injector = new Injector([
        { provide: Car, deps: [Engine, Tires] },
        { provide: Engine, deps: [] },
        { provide: Tires, deps: [] }
      ]);
      */
      injector = Injector.create({
        providers: [
          { provide: Car, deps: [Engine, Tires] },
          { provide: Engine, deps: [] },
          { provide: Tires, deps: [] }
        ]
      });
      let car = injector.get(Car);
      car.description = 'Injector';
      injector = Injector.create({
        providers: [{ provide: Logger, deps: [] }]
      });
      let logger = injector.get(Logger);
      logger.log('Injector car.drive() said: ' + car.drive());
      return car;
    }

    // --- car-no-di.ts - car without DI
    import { Engine, Tires } from './car';
    export class Car {
      public engine: Engine;
      public tires: Tires;
      public description = 'No DI';
      constructor() {
        this.engine = new Engine();
        this.tires = new Tires();
      }
      // Method using the engine and tires
      drive() {
        return `${this.description} car with ` +
          `${this.engine.cylinders} cylinders and ${this.tires.make} tires.`;
      }
    }
  </code></pre></details>

  <details><summary>dependency provider - configures an injector with a DI token</summary>
  <pre><code class="ts">
    // --- ALTERNATIVE CLASS PROVIDERS
    [{ provide: Logger, useClass: BetterLogger }]

    // --- CLASS PROVIDERS WITH DEPENDENCIES
    [ UserService,
      {
        provide: Logger,
        useClass: EvenBetterLogger
      }
    ]
    // ...
    @Injectable()
    export class EvenBetterLogger extends Logger {
      constructor(private userService: UserService) { super(); }
      log(message: string) {
        let name = this.userService.user.name;
        super.log(`Message to ${name}: ${message}`);
      }
    }

    // --- ALIASED CLASS PROVIDERS
    // useExisting - lets you map one token to another
    // first token is an alias for the service associated with the second token,
    // creating two ways to access the same service object.
    // avoid two instances creation:
    [ NewLogger,
      {
        provide: OldLogger,
        useExisting: NewLogger
    }]
    // token for a provider:
    { provide: MinimalLogger, useExisting: LoggerService },...
    // minimal-logger.service.ts
    // class used as a "narrowing" interface that exposes a minimal logger
    // other members of the actual implementation are invisible
    export abstract class MinimalLogger {
      logs: string[];
      logInfo: (msg: string) => void;
    }

    // --- PROVIDE A READY-MADE OBJECT
    [{ provide: Logger, useValue: silentLogger }]
    export function SilentLoggerFn() {}
    const silentLogger = { // object in the shape of the logger service
      logs: ['Silent logger says "Shhhhh!". Provided via "useValue"'],
      log: SilentLoggerFn
    };
    // InjectionToken objects
    { provide: TITLE, useValue: 'Hero of the Month' },
    // ...
    import { InjectionToken } from '@angular/core';
    export const TITLE = new InjectionToken&lt;string&gt;('title');

    // --- NON-CLASS DEPENDENCIES
    // src/app/app.config.ts
    export const HERO_DI_CONFIG: AppConfig = {
      apiEndpoint: 'api.heroes.com',
      title: 'Dependency Injection'
    };
    // TypeScript interfaces are not valid tokens !
    // use an InjectionToken whenever the type you are injecting
    // is not reified (does not have a runtime representation)
    // interface, callable type, array or parameterized type
    import { InjectionToken } from '@angular/core';
    export const APP_CONFIG = new InjectionToken&lt;AppConfig&gt;('app.config');
    // src/app/app.module.ts (providers)
    providers: [
      UserService,
      { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }
    ],...
    // and
    constructor(@Inject(APP_CONFIG) config: AppConfig) {
      this.title = config.title;
    }

    // --- FACTORY PROVIDER
    // create a dependency object with a factory function
    // whose inputs are a combination of injected services and local state
    // user.service.ts
    export class User {
      constructor( public name: string, public isAuthorized = false) { }
    }
    let alice = new User('Alice', true);
    let bob = new User('Bob', false);
    @Injectable({ providedIn: 'root' })
    export class UserService {
      user = bob;  // initial user is Bob
      getNewUser() { // swap users, // TODO: get the user; don't 'new' it
        return this.user = this.user === bob ? alice : bob;
      }
    }
    // hero.service.provider.ts
    let heroServiceFactory = (logger: Logger, userService: UserService) => {
      return new HeroService(logger, userService.user.isAuthorized);
    };
    export let heroServiceProvider =
      {
        provide: HeroService,
        useFactory: heroServiceFactory,
        deps: [Logger, UserService]
      };
    // hero.service.ts
    @Injectable({
      providedIn: 'root',
      useFactory: (logger: Logger, userService: UserService) =>
          new HeroService(logger, userService.user.isAuthorized),
      deps: [Logger, UserService],
    })
    export class HeroService {
      constructor( private logger: Logger, private isAuthorized: boolean) { }
      getHeroes() {
        let auth = this.isAuthorized ? 'authorized ' : 'unauthorized';
        this.logger.log(`Getting heroes for ${auth} user.`);
        return HEROES.filter(hero => this.isAuthorized || !hero.isSecret);
      }
    }
    // ...
    constructor(heroService: HeroService) {
      this.heroes = heroService.getHeroes();
    }
    // ...
    {{hero.isSecret ? 'secret' : 'public'}})

    // --- PREDEFINED TOKENS AND MULTIPLE PROVIDERS
    export const APP_TOKENS = [
      { provide: PLATFORM_INITIALIZER,
        useFactory: platformInitialized, multi: true },
      { provide: APP_INITIALIZER,
        useFactory: delayBootstrapping, multi: true },
      { provide: APP_BOOTSTRAP_LISTENER,
        useFactory: appBootstrapped, multi: true },
    ];
  </code></pre></details>

  <details><summary>multiple service instances</summary>
  <pre><code class="ts">
    // separate instance of the service for each component
    // hero-bios.component.ts
    @Component({
      selector: 'app-hero-bios',
      template: `
      &lt;app-hero-bio [heroId]="1"&gt;&lt;/app-hero-bio&gt;
      &lt;app-hero-bio [heroId]="2"&gt;&lt;/app-hero-bio&gt;
      &lt;app-hero-bio [heroId]="3"&gt;&lt;/app-hero-bio&gt;`,
      providers: [HeroService]
    })
    export class HeroBiosComponent { }
    // hero-cache.service.ts
    @Injectable()
    export class HeroCacheService {
      hero: Hero;
      constructor(private heroService: HeroService) {}
      fetchCachedHero(id: number) {
        if (!this.hero) {
          this.hero = this.heroService.getHeroById(id);
        }
        return this.hero;
      }
    }
    // hero-bio.component.ts
    @Component({
      selector: 'app-hero-bio',
      template: `
        &lt;h4&gt;{{hero.name}}&lt;/h4&gt;
        &lt;ng-content&gt;&lt;/ng-content&gt;
        &lt;textarea cols="25" [(ngModel)]="hero.description"&gt;&lt;/textarea&gt;`,
      providers: [HeroCacheService]
    })
    export class HeroBioComponent implements OnInit  {
      @Input() heroId: number;
      constructor(private heroCache: HeroCacheService) { }
      ngOnInit() { this.heroCache.fetchCachedHero(this.heroId); }
      get hero() { return this.heroCache.hero; }
    }
  </code></pre></details>

  <details><summary>parameter decorators</summary>
  <pre><code class="ts">
    // @Host() , @Optional()
    @Component({
      selector: 'app-hero-contact',
      template: `
      Phone #: {{phoneNumber}}
      &lt;span *ngIf="hasLogger"&gt;!!!&lt;/span&gt;`
    })
    export class HeroContactComponent {
      hasLogger = false;
      constructor(
          @Host() // limit to the host components instance of the HeroCacheService
          private heroCache: HeroCacheService,
          @Host()     // limit search for logger; hides the application-wide logger
          @Optional() // ok if the logger doesnt exist
          private loggerService: LoggerService
      ) {
        if (loggerService) {
          this.hasLogger = true;
          loggerService.logInfo('HeroContactComponent can log!');
        }
      }
      get phoneNumber() { return this.heroCache.hero.phone; }
    }

    // @Inject - specify a custom provider of a dependency
    import { Inject, Injectable, InjectionToken } from '@angular/core';
    export const BROWSER_STORAGE = new InjectionToken&lt;Storage&gt;('Browser Storage', {
      providedIn: 'root',
      factory: () => localStorage
    });
    @Injectable({ providedIn: 'root' })
    export class BrowserStorageService {
      constructor(@Inject(BROWSER_STORAGE) public storage: Storage) {}
      get(key: string) { this.storage.getItem(key); }
      set(key: string, value: string) { this.storage.setItem(key, value); }
      remove(key: string) { this.storage.removeItem(key); }
      clear() { this.storage.clear(); }
    }

    // @Self - injector only looks at the component injector for its providers
    // @SkipSelf - skip local injector and look in hierarchy
    // override BROWSER_STORAGE in Component class providers with sessionStorage
    import { Component, OnInit, Self, SkipSelf } from '@angular/core';
    import { BROWSER_STORAGE, BrowserStorageService } from './storage.service';
    @Component({
      selector: 'app-storage',
      template: `
        Open the inspector to see the local/session storage keys:
        &lt;h3&gt;Session Storage&lt;/h3&gt;
        &lt;button (click)="setSession()"&gt;Set Session Storage&lt;/button&gt;
        &lt;h3&gt;Local Storage&lt;/h3&gt;
        &lt;button (click)="setLocal()"&gt;Set Local Storage&lt;/button&gt;
      `,
      providers: [
        BrowserStorageService,
        { provide: BROWSER_STORAGE, useFactory: () => sessionStorage }
      ]
    })
    export class StorageComponent implements OnInit {
      constructor(
        @Self() private sessionStorageService: BrowserStorageService,
        @SkipSelf() private localStorageService: BrowserStorageService,
      ) { }
      ngOnInit() { }
      setSession() {
        this.sessionStorageService.set('hero', 'Mr. Nice - Session');
      }
      setLocal() {
        this.localStorageService.set('hero', 'Mr. Nice - Local');
      }
    }
  </code></pre></details>

  <details><summary>inject the component DOM element</summary>
  <pre><code class="ts">
    import { Directive, ElementRef, HostListener, Input } from '@angular/core';
    @Directive({
      selector: '[appHighlight]'
    })
    export class HighlightDirective {
      @Input('appHighlight') highlightColor: string;
      private el: HTMLElement;
      constructor(el: ElementRef) {
        this.el = el.nativeElement;
      }
      @HostListener('mouseenter')
      onMouseEnter() {
        this.highlight(this.highlightColor || 'cyan');
      }
      @HostListener('mouseleave')
      onMouseLeave() {
        this.highlight(null);
      }
      private highlight(color: string) {
        this.el.style.backgroundColor = color;
      }
    }
  </code></pre></details>

  <img src="../images/dependency-injection.png"
  style="position:relative;width:75%;margin-left:10%;">
  <img src="../images/injector-injects.png"
  style="position:relative;width:75%;margin-left:10%;">



<h2 id="forms">Forms</h2>

  <ul>
    <li><strong>Reactive forms</strong> - scalable, reusable, and testable
      <ul>
        <li>form model (FormControl,...) is the source of truth</li>
        <li>updates from the view to the model and from the model to the view are synchronous and arent dependent on the UI rendered</li>
        <li>define custom validators as functions that receive a control to validate</li>
        <li>FormControl instance always returns a new value when the control value is updated</li>
        <li>display value in these ways
          <ul>
            <li>through the valueChanges observable where you can listen for changes in the form value in the template using AsyncPipe or in the component class using the subscribe() method</li>
            <li>with the value property: {{ name.value }}</li>
          </ul>
        </li>
        <li>updating parts of the model for a form group instance
          <ul>
            <li>setValue() - set a new value for an individual control, adheres to the structure of the form group and replaces the entire value for the control</li>
            <li>patchValue() - replace any properties defined in the object that have changed in the form model</li>
          </ul>
        </li>
        <li><strong>FormBuilder</strong> service provides convenient methods for generating controls, is an injectable provider that is provided with the reactive forms module, has three methods: control(), group(), and array()</li>
        <li>you add validator functions directly to the form control model in the component class
          <ul>
            <li><strong>Sync validators</strong> - take a control instance and immediately return either a set of validation errors or null, pass these in as the second argument when you instantiate a FormControl</li>
            <li><strong>Async validators</strong> - take a control instance and return a Promise or Observable that later emits a set of validation errors or null, pass these in as the third argument when you instantiate a FormControl</li>
            <li>Angular only runs async validators if all sync validators pass, each must complete before errors are set</li>
          </ul>
        </li>
      </ul>
    </li>
    <li><strong>Template-driven forms</strong> - useful for adding a simple form to an app
      <ul>
        <li>each form element is linked to a directive that manages the form model internally</li>
        <li>tied to template directives, and must provide custom validator directives that wrap validation functions</li>
        <li>property is always modified to its new value</li>
        <li>if you imported FormsModule, you don't have to do anything to the <form> tag in order to make use of FormsModule.</li>
        <li>Angular automatically creates and attaches an NgForm directive to the form-tag</li>
        <li>use native validation, including <i>required</i>, <i>minlength</i>, and <i>maxlength</i> in combination with the built-in validators provided by Angular prevents errors when the expression is changed after the template has been checked</li>
        <li>track control state and validity with ngModel
          <ul>
            <li>ng-touched/ng-untouched - control has been visited</li>
            <li>ng-dirty/ng-pristine - controls value has changed</li>
            <li>ng-valid/ng-invalid - controls value is valid</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>both share underlying building blocks
      <ul>
        <li>FormControl tracks the value and validation status of an individual form control</li>
        <li>FormGroup tracks the same values and status for a collection of form controls</li>
        <li>FormArray tracks the same values and status for an array of form controls</li>
        <li>ControlValueAccessor creates a bridge between Angular FormControl instances and native DOM elements</li>
      </ul>
    </li>
    <li>you can dynamically insert and remove controls from FormArray and FormGroup instances</li>
    <li>control status CSS classes
      <ul>
        <li><code>.ng-valid</code></li>
        <li><code>.ng-invalid</code></li>
        <li><code>.ng-pending</code></li>
        <li><code>.ng-pristine</code></li>
        <li><code>.ng-dirty</code></li>
        <li><code>.ng-untouched</code></li>
        <li><code>.ng-touched</code></li>
      </ul>
    </li>
  </ul>

  <details>
  <summary>REACTIVE</summary>
    <pre><code class="ts">
      // --- src/app/app.module.ts
      import { ReactiveFormsModule } from '@angular/forms';
      @NgModule({
        imports: [
          // other imports ...
          ReactiveFormsModule
        ],
      })
      export class AppModule { }
      // ---  &lt;app-profile-editor&gt; &lt;/app-profile-editor&gt;
      import { Component } from '@angular/core';
      import { FormGroup, FormControl } from '@angular/forms';
      import { FormBuilder } from '@angular/forms';
      import { Validators } from '@angular/forms';
      import { FormArray } from '@angular/forms';
      @Component({
        selector: 'app-profile-editor',
        template: `
        // --- --- ---
        Name:  &lt;input type="text" [formControl]="name"&gt;
        &lt;button (click)="updateName()"&gt;Update Name &lt;/button&gt;
        &lt;p&gt;Value: {{ name.value }} &lt;/p&gt;
        // --- --- ---
        &lt;form [formGroup]="profileForm" (ngSubmit)="onSubmit()"&gt;
          First Name:  &lt;input type="text" formControlName="firstName" required &gt;
            &lt;div *ngIf="profileForm.get('firstName').invalid && (profileForm.get('firstName').dirty || profileForm.get('firstName').touched)""&gt;
              &lt;div *ngIf="profileForm.get('firstName').errors.required""&gt;Name is required&lt;/div"&gt;
              &lt;div *ngIf="profileForm.get('firstName').errors.minlength""&gt;
                Name must be at least 4 characters long
              &lt;/div"&gt;
              &lt;div *ngIf="firstName.errors.forbiddenName""&gt;Name cannot be Bob&lt;/div"&gt;
            &lt;/div"&gt;
          Last Name:  &lt;input type="text" formControlName="lastName"&gt;
          &lt;div formGroupName="address"&gt;
            &lt;h3&gt;Address &lt;/h3&gt;
            Street:  &lt;input type="text" formControlName="street"&gt;
            City:  &lt;input type="text" formControlName="city"&gt;
            State:  &lt;input type="text" formControlName="state"&gt;
            Zip Code:  &lt;input type="text" formControlName="zip"&gt;
            &lt;p&gt;Value: {{ profileForm.get('address').street.value }} &lt;/p&gt;
          &lt;/div&gt;
          &lt;button (click)="updateProfile()"&gt;Update Profile &lt;/button&gt;
          // --- --- ---
          &lt;div formArrayName="cities"&gt;
            &lt;div *ngFor="let city of cities.controls; index as i"&gt;
              &lt;input [formControlName]="i" placeholder="City"&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;button (click)="addCity()"&gt;Add City &lt;/button&gt;
          // --- --- ---
          &lt;div formArrayName="aliases"&gt;
            &lt;h3&gt;Aliases &lt;/h3&gt;  &lt;button (click)="addAlias()"&gt;Add Alias &lt;/button&gt;
            &lt;div *ngFor="let address of aliases.controls; let i=index"&gt;
              &lt;!-- The repeated alias template --&gt;
              Alias:  &lt;input type="text" [formControlName]="i"&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          // --- --- ---
          &lt;button type="submit" [disabled]="!profileForm.valid"&gt;
            Submit
          &lt;/button&gt;
          Form Status: {{ profileForm.status }}
        &lt;/form&gt;
        // --- --- ---
        `
      })
      export class ProfileEditorComponent {
        constructor(private fb: FormBuilder) { }

        name = new FormControl('');
        updateName() {
          this.name.setValue(
            'Nancy',
            // delay updating form validity: change(default)|submit|blur
            {updateOn: 'blur'}
          );
        }

        // --- WITH INSTANCES

        profileForm = new FormGroup({
          firstName: new FormControl('Andrei',[
            Validators.required,
            Validators.minLength(4),
            forbiddenNameValidator(/bob/i) // how you pass in the custom validator
          ]),
          lastName: new FormControl('T.', Validators.required),
          address: new FormGroup({
            street: new FormControl(''),
            city: new FormControl(''),
            state: new FormControl(''),
            zip: new FormControl('')
          }),
          cities: new FormArray([
            new FormControl('SF'),
            new FormControl('NY'),
          ]),
        });
        get cities(): FormArray { return this.profileForm.get('cities') as FormArray; }
        addCity() { this.cities.push(new FormControl()); }
        onSubmit() {
          console.log(this.cities.value);  // ['SF', 'NY']
          console.log(this.form.value);    // { cities: ['SF', 'NY'] }
        }
        setPreset() { this.cities.patchValue(['LA', 'MTV']); }

        // --- WITH FORM BUILDER

        profileForm = this.fb.group({
          firstName: ['', Validators.required],
          lastName: [''],
          address: this.fb.group({
            street: [''],
            city: [''],
            state: [''],
            zip: ['']
          }),
          // undefined number of controls in an array
          aliases: this.fb.array([
            this.fb.control('')
          ])
        });
        get aliases() {
          return this.profileForm.get('aliases') as FormArray;
        }
        addAlias() {
          this.aliases.push(this.fb.control(''));
        }
        // ---
        updateProfile() {
          this.profileForm.patchValue({
            firstName: 'Andrei',
            address: {
              street: '123 Here Street'
            }
          });
        }
        // setValue() { this.form.setValue({first: 'Carson', last: 'Drew'}); }
        onSubmit() {
          // TODO: Use EventEmitter with form value
          console.warn(this.profileForm.value);
        }
      }
    </code></pre>
  </details>

  <details>
  <summary>TEMPLATE-DRIVEN</summary>
    <pre><code class="ts">
      // --- src/app/app.module.ts
      import { FormsModule } from '@angular/forms';
      @NgModule({
        imports: [
          // other imports ...
          FormsModule
        ],
      })
      export class AppModule { }
      // ---  &lt;app-hero-form&gt;&lt;/app-hero-form&gt;
      import { Component } from '@angular/core';
      import { Hero }    from '../hero';
      @Component({
        selector: 'app-hero-form',
        template: `
        &lt;div&gt;
          &lt;div [hidden]="submitted"&gt;
            &lt;h1&gt;Hero Form&lt;/h1&gt;
            &lt;form (ngSubmit)="onSubmit()" #heroForm="ngForm"&gt;
              &lt;div&gt;
                &lt;label for="name"&gt;Name&lt;/label&gt;
                &lt;input type="text" id="name"
                        required minlength="4" appForbiddenName="bob"
                        [(ngModel)]="model.name" name="name"
                        // delay updating the form validity
                        [ngModelOptions]="{updateOn: 'blur'}"
                        #name="ngModel"&gt;
                &lt;div *ngIf="name.invalid && (name.dirty || name.touched)"
                    class="alert alert-danger"&gt;
                  &lt;div *ngIf="name.errors.required"&gt;
                    Name is required.
                  &lt;/div&gt;
                  &lt;div *ngIf="name.errors.minlength"&gt;
                    Name must be at least 4 characters long.
                  &lt;/div&gt;
                  &lt;div *ngIf="name.errors.forbiddenName"&gt;
                    Name cannot be Bob.
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;
              &lt;div&gt;
                &lt;label for="alterEgo"&gt;Alter Ego&lt;/label&gt;
                &lt;input type="text" id="alterEgo"
                        [(ngModel)]="model.alterEgo" name="alterEgo"&gt;
              &lt;/div&gt;
              &lt;div&gt;
                &lt;label for="power"&gt;Hero Power&lt;/label&gt;
                &lt;select id="power" required
                        [(ngModel)]="model.power" name="power"
                        #power="ngModel"&gt;
                  &lt;option *ngFor="let pow of powers" [value]="pow"&gt;{{pow}}&lt;/option&gt;
                &lt;/select&gt;
                &lt;div [hidden]="power.valid || power.pristine"&gt;
                  Power is required
                &lt;/div&gt;
              &lt;/div&gt;
              &lt;button type="submit"
                      [disabled]="!heroForm.form.valid"&gt;Submit&lt;/button&gt;
              &lt;button type="button"
                      (click)="newHero(); heroForm.reset()"&gt;New Hero&lt;/button&gt;
            &lt;/form&gt;
          &lt;/div&gt;
          &lt;div [hidden]="!submitted"&gt;
            &lt;h2&gt;You submitted the following:&lt;/h2&gt;
            Name: {{ model.name }}&lt;br&gt;
            Alter Ego: {{ model.alterEgo }}&lt;br&gt;
            Power: {{ model.power }}&lt;br&gt;
            &lt;button  (click)="submitted=false"&gt;Edit&lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        `,
        style: `
          .ng-valid[required], .ng-valid.required  {
            border-left: 5px solid #42A948; /* green */
          }
          .ng-invalid:not(form)  {
            border-left: 5px solid #a94442; /* red */
          }
        `
      })
      export class HeroFormComponent {
        powers = ['Really Smart', 'Super Flexible',
                  'Super Hot', 'Weather Changer'];
        model = new Hero(18, 'Dr IQ', this.powers[0], 'Chuck Overstreet');
        submitted = false;
        onSubmit() { this.submitted = true; }
        newHero() {
          this.model = new Hero(42, '', '');
        }
      }
    </code></pre>
  </details>

  <details>
  <summary>custom validators</summary>
    <pre><code class="ts">
      //--- validator for reactive form
      // forbidden-name.directive.ts (forbiddenNameValidator)
      // name cant match the given regular expression
      export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn {
        return (control: AbstractControl): {[key: string]: any} | null => {
          const forbidden = nameRe.test(control.value);
          return forbidden ? {'forbiddenName': {value: control.value}} : null;
        };
      }
      //--- extending for template driven form as directive
      @Directive({
        selector: '[appForbiddenName]',
        providers: [{
          provide: NG_VALIDATORS,
          useExisting: ForbiddenValidatorDirective,
          multi: true
        }]
      })
      export class ForbiddenValidatorDirective implements Validator {
        @Input('appForbiddenName') forbiddenName: string;
        validate(control: AbstractControl): {[key: string]: any} | null {
          return this.forbiddenName ?
            forbiddenNameValidator(new RegExp(this.forbiddenName, 'i'))(control) : null;
        }
      }
    </code></pre>
  </details>

  <details>
  <summary>cross-field validation</summary>
    <pre><code class="ts">
      // REACTIVE
      const heroForm = new FormGroup({
        'name': new FormControl(),
        'alterEgo': new FormControl(),
        'power': new FormControl()
      }, { validators: identityRevealedValidator });
      // //--- shared/identity-revealed.directive.ts
      // // name cant match the hero alter ego
      // export const identityRevealedValidator: ValidatorFn =
      //   (control: FormGroup): ValidationErrors | null =&gt; {
      //     const name = control.get('name');
      //     const alterEgo = control.get('alterEgo');
      //     return name && alterEgo &&
      //       name.value === alterEgo.value ? { 'identityRevealed': true } : null;
      // };
      // --- --- ---
      // &lt;div
      // *ngIf="heroForm.errors?.identityRevealed && (heroForm.touched || heroForm.dirty)"
      // class="cross-validation-error-message alert alert-danger"&gt;
      //     Name cannot match alter ego.
      // &lt;/div&gt;
      // for TEMPLATE-DRIVEN
      @Directive({
        selector: '[appIdentityRevealed]',
        providers: [{
          provide: NG_VALIDATORS,
          useExisting: IdentityRevealedValidatorDirective,
          multi: true
        }]
      })
      export class IdentityRevealedValidatorDirective implements Validator {
        validate(control: AbstractControl): ValidationErrors {
          return identityRevealedValidator(control)
        }
      }
      // &lt;form #heroForm="ngForm" appIdentityRevealed&gt;
      //   &lt;div *ngIf="heroForm.errors?.identityRevealed &&
      //      (heroForm.touched || heroForm.dirty)"
      //     class="cross-validation-error-message alert alert-danger"&gt;
      //       Name cannot match alter ego.
      //   &lt;/div&gt;
    </code></pre>
  </details>

  <details>
  <summary>custom async validator</summary>
    <pre><code class="ts">
      @Injectable({ providedIn: 'root' })
      export class UniqueAlterEgoValidator implements AsyncValidator {
        constructor(private heroesService: HeroesService) {}
        validate(
          ctrl: AbstractControl
        ): Promise&lt;ValidationErrors | null&gt; | Observable&lt;ValidationErrors | null&gt; {
          return this.heroesService.isAlterEgoTaken(ctrl.value).pipe(
            map(isTaken => (isTaken ? { uniqueAlterEgo: true } : null)),
            catchError(() => null)
          );
        }
      }
      //--------------------------------
      // responsible for check if the alter ego is available
      interface HeroesService {
        isAlterEgoTaken: (alterEgo: string) => Observable&lt;boolean&gt;;
      }
    </code></pre>
  </details>

  <details>
  <summary>tests</summary>
    <pre><code class="ts">
      // reactive form - view to model test
      it('should update the value of the input field', () => {
        // query the view for the form input element
        const input = fixture.nativeElement.querySelector('input');
        // custom "input" event for the test
        const event = createNewEvent('input');
        input.value = 'Red';
        input.dispatchEvent(event);
        // assert component favoriteColorControl value
        expect(
          fixture.componentInstance.favoriteColorControl.value
        ).toEqual('Red');
      });

      // template-driven form
      // requires a detailed knowledge of the change detection process
      // and an understanding of how directives run on each cycle
      // to ensure that elements are queried, tested, or changed at the correct time
      // view to model test
      it('should update the favorite color in the component', fakeAsync(() => {
        const input = fixture.nativeElement.querySelector('input');
        const event = createNewEvent('input');
        input.value = 'Red';
        input.dispatchEvent(event);
        fixture.detectChanges();
        expect(component.favoriteColor).toEqual('Red');
      }));
      // model to view
      it('should update the favorite color on the input field', fakeAsync(() => {
        component.favoriteColor = 'Blue';
        fixture.detectChanges();
        tick();
        const input = fixture.nativeElement.querySelector('input');
        expect(input.value).toBe('Blue');
      }));
    </code></pre>
  </details>

  <img src="../images/key-diff-reactive-forms.png"
  style="position:relative;width:80%;margin-left:10%;">
  <img src="../images/key-diff-td-forms.png"
  style="position:relative;width:80%;margin-left:10%;">
  <img src="../images/dataflow-reactive-forms-vtm.png"
  style="position:relative;width:80%;margin-left:10%;">
  <img src="../images/dataflow-reactive-forms-mtv.png"
  style="position:relative;width:80%;margin-left:10%;">
  <img src="../images/dataflow-td-forms-vtm.png"
  style="position:relative;width:80%;margin-left:10%;">
  <img src="../images/dataflow-td-forms-mtv.png"
  style="position:relative;width:80%;margin-left:10%;">

  <table>
    <thead>
    <tr>
    <th></th>
    <th>Reactive</th>
    <th>Template-driven</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td>Setup (form model)</td>
    <td>More explicit, created in component class</td>
    <td>Less explicit, created by directives</td>
    </tr>
    <tr>
    <td>Data model</td>
    <td>Structured</td>
    <td>Unstructured</td>
    </tr>
    <tr>
    <td>Predictability</td>
    <td>Synchronous</td>
    <td>Asynchronous</td>
    </tr>
    <tr>
    <td>Form validation</td>
    <td>Functions</td>
    <td>Directives</td>
    </tr>
    <tr>
    <td>Mutability</td>
    <td>Immutable</td>
    <td>Mutable</td>
    </tr>
    <tr>
    <td>Scalability</td>
    <td>Low-level API access</td>
    <td>Abstraction on top of APIs</td>
    </tr>
    </tbody>
  </table>



<h2 id="observables">Observables</h2>

  <ul>
    <li>provide support for passing messages between publishers and subscribers</li>
    <li>you define a function for publishing values, subscribed consumer then receives notifications until the function completes, or until they unsubscribe</li>
    <li>ActivatedRoute observables are among exceptions that dont need unsubscription - Router destroys a routed component when it is no longer needed and the injected ActivatedRoute dies with it, feel free to unsubscribe anyway, harmless and never a bad practice</li>
    <li>as a publisher, you create an Observable instance that defines a subscriber function (how to obtain or generate values or messages to be published), executed when a consumer calls the subscribe() method, passing this observer</li>
    <li>Observable instance begins publishing values from new, independent execution for each subscribed observer only when someone subscribes to it, calling the subscribe() method of the instance, passing an observer object to receive the notifications</li>
    <li>types of notifications that an observable can send:
      <ul>
        <li>next - required, handler for each delivered value, called zero or more times after execution starts</li>
        <li>error - optional, handler for an error notification, error halts execution of the observable instance</li>
        <li>complete - optional, handler for the execution-complete notification, delayed values can continue to be delivered to the next handler after execution is complete</li>
      </ul>
    </li>
    <li>Angular examples of usage
      <ul>
        <li>EventEmitter class - used when publishing values from a component through the @Output() decorator,extends Observable, adding an emit() method so it can send arbitrary values, when you call emit(), it passes the emitted value to the next() method of any subscribed observer</li>
        <li>HttpClient returns observables from HTTP method calls</li>
        <li>AsyncPipe subscribes to an observable or promise and returns the latest value it has emitted</li>
        <li>Router.events provides events as observables</li>
        <li>ActivateRoute.url contains an observable that reports the route path or paths</li>
        <li>Reactive forms have properties that use observables to monitor form control values, subscribing to an observable form-control property is a way of triggering application logic within the component class</li>
      </ul>
    </li>
    <li>subscribe to an Observable without providing any unsubscription logic in case such: <strong>some components (eg AppComponent) and most of the services (with exception of services from lazy loaded modules and services provided in @Component decorator) in Angular application will be instantiated only once during the application startup</strong></li>
    <li><strong>multicasting</strong> - broadcasting to a list of multiple subscribers in a single execution, re-using the first listener and send values out to each subscriber</li>
    <li>stopwatchValue$: Observable&lt;number&gt;; - use $ for observable name</li>
    <li>use <strong>pipes</strong> to link operators together, combine multiple functions into a single function, pipe() function takes as its arguments the functions you want to combine, and returns a new function that, when executed, runs the composed functions in sequence</li>
    <li>type-ahead suggestions
      <ul>
        <li>listen for data from an input</li>
        <li>trim the value (remove whitespace) and make sure its a minimum length</li>
        <li>debounce (so as not to send off API requests for every keystroke, but instead wait for a break in keystrokes)</li>
        <li>dont send a request if the value stays the same (rapidly hit a character, then backspace, for instance)</li>
        <li>cancel ongoing AJAX requests if their results will be invalidated by the updated results</li>
      </ul>
    </li>
    <li>exponential backoff - retry an API after failure, making the time in between retries longer after each consecutive failure, with a maximum number of retries after which the request is considered to have failed</li>
    <li>vs Promises:
      <ul>
        <li>computation does not start until subscription</li>
        <li>provide many values, makes useful for getting multiple values over time</li>
        <li>differentiate between chaining and subscription, useful for creating complex transformation recipes to be used by other part of the system, without causing the work to be executed</li>
        <li>subscribe() is responsible for handling errors, promises push errors to the child promises</li>
        <li>promises are not cancellable (vs. unsubscribe())</li>
      </ul>
    </li>
  </ul>

  <pre><code class="ts">
    // create simple observable that emits three values
    const myObservable = of(1, 2);
    // create observer object
    const myObserver = {
      next: x => console.log('Observer got a next value: ' + x),
      error: err => console.error('Observer got an error: ' + err),
      complete: () => console.log('Observer got a complete notification'),
    };
    // execute with the observer object
    myObservable.subscribe(myObserver);
    // myObservable.subscribe(
    //   x => console.log(x),
    //   err => console.error('Observer got an error: ' + err),
    //   () => console.log('Observer got a complete notification')
    // );
    // logs: 1 , 2 , Observer got a complete notification
    // --- SAME AS
    function sequenceSubscriber(observer) { // runs when subscribe() is called
      // synchronously deliver 1 and 2 then complete
      observer.next(1);
      observer.next(2);
      observer.complete();
      return {unsubscribe() {}}; // no scenario here, values delivered synchronously
    }
    const sequence = new Observable(sequenceSubscriber); // deliver the above sequence
    sequence.subscribe({
      next(num) { console.log(num); },
      complete() { console.log('Finished sequence'); }
    });
    // Logs: 1 , 2 , Finished sequence
  </code></pre>

  <h3>EXAMPLES</h3>
  <pre><code class="ts">
    // --- UNSUBSCRIBING
    @Component({...})
    export class LineChartComponent implements OnInit {
      private subscription: Subscription = new Subscription();
      everySecond$: Observable<number> = timer(1, 1000);
      everyMinute$: Observable<number> = timer(1, 60000);
      ngOnInit() {
        this.subscription.add(this.everySecond$.subscribe(
          second => console.log(second)
        ));
        ngOnInit() {
          this.subscription.add(this.everyMinute$.subscribe(
            minute => console.log(minute)
          ));
      }
      ngOnDestroy() {
        this.subscription.unsubscribe();
      }
    }

    // --- MULTICASTING
    function multicastSequenceSubscriber() {
      const seq = [1, 2, 3];
      const observers = [];
      let timeoutId;
      return (observer) => {
        observers.push(observer);
        // start the sequence on first subscription
        if (observers.length === 1) {
          timeoutId = doSequence({
            next(val) { observers.forEach(obs => obs.next(val)); },
            complete() { observers.slice(0).forEach(obs => obs.complete()); }
          }, seq, 0);
        }
        return {
          unsubscribe() {
            // remove from the observers array
            observers.splice(observers.indexOf(observer), 1);
            // cleanup if there is no more listeners
            if (observers.length === 0) { clearTimeout(timeoutId); }
          }
        };
      };
    }
    // Run through an array of numbers, emitting one value
    // per second until it gets to the end of the array.
    function doSequence(observer, arr, idx) {
      return setTimeout(() => {
        observer.next(arr[idx]);
        if (idx === arr.length - 1) {
          observer.complete();
        } else {
          doSequence(observer, arr, ++idx);
        }
      }, 1000);
    }
    // Create a new Observable that will deliver the above sequence
    const multicastSequence = new Observable(multicastSequenceSubscriber());
    // Subscribe starts the clock, and begins to emit after 1 second
    multicastSequence.subscribe({
      next(num) { console.log('1st subscribe: ' + num); },
      complete() { console.log('1st sequence finished.'); }
    });
    // After 1 1/2 seconds, subscribe again (should "miss" the first value).
    setTimeout(() => {
      multicastSequence.subscribe({
        next(num) { console.log('2nd subscribe: ' + num); },
        complete() { console.log('2nd sequence finished.'); }
      });
    }, 1500);
    // Logs:
    // (at 1 second): 1st subscribe: 1
    // (at 2 seconds): 1st subscribe: 2
    // (at 2 seconds): 2nd subscribe: 2
    // (at 3 seconds): 1st subscribe: 3
    // (at 3 seconds): 1st sequence finished
    // (at 3 seconds): 2nd subscribe: 3
    // (at 3 seconds): 2nd sequence finished

    // --- PIPE
    import { filter, map } from 'rxjs/operators';
    const squareOdd = of(1, 2, 3, 4, 5)
      .pipe(
        filter(n => n % 2 !== 0),
        map(n => n * n)
      );
    // Subscribe to get values
    squareOdd.subscribe(x => console.log(x));

    // ---  EventEmitter
    // component that listens for open and close events
    // &lt;zippy (open)="onOpen($event)" (close)="onClose($event)"&gt;&lt;/zippy&gt;
    @Component({
      selector: 'zippy',
      template: `
      &lt;div class="zippy"&gt;
        &lt;div (click)="toggle()"&gt;Toggle&lt;/div&gt;
        &lt;div [hidden]="!visible"&gt;
          &lt;ng-content&gt;&lt;/ng-content&gt;
        &lt;/div&gt;
      &lt;/div&gt;`})
    export class ZippyComponent {
      visible = true;
      @Output() open = new EventEmitter&lt;any&gt;();
      @Output() close = new EventEmitter&lt;any&gt;();
      toggle() {
        this.visible = !this.visible;
        if (this.visible) {
          this.open.emit(null);
        } else {
          this.close.emit(null);
        }
      }
    }

    // --- AsyncPipe
    @Component({
      selector: 'async-observable-pipe',
      template: `Time: {{ time | async }}`
    })
    export class AsyncObservablePipeComponent {
      time = new Observable(observer =>
        setInterval(() => observer.next(new Date().toString()), 1000)
      );
    }

    // --- Router
    import { Router, ActivatedRoute, NavigationStart } from '@angular/router';
    import { filter } from 'rxjs/operators';
    @Component({ selector: 'app-routable', ... })
    export class Routable1Component implements OnInit {
      navStart: Observable&lt;NavigationStart&gt;;
      constructor(
        private router: Router,
        private activatedRoute: ActivatedRoute
      ) {
        // look for events of interest, only the NavigationStart event
        this.navStart = router.events.pipe(
          filter(evt => evt instanceof NavigationStart)
        ) as Observable&lt;NavigationStart&gt;;
      }
      ngOnInit() {
        this.navStart.subscribe(evt => console.log('Navigation Started!'));
        // report the route path or paths
        this.activatedRoute.url
          .subscribe(url => console.log('The URL changed to: ' + url));
      }
    }

    // --- Reactive forms
    import { FormGroup } from '@angular/forms';
    @Component({
      selector: 'my-component', ...
    })
    export class MyComponent implements OnInit {
      nameChangeLog: string[] = [];
      heroForm: FormGroup;
      ngOnInit() {
        this.logNameChange();
      }
      logNameChange() {
        // valueChanges and statusChanges contain change events observables
        const nameControl = this.heroForm.get('name');
        nameControl.valueChanges.forEach(
          (value: string) => this.nameChangeLog.push(value)
        );
      }
    }

    // --- Typeahead
    import { fromEvent } from 'rxjs';
    import { ajax } from 'rxjs/ajax';
    import {
      map, filter, debounceTime, distinctUntilChanged, switchMap
    } from 'rxjs/operators';
    const searchBox = document.getElementById('search-box');
    const typeahead = fromEvent(searchBox, 'input').pipe(
      map((e: KeyboardEvent) => e.target.value),
      filter(text => text.length > 2),
      debounceTime(10),
      distinctUntilChanged(),
      switchMap(() => ajax('/api/endpoint'))
    );
    typeahead.subscribe(data => {
     // Handle the data from the API
    });


    import { pipe, range, timer, zip } from 'rxjs';
    import { ajax } from 'rxjs/ajax';
    import { retryWhen, map, mergeMap } from 'rxjs/operators';
    function backoff(maxTries, ms) {
     return pipe(
       retryWhen(attempts => zip(range(1, maxTries), attempts)
         .pipe(
           map(([i]) => i * i),
           mergeMap(i =>  timer(i * ms))
    )))}
    ajax('/api/endpoint')
      .pipe(backoff(3, 250)).subscribe(data => handleData(data));
    function handleData(data) { /*...*/ }

    // start listening to geolocation updates when a consumer subscribes
    const locations = new Observable((observer) => {
      // next and error callbacks, passed when the consumer subscribes
      const {next, error} = observer;
      let watchId;
      // geolocation API check provides values to publish
      if ('geolocation' in navigator) {
        watchId = navigator.geolocation.watchPosition(next, error);
      } else { error('Geolocation not available'); }
      // consumer unsubscribes, clean up data ready for next subscription.
      return {unsubscribe() { navigator.geolocation.clearWatch(watchId); }};
    });
    // call subscribe() to start listening for updates.
    const locationsSubscription = locations.subscribe({
      next(position) { console.log('Current Position: ', position); },
      error(msg) { console.log('Error Getting Location: ', msg); }
    });
    // Stop listening for location after 10 seconds
    setTimeout(() => { locationsSubscription.unsubscribe(); }, 10000);
  </code></pre>

  <h3>Observables VS Promises</h3>
  <table style="width:95%">
    <thead>
      <tr>
        <th>Operation</th>
        <th>Observable</th>
        <th>Promise</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Creation</td>
        <td>
          &nbsp;new Observable((observer) =&gt; {<br>
          &nbsp;&nbsp;observer.next(123);<br>
          &nbsp;});<br>
        </td>
        <td>
          &nbsp;new Promise((resolve, reject) =&gt; {<br>
          &nbsp;&nbsp;resolve(123);<br>
          &nbsp;});<br>
        </td>
      </tr>
      <tr>
        <td>Transform</td>
        <td>obs.map((value) =&gt; value * 2 );</td>
        <td>promise.then((value) =&gt; value * 2);</td>
      </tr>
      <tr>
        <td>Subscribe</td>
        <td>
          &nbsp;sub = obs.subscribe((value) =&gt; {<br>
          &nbsp;&nbsp;console.log(value)<br>
          &nbsp;});<br>
        </td>
        <td>
          &nbsp;promise.then((value) =&gt; {<br>
          &nbsp;&nbsp;console.log(value);<br>
          &nbsp;});<br>
        </td>
      </tr>
      <tr>
        <td>Unsubscribe</td>
        <td>sub.unsubscribe();</td>
        <td>Implied by promise resolution.</td>
      </tr>
    </tbody>
  </table>

  <h3>Observables VS Events API</h3>
  <table>
    <tbody><tr>
      <th></th>
      <th>Observable</th>
      <th>Events API</th>
    </tr>
    <tr>
      <td>Creation &amp; cancellation</td>
      <td>
        &nbsp;// Setup<br>
        &nbsp;let clicks$ = fromEvent(buttonEl, â€˜clickâ€™);<br>
        &nbsp;// Begin listening<br>
        &nbsp;let subscription = clicks$<br>
        &nbsp;&nbsp;.subscribe(e =&gt; console.log(â€˜Clickedâ€™, e))<br>
        &nbsp;// Stop listening<br>
        &nbsp;subscription.unsubscribe();<br>
      </td>
      <td>
        &nbsp;function handler(e) {<br>
        &nbsp;&nbsp;console.log(â€˜Clickedâ€™, e);<br>
        &nbsp;}<br>
        &nbsp;// Setup &amp; begin listening<br>
        &nbsp;button.addEventListener(â€˜clickâ€™, handler);<br>
        &nbsp;// Stop listening<br>
        &nbsp;button.removeEventListener(â€˜clickâ€™, handler);<br>
      </td>
    </tr>
    <tr>
      <td>Subscription</td>
      <td>
        &nbsp;observable.subscribe(() =&gt; {<br>
        &nbsp;&nbsp;// notification handlers here<br>
        &nbsp;});<br>
      </td>
      <td>
        &nbsp;element.addEventListener(<br>
        &nbsp;&nbsp;eventName, <br>
        &nbsp;&nbsp;(event) =&gt; {<br>
        &nbsp;&nbsp;// notification handler here<br>
        &nbsp;});<br>
      </td>
    </tr>
    <tr>
      <td>Configuration</td>
      <td>Listen for keystrokes, but provide a stream representing the value in the input<br>
        &nbsp;fromEvent(inputEl, 'keydown').pipe(<br>
        &nbsp;&nbsp;map(e =&gt; e.target.value)<br>
        &nbsp;);<br>
      </td>
      <td>Does not support configuration<br>
        &nbsp;element.addEventListener(<br>
        &nbsp;&nbsp;eventName, <br>
        &nbsp;&nbsp;(event) =&gt; {<br>
        &nbsp;&nbsp;// Cannot change the passed Event into another<br>
        &nbsp;&nbsp;// value before it gets to the handler<br>
        &nbsp;});<br>
      </td>
    </tr>
    </tbody>
  </table>

  <h3>Observables VS arrays</h3>
  <table>
    <tbody><tr>
      <th></th>
      <th>Observable</th>
      <th>Array</th>
    </tr>
    <tr>
      <td>Given</td>
      <td>
        <pre>obs: âžž1âžž2âžž3âžž5âžž7</pre>
        <pre>obsB: âžž'a'âžž'b'âžž'c'</pre>
      </td>
      <td>
        <pre>arr: [1, 2, 3, 5, 7]</pre>
        <pre>arrB: ['a', 'b', 'c']</pre>
      </td>
    </tr>
    <tr>
      <td><pre>concat()</pre></td>
      <td>
        <pre>obs.concat(obsB)</pre>
        <pre>âžž1âžž2âžž3âžž5âžž7âžž'a'âžž'b'âžž'c'</pre>
      </td>
      <td>
        <pre>arr.concat(arrB)</pre>
        <pre>[1,2,3,5,7,'a','b','c']</pre>
      </td>
    </tr>
    <tr>
      <td><pre>filter()</pre></td>
      <td>
        <pre>obs.filter((v) =&gt; v&gt;3)</pre>
        <pre>âžž5âžž7</pre>
      </td>
      <td>
        <pre>arr.filter((v) =&gt; v&gt;3)</pre>
        <pre>[5, 7]</pre>
      </td>
    </tr>
    <tr>
      <td><pre>find()</pre></td>
      <td>
        <pre>obs.find((v) =&gt; v&gt;3)</pre>
        <pre>âžž5</pre>
      </td>
      <td>
        <pre>arr.find((v) =&gt; v&gt;3)</pre>
        <pre>5</pre>
      </td>
    </tr>
    <tr>
      <td><pre>findIndex()</pre></td>
      <td>
        <pre>obs.findIndex((v) =&gt; v&gt;3)</pre>
        <pre>âžž3</pre>
      </td>
      <td>
        <pre>arr.findIndex((v) =&gt; v&gt;3)</pre>
        <pre>3</pre>
      </td>
    </tr>
    <tr>
      <td><pre>forEach()</pre></td>
      <td>
        <pre>obs.forEach((v) =&gt; { console.log(v); })
          1 2 3 5 7
        </pre>
      </td>
      <td>
        <pre>arr.forEach((v) =&gt; { console.log(v); })
          1 2 3 5 7
        </pre>
      </td>
    </tr>
    <tr>
      <td><pre>map()</pre></td>
      <td>
        <pre>obs.map((v) =&gt; -v)</pre>
        <pre>âžž-1âžž-2âžž-3âžž-5âžž-7</pre>
      </td>
      <td>
        <pre>arr.map((v) =&gt; -v)</pre>
        <pre>[-1, -2, -3, -5, -7]</pre>
      </td>
    </tr>
    <tr>
      <td><pre>reduce()</pre></td>
      <td>
        <pre>obs.scan((s,v)=&gt; s+v, 0)</pre>
        <pre>âžž1âžž3âžž6âžž11âžž18</pre>
      </td>
      <td>
        <pre>arr.reduce((s,v) =&gt; s+v, 0)</pre>
        <pre>18</pre>
      </td>
    </tr>
  </tbody></table>



<h2 id="http">Http/requests</h2>
  <ul>
    <li>import HttpClientModule, inject HttpClient</li>
    <li>HttpClient method does not begin its HTTP request until you call subscribe() on the observable returned by that method, true for all HttpClient methods</li>
    <li>AsyncPipe subscribes (and unsubscribes) for you automatically</li>
    <li>HTTP Interception - inspect and transform HTTP requests
      <ul>
        <li>declare a class that implements the intercept() method of the HttpInterceptor interface</li>
        <li>intercept method transforms a request into an Observable that eventually returns the HTTP response</li>
        <li>fully capable of handling the request entirely by itself</li>
        <li><strong>next</strong> object represents the next interceptor in the chain of interceptors, could be skipped to return Observer as artificial response</li>
        <li>provide in the same injector (or a parent of the injector) that provides HttpClient, interceptors provided after DI creates the HttpClient are ignored</li>
        <li>interceptors are applied in the order that you provide them: interceptors A, then B, then C, handles requests <strong>flow in A->B->C</strong> and responses <strong>flow out C->B->A</strong></li>
        <li>you <strong>cannot change the order or remove interceptors later</strong>, if you need to enable and disable an interceptor dynamically, you will have to build that capability into the interceptor itself</li>
        <li>TS will prevent you from setting HttpRequest readonly properties, to alter the request, clone it first and modify the clone before passing it to next.handle()</li>
        <li>if you must mutate the request body, copy it first, change the copy, clone() the request, and set the clone body with the new body</li>
      </ul>
    </li>
  </ul>

  <pre><code class="ts">
    // app.module.ts
    import { NgModule }         from '@angular/core';
    import { BrowserModule }    from '@angular/platform-browser';
    import { HttpClientModule } from '@angular/common/http';
    import { HttpClientXsrfModule } from '@angular/common/http';
    import { httpInterceptorProviders } from './http-interceptors/index';
    @NgModule({
      imports: [
        BrowserModule,
        // import HttpClientModule after BrowserModule
        HttpClientModule,
        // configuring custom cookie/header names
        HttpClientXsrfModule.withOptions({
          cookieName: 'My-Xsrf-Cookie',
          headerName: 'My-Xsrf-Header',
        }),
      ],
      declarations: [
        AppComponent,
      ],
      providers: [
        httpInterceptorProviders
      ],
      bootstrap: [ AppComponent ]
    })
    export class AppModule {}

    // http-interceptors/index.ts
    // "Barrel" of Http Interceptors
    import { HTTP_INTERCEPTORS } from '@angular/common/http';
    import { AuthInterceptor } from './auth-interceptor';
    import { CachingInterceptor } from './caching-interceptor';
    import { EnsureHttpsInterceptor } from './ensure-https-interceptor';
    import { LoggingInterceptor } from './logging-interceptor';
    import { TrimNameInterceptor } from './trim-name-interceptor';
    import { UploadInterceptor } from './upload-interceptor';
    // Http interceptor providers in outside-in order
    export const httpInterceptorProviders = [
      { provide: HTTP_INTERCEPTORS, useClass: EnsureHttpsInterceptor, multi: true },
      { provide: HTTP_INTERCEPTORS, useClass: TrimNameInterceptor, multi: true },
      { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },
      { provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true },
      { provide: HTTP_INTERCEPTORS, useClass: UploadInterceptor, multi: true },
      { provide: HTTP_INTERCEPTORS, useClass: CachingInterceptor, multi: true },
      // multi: true - multiprovider, inject this array of values, rather than a single value in root
    ];
  </code></pre>

  <details>
  <summary>note.service.ts</summary>
  <pre><code class="ts">
    import { Injectable } from '@angular/core';
    import { Observable, of } from 'rxjs';
    import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
    import { catchError, map, tap } from 'rxjs/operators';
    const httpOptions = {
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'x-refresh':  'true'
      })
    };

    function createHttpOptions(packageName: string, refresh = false) {
      // npm package name search api: http://npmsearch.com/query?q=dom
      const params = new HttpParams({ fromObject: { q: packageName } });
      const headerMap = refresh ? {'x-refresh': 'true'} : {};
      const headers = new HttpHeaders(headerMap) ;
      return { headers, params };
    }

    // export interface NpmPackageInfo {
    //   name: string;
    //   version: string;
    //   description: string;
    // }

    import { Note } from './note';
    // import { NOTES } from './mock-notes';
    import { MessageService } from './message.service';

    export const notesUrl = 'api/notes';

    @Injectable({
      providedIn: 'root' // injects into any class that asks for it
    })
    export class NoteService {// URL to web api
      constructor(
        private http: HttpClient,
        private messageService: MessageService // injecting other service
      ) { }
      // getNotes(): Note[] {
      //   return NOTES;
      // }
      getNotes(): Observable&lt;Note[]&gt; {
        // TODO: send the message _after_ fetching the heroes
        // this.log('fetched notes');
        // return of(NOTES);
        return this.http.get&lt;Note[]&gt;(notesUrl).pipe(
          tap(_ =&gt; this.log('fetched notes')),
          catchError(this.handleError('getNotes', []))
        );
      }
      getNoteNo404&lt;Data&gt;(id: number): Observable&lt;Note&gt; {
        const url = `${notesUrl}/?id=${id}`;
        return this.http.get&lt;Note[]&gt;(url)
          .pipe(
            map(notes =&gt; notes[0]), // returns a {0|1} element array
            tap(h =&gt; {
              const outcome = h ? `fetched` : `did not find`;
              this.log(`${outcome} note id=${id}`);
            }),
            catchError(this.handleError&lt;Note&gt;(`getNote id=${id}`))
          );
      }
      getNote(id: number): Observable&lt;Note&gt; {
        // this.log(`fetched note id=${id}`); // send _after_ fetching the heroes
        // return of(NOTES.find(note =&gt; note.id === id));
        const url = `${notesUrl}/${id}`;
        return this.http.get&lt;Note&gt;(url).pipe(
          tap(_ =&gt; this.log(`fetched note id=${id}`)),
          catchError(this.handleError&lt;Note&gt;(`getNote id=${id}`))
        );
      }
      updateNote (note: Note): Observable&lt;any&gt; {
        return this.http.put(notesUrl, note, httpOptions).pipe(
          tap(_ =&gt; this.log(`updated note id=${note.id}`)),
          catchError(this.handleError&lt;any&gt;('updateNote'))
        );
      }
      addNote (note: Note): Observable&lt;Note&gt; {
        return this.http.post&lt;Note&gt;(notesUrl, note, httpOptions).pipe(
          tap((note: Note) =&gt; this.log(`added note w/ id=${note.id}`)),
          catchError(this.handleError&lt;Note&gt;('addNote'))
        );
      }
      deleteNote (note: Note | number): Observable&lt;Note&gt; {
        const id = typeof note === 'number' ? note : note.id;
        const url = `${notesUrl}/${id}`;
        return this.http.delete&lt;Note&gt;(url, httpOptions).pipe(
          tap(_ =&gt; this.log(`deleted note id=${id}`)),
          catchError(this.handleError&lt;Note&gt;('deleteNote'))
        );
      }
      searchNotes(
        term: string,
        refresh = false
      ): Observable&lt;Note[]&gt; {
        if (!term.trim()) { return of([]); }
        // const options = term ?
        // { params: new HttpParams().set('title', term) } : {}; // URL encoded search parameter
        const options = createHttpOptions(term, refresh);
        console.log(options)
        return this.http.get&lt;Note[]&gt;(notesUrl, options).pipe(
          tap(_ =&gt; this.log(`found notes matching "${term}"`)),
          // map((data: any) =&gt; {
          //   return data.results.map(entry =&gt; ({
          //       name: entry.name[0],
          //       version: entry.version[0],
          //       description: entry.description[0]
          //     } as NpmPackageInfo )
          //   );
          // }),
          catchError(this.handleError&lt;Note[]&gt;('searchNotes', []))
        );
        // return this.http.get&lt;Note[]&gt;(`${notesUrl}/?title=${term}`).pipe(...
      }

      // --------------------------------------
      private log(message: string) {
        this.messageService.add(`NoteService: ${message}`);
      }
      /**
        * Handle Http operation that failed. Let the app continue.
        * @param operation - name of the operation that failed
        * @param result - optional value to return as the observable result
        */
      private handleError&lt;T&gt; (operation = 'operation', result?: T) {
        return (error: any): Observable&lt;T&gt; =&gt; {
          // TODO: send the error to remote logging infrastructure
          console.error(error); // log to console instead
          // TODO: better job of transforming error for user consumption
          this.log(`${operation} failed: ${error.message}`);
          // Let the app keep running by returning an empty result.
          return of(result as T);
        };
      }
    }
  </code></pre></details>

  <details>
  <summary>note-search.component.ts</summary>
  <pre><code class="ts">
    import { Component, OnInit } from '@angular/core';
    import { Observable, Subject } from 'rxjs';
    import {
        debounceTime, distinctUntilChanged, switchMap
      } from 'rxjs/operators';
    import { Note } from '../note';
    import { NoteService /*,NpmPackageInfo*/ } from '../note.service';

    @Component({
      selector: 'app-note-search',
      template: `
        &lt;div id="search-component"&gt;
          &lt;h4&gt;Note Search&lt;/h4&gt;
          &lt;input #searchBox id="search-box" (input)="search(searchBox.value)" /&gt;
          &lt;input type="checkbox" id="refresh" [checked]="withRefresh" (click)="toggleRefresh()"&gt;
          &lt;label for="refresh"&gt;with refresh&lt;/label&gt;
          &lt;ul class="search-result"&gt;
            &lt;li *ngFor="let note of notes$ | async" &gt;
              &lt;a routerLink="/note/{{note.id}}"&gt;
                {{note.title}}
              &lt;/a&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
        &lt;/div&gt;
      `,
      styleUrls: ['./note-search.component.css']
    })
    export class NoteSearchComponent implements OnInit {
      withRefresh = false;
      // packages$: Observable&lt;NpmPackageInfo[]&gt;;
      notes$: Observable&lt;Note[]&gt;; // $ - as an Observable
      private searchTerms$ = new Subject&lt;string&gt;();
      constructor(private noteService: NoteService) { }
      ngOnInit(): void {
        this.notes$ = this.searchTerms$.pipe(
          // wait 300ms after each keystroke before considering the term
          debounceTime(300),
          // ignore new term if same as previous term
          distinctUntilChanged(),
          // switch to new search observable each time the term changes
          switchMap(
            (term: string) =&gt; this.noteService.searchNotes(term, this.withRefresh)
          ),
        );
      }
      // Push a search term into the observable stream.
      search(term: string): void {
        this.searchTerms$.next(term);
      }
      toggleRefresh() { this.withRefresh = ! this.withRefresh; }
    }
  </code></pre></details>

  <details>
  <summary>notes.component.ts</summary>
  <pre><code class="ts">
    import { Component, OnInit } from '@angular/core';
    import { Note } from '../note';
    // import { NOTES } from '../mock-notes';
    import { NoteService } from '../note.service';

    @Component({
      selector: 'app-notes',
      template: `
        &lt;h2&gt;My Notes&lt;/h2&gt;
        &lt;div&gt;
          &lt;label&gt;Note title:
            &lt;input #noteTitle (keyup.enter)="add(noteTitle.value); noteTitle.value=''" /&gt;
          &lt;/label&gt;
          &lt;!-- (click) passes input value to add() and then clears the input --&gt;
          &lt;button (click)="add(noteTitle.value); noteTitle.value=''"&gt;
            add
          &lt;/button&gt;
        &lt;/div&gt;

        &lt;ul class="notes"&gt;
          &lt;li *ngFor="let note of notes" &gt;
            &lt;!-- [class.selected]="note === selectedNote" --&gt;
            &lt;!-- (click)="onSelect(note)" --&gt;
            &lt;a routerLink="/note/{{note.id}}"&gt;
              &lt;span class="id"&gt;{{note.id}}&lt;/span&gt; {{note.title}}
            &lt;/a&gt;
            &lt;button class="delete" title="delete note"
              (click)="delete(note)"&gt;x&lt;/button&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
        &lt;!-- &lt;app-note-details [note]="selectedNote"&gt;&lt;/app-note-details&gt; --&gt;
      `,
      styleUrls: ['./notes.component.css']
    })
    export class NotesComponent implements OnInit {
      // note: Note = {
      //   id: 1,
      //   title: 'Note 1 title',
      //   content: 'this is content sample'
      // };
      // notes = NOTES;
      notes: Note[];
      // selectedNote: Note;
      constructor(private noteService: NoteService) {}
      ngOnInit() {
        this.getNotes();
      }
      // onSelect(note: Note): void {
      //   this.selectedNote = note;
      // }
      getNotes(): void {
        this.noteService.getNotes()
          .subscribe(notes =&gt; this.notes = notes);
      }
      add(title: string): void {
        title = title.trim();
        if (!title) { return; }
        this.noteService.addNote({ title } as Note)
          .subscribe(note =&gt; {
            this.notes.push(note);
          });
      }
      delete(note: Note): void {
        this.notes = this.notes.filter(h =&gt; h !== note);
        this.noteService.deleteNote(note).subscribe();
      }
    }
  </code></pre></details>

  <details>
  <summary>http-examples.component.ts</summary>
  <pre><code class="ts">
    import { Component, OnInit } from '@angular/core';
    import { Config, HttpExamplesService } from './http-examples.service';
    import { UploaderService } from './uploader.service';
    @Component({
      selector: 'app-http-examples',
      templateUrl: './http-examples.component.html',
      styles:[`
        textarea.error {
          width:50%;
          height:20em;
        }
      `],
      providers: [HttpExamplesService, UploaderService]
    })
    export class HttpExamplesComponent implements OnInit {
      error: any;
      headers: string[];
      config: Config;
      result_obj: Object;
      contents: string;
      configUrl = 'assets/config.json';
      textfileUrl = 'assets/textfile.txt';
      objectKeys = Object.keys;
      constructor(
        private httpExamplesService: HttpExamplesService,
        private uploaderService: UploaderService
      ) {}
      ngOnInit() { }
      clear() {
        this.error = undefined;
        this.headers = undefined;
        this.config = undefined;
        this.result_obj = undefined;
        this.contents = undefined;
      }
      showConfig() {
        this.httpExamplesService.getData(this.configUrl)
          .subscribe(
            (data: Config) =&gt; {
              this.config = { ...data }; // typed response object container
              this.result_obj = this.config; // assign to local object
            }, // success path
            error =&gt; this.error = error // error path
          );
          // .subscribe((data: Config) =&gt; this.config = {
          //   apiUrl: data['heroesUrl'],
          //   textfile:  data['textfile']
          // });
      }
      showConfigResponse() {
        this.httpExamplesService.getConfigDataResponse(
          this.configUrl
        ).subscribe(resp =&gt; { // resp is of type `HttpResponse&lt;Config&gt;`
            // display its headers
            const keys = resp.headers.keys();
            this.headers = keys.map(key =&gt;
              `${key}: ${resp.headers.get(key)}`);
            // access the body directly, which is typed as `Config`.
            this.config = { ... resp.body }; // typed response object container
            this.result_obj = this.config; // assign here to local object
          });
      }
      onPicked(input: HTMLInputElement) {
        const file = input.files[0];
        if (file) {
          this.uploaderService.upload(file).subscribe(
            msg =&gt; {
              input.value = null;
              this.contents = msg;
            }
          );
        }
      }
      showTextfileContent() {
        this.httpExamplesService.getData(
          this.textfileUrl,
          {responseType: 'text'}
        ).subscribe(
          results =&gt; this.contents = results.toString(),
          error =&gt; this.error = error // error path
        );
        // .subscribe((data: Config) =&gt; this.config = {
        //   apiUrl: data['heroesUrl'],
        //   textfile:  data['textfile']
        // });
      }
      makeError() {
        this.httpExamplesService.makeIntentionalError()
          .subscribe(null, error =&gt; this.error = error );
      }
    }
  </code></pre></details>

  <details>
  <summary>http-examples.service.ts</summary>
  <pre><code class="ts">
    import { Injectable } from '@angular/core';
    import { HttpClient } from '@angular/common/http';
    import { HttpErrorResponse, HttpResponse } from '@angular/common/http';
    import { Observable, throwError } from 'rxjs';
    import { catchError, retry, tap } from 'rxjs/operators';
    import { MessageService } from '../message.service';

    export interface Config {
      apiUrl: string;
      textfile: string;
    }

    @Injectable()
    export class HttpExamplesService {
      constructor(
        private http: HttpClient,
        private messageService: MessageService
      ) { }
      getData(url: string, options_obj = {}) {
        return this.http.get(url, options_obj)
          .pipe(
            retry(3),
            tap(
              data =&gt; data,
              error =&gt; this.handleError(error)
            )
          );
        // Observable of Config
        // configUrl = 'assets/config.json';
        // return this.http.get&lt;Config&gt;(this.configUrl)
        // .pipe(
        //   retry(3), // retry a failed request up to 3 times
        //   catchError(this.handleError) // then handle the error
        // );
        // return this.http.get(this.configUrl);
      }
      getConfigDataResponse(url: string): Observable&lt;HttpResponse&lt;Config&gt;&gt; {
        return this.http.get&lt;Config&gt;(
          url,
          { observe: 'response' }
        );
      }
      makeIntentionalError() {
        return this.http.get('not/a/real/url')
          .pipe(
            tap(
              data =&gt; data,
              error =&gt; this.handleError(error)
            )
          );
      }
      private handleError(error: HttpErrorResponse) {
        if (error.error instanceof ErrorEvent) {
          // client-side or network error occurred
          this.log('An error occurred:'+ error.error.message);
        } else {
          // backend returned an unsuccessful response
          this.log(
            `Backend returned code ${error.status}`);
            // , body was: ${error.error}
        }
        // return an observable with a user-facing error message
        return throwError(
          'Something bad happened; please try again later.');
      };
      private log(data: string) {
        this.messageService.add(data);
      }
    }
  </code></pre></details>

  <details>
  <summary>uploader.service.ts</summary>
  <pre><code class="ts">
    import { Injectable } from '@angular/core';
    import {
      HttpClient, HttpEvent, HttpEventType, HttpProgressEvent,
      HttpRequest, HttpResponse, HttpErrorResponse
    } from '@angular/common/http';
    import { of } from 'rxjs';
    import { catchError, last, map, tap } from 'rxjs/operators';
    import { MessageService } from '../message.service';
    @Injectable()
    export class UploaderService {
      constructor(
        private http: HttpClient,
        private messenger: MessageService) {}
      // If uploading multiple files, change to:
      // upload(files: FileList) {
      //   const formData = new FormData();
      //   files.forEach(f =&gt; formData.append(f.name, f));
      //   new HttpRequest('POST', '/upload/file', formData, {reportProgress: true});
      //   ...
      // }
      upload(file: File) {
        if (!file) { return; }

        // COULD HAVE WRITTEN:
        // return this.http.post('/upload/file', file, {
        //   reportProgress: true,
        //   observe: 'events'
        // }).pipe(
        const req = new HttpRequest('POST', '/upload/file', file, {
          reportProgress: true
        });
        // The `HttpClient.request` API produces a raw event stream
        // which includes start (sent), progress, and response events.
        return this.http.request(req).pipe(
          map(event =&gt; this.getEventMessage(event, file)),
          tap(message =&gt; this.showProgress(message)),
          last(), // return last (completed) message to caller
          catchError(this.handleError(file))
        );
      }
      /** Return distinct message for sent, upload progress, & response events */
      private getEventMessage(event: HttpEvent&lt;any&gt;, file: File) {
        switch (event.type) {
          case HttpEventType.Sent:
            return `Uploading file "${file.name}" of size ${file.size}.`;
          case HttpEventType.UploadProgress:
            // Compute and show the % done:
            const percentDone = Math.round(100 * event.loaded / event.total);
            return `File "${file.name}" is ${percentDone}% uploaded.`;
          case HttpEventType.Response:
            return `File "${file.name}" was completely uploaded!`;
          default:
            return `File "${file.name}" surprising upload event: ${event.type}.`;
        }
      }
      /**
        * Returns a function that handles Http upload failures.
        * @param file - File object for file being uploaded
        *
        * When no `UploadInterceptor` and no server,
        * you'll end up here in the error handler.
        */
      private handleError(file: File) {
        const userMessage = `${file.name} upload failed.`;
        return (error: HttpErrorResponse) =&gt; {
          // TODO: send the error to remote logging infrastructure
          console.error(error); // log to console instead
          const message = (error.error instanceof Error) ?
            error.error.message :
            `server returned code ${error.status} with body "${error.error}"`;
          this.messenger.add(`${userMessage} ${message}`);
          // Let app keep running but indicate failure.
          return of(userMessage);
        };
      }
      private showProgress(message: string) {
        this.messenger.add(message);
      }
    }
  </code></pre></details>

  <details>
  <summary>auth-interceptor.ts | auth.service.ts</summary>
  <pre><code class="ts">
    import { Injectable } from '@angular/core';
    import {
      HttpEvent, HttpInterceptor, HttpHandler, HttpRequest
    } from '@angular/common/http';
    import { AuthService } from '../auth.service';
    @Injectable()
    export class AuthInterceptor implements HttpInterceptor {
      constructor(private auth: AuthService) {}
      intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler) {
        const authToken = this.auth.getAuthorizationToken();
        // // Verbose way: clone the request and replace the original headers
        // // with cloned headers, updated with the authorization
        // const authReq = req.clone({
        //   headers: req.headers.set('Authorization', authToken)
        // });
        // clone the request and set the new header in one step
        const authReq = req.clone({ setHeaders: { Authorization: authToken } });
        return next.handle(authReq); // send cloned request with header to the next handler
      }
    }

    // auth.service.ts
    import { Injectable } from '@angular/core';
    @Injectable()
    export class AuthService {
      getAuthorizationToken() {
        return 'some-auth-token';
      }
    }
  </code></pre></details>

  <details>
  <summary>caching-interceptor.ts | request-cache.service.ts</summary>
  <pre><code class="ts">
    import { Injectable } from '@angular/core';
    import {
      HttpEvent, HttpHeaders, HttpRequest, HttpResponse,
      HttpInterceptor, HttpHandler
    } from '@angular/common/http';
    import { Observable, of } from 'rxjs';
    import { startWith, tap } from 'rxjs/operators';
    import { RequestCache } from '../request-cache.service';

    import { searchUrl } from '../package-search/package-search.service';
    // searchUrl = 'https://npmsearch.com/query';

    // return cachable (e.g., search) response as observable,
    // also re-run search if has 'x-refresh' header that is true,
    // using response from next(),
    // returning an observable that emits the cached response first.
    // if not in cache or not cachable, pass request through to next()
    @Injectable()
    export class CachingInterceptor implements HttpInterceptor {
      constructor(private cache: RequestCache) {}
      intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler) {
        // continue if not cachable.
        if (!isCachable(req)) { return next.handle(req); }
        const cachedResponse = this.cache.get(req);
        // cache-then-refresh
        if (req.headers.get('x-refresh')) {
          const results$ = sendRequest(req, next, this.cache);
          return cachedResponse ?
            results$.pipe( startWith(cachedResponse) ) :
            results$;
        }
        // cache-or-fetch
        return cachedResponse ?
          of(cachedResponse) : sendRequest(req, next, this.cache);
      }
    }
    // Only GET requests and npm package search are cachable
    function isCachable(req: HttpRequest&lt;any&gt;) {
      return req.method === 'GET' && -1 &lt; req.url.indexOf(searchUrl);
    }
    // get server response observable by sending request to `next()`
    // adds the response to the cache on the way out
    function sendRequest(
      req: HttpRequest&lt;any&gt;,
      next: HttpHandler,
      cache: RequestCache
    ): Observable&lt;HttpEvent&lt;any&gt;&gt; {
      // No headers allowed in npm search request
      const noHeaderReq = req.clone({ headers: new HttpHeaders() });
      return next.handle(noHeaderReq).pipe(
        tap(event =&gt; {
          // There may be other events besides the response.
          if (event instanceof HttpResponse) {
            cache.put(req, event); // Update the cache.
          }
        })
      );
    }

    // request-cache.service.ts
    import { Injectable } from '@angular/core';
    import { HttpRequest, HttpResponse } from '@angular/common/http';
    import { MessageService } from './message.service';
    export interface RequestCacheEntry {
      url: string;
      response: HttpResponse&lt;any&gt;;
      lastRead: number;
    }
    export abstract class RequestCache {
      abstract get(req: HttpRequest&lt;any&gt;): HttpResponse&lt;any&gt; | undefined;
      abstract put(req: HttpRequest&lt;any&gt;, response: HttpResponse&lt;any&gt;): void
    }
    const maxAge = 30000; // maximum cache age (ms)
    @Injectable()
    export class RequestCacheWithMap implements RequestCache {
      cache = new Map&lt;string, RequestCacheEntry&gt;();
      constructor(private messenger: MessageService) { }
      get(req: HttpRequest&lt;any&gt;): HttpResponse&lt;any&gt; | undefined {
        const url = req.urlWithParams;
        const cached = this.cache.get(url);
        if (!cached) { return undefined; }
        const isExpired = cached.lastRead &lt; (Date.now() - maxAge);
        const expired = isExpired ? 'expired ' : '';
        this.messenger.add(`Found ${expired}cached response for "${url}".`);
        return isExpired ? undefined : cached.response;
      }
      put(req: HttpRequest&lt;any&gt;, response: HttpResponse&lt;any&gt;): void {
        const url = req.urlWithParams;
        this.messenger.add(`Caching response from "${url}".`);
        const entry = { url, response, lastRead: Date.now() };
        this.cache.set(url, entry);
        // remove expired cache entries
        const expired = Date.now() - maxAge;
        this.cache.forEach(entry =&gt; {
          if (entry.lastRead &lt; expired) {
            this.cache.delete(entry.url);
          }
        });
        this.messenger.add(`Request cache size: ${this.cache.size}.`);
      }
    }
  </code></pre></details>

  <details>
  <summary>ensure-https-interceptor.ts</summary>
  <pre><code class="ts">
    import { Injectable } from '@angular/core';
    import {
      HttpEvent, HttpInterceptor, HttpHandler, HttpRequest
    } from '@angular/common/http';
    import { Observable } from 'rxjs';
    @Injectable()
    export class EnsureHttpsInterceptor implements HttpInterceptor {
      intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
        // clone request and replace 'http://' with 'https://' at the same time
        const secureReq = req.clone({
          url: req.url.replace('http://', 'https://')
        });
        return next.handle(secureReq); // send cloned, "secure" request to the next handler
      }
    }
  </code></pre></details>

  <details>
  <summary>logging-interceptor.ts</summary>
  <pre><code class="ts">
    import { Injectable } from '@angular/core';
    import {
      HttpEvent, HttpInterceptor, HttpHandler,
      HttpRequest, HttpResponse
    } from '@angular/common/http';
    import { finalize, tap } from 'rxjs/operators';
    import { MessageService } from '../message.service';
    @Injectable()
    export class LoggingInterceptor implements HttpInterceptor {
      constructor(private messenger: MessageService) {}
      intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler) {
        const started = Date.now();
        let ok: string;
        // extend server response observable with logging
        return next.handle(req)
          .pipe(
            tap(
              // Succeeds when there is a response; ignore other events
              event =&gt; ok = event instanceof HttpResponse ? 'succeeded' : '',
              // Operation failed; error is an HttpErrorResponse
              error =&gt; ok = 'failed'
            ),
            // Log when response observable either completes or errors
            finalize(() =&gt; {
              const elapsed = Date.now() - started;
              const msg = `${req.method} "${req.urlWithParams}"
                  ${ok} in ${elapsed} ms.`;
              this.messenger.add(msg);
            })
          );
      }
    }
  </code></pre></details>

  <details>
  <summary>trim-name-interceptor.ts</summary>
  <pre><code class="ts">
    import { Injectable } from '@angular/core';
    import {
      HttpEvent, HttpInterceptor, HttpHandler, HttpRequest
    } from '@angular/common/http';
    import { Observable } from 'rxjs';
    @Injectable()
    export class TrimNameInterceptor implements HttpInterceptor {
      intercept(
        req: HttpRequest&lt;any&gt;,
        next: HttpHandler
      ): Observable&lt;HttpEvent&lt;any&gt;&gt; {
        const body = req.body;
        if (!body || !body.name ) { return next.handle(req); }
        // copy the body and trim whitespace from the name property
        const newBody = { ...body, name: body.name.trim() };
        // clone request and set its body
        const newReq = req.clone({ body: newBody });
        // send the cloned request to the next handler.
        return next.handle(newReq);
      }
    }
  </code></pre></details>

  <details>
  <summary>upload-interceptor.ts - simulate server replying to file upload request</summary>
  <pre><code class="ts">
    import { Injectable } from '@angular/core';
    import {
      HttpEvent, HttpInterceptor, HttpHandler,
      HttpRequest, HttpResponse,
      HttpEventType, HttpProgressEvent
    } from '@angular/common/http';
    import { Observable } from 'rxjs';
    @Injectable()
    export class UploadInterceptor implements HttpInterceptor {
      intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
        if (req.url.indexOf('/upload/file') === -1) {
          return next.handle(req);
        }
        const delay = 300; // TODO: inject delay?
        return createUploadEvents(delay);
      }
    }
    // simulation of upload event stream
    function createUploadEvents(delay: number) {
      // Simulate XHR behavior which would provide this information in a ProgressEvent
      const chunks = 5;
      const total = 12345678;
      const chunkSize = Math.ceil(total / chunks);
      return new Observable&lt;HttpEvent&lt;any&gt;&gt;(observer =&gt; {
        // notify the event stream that the request was sent.
        observer.next({type: HttpEventType.Sent});
        uploadLoop(0);
        function uploadLoop(loaded: number) {
          // N.B.: Cannot use setInterval or rxjs delay (which uses setInterval)
          // because e2e test won't complete. A zone thing?
          // Use setTimeout and tail recursion instead.
            setTimeout(() =&gt; {
              loaded += chunkSize;
              if (loaded &gt;= total) {
                const doneResponse = new HttpResponse({
                  status: 201, // OK but no body;
                });
                observer.next(doneResponse);
                observer.complete();
                return;
              }
              const progressEvent: HttpProgressEvent = {
                type: HttpEventType.UploadProgress,
                loaded,
                total
              };
              observer.next(progressEvent);
              uploadLoop(loaded);
            }, delay);
        }
      });
    }
  </code></pre></details>

  <details>
  <summary>HttpClient</summary>
  <pre><code class="ts">
    get(
      url: string,
      options: {
        headers?: HttpHeaders | { [header: string]: string | string[]; };
        observe?: HttpObserve;
        params?: HttpParams | { [param: string]: string | string[]; };
        reportProgress?: boolean;
        responseType?: "arraybuffer" | "blob" | "text" | "json";
        withCredentials?: boolean;
      } = {}
    ): Observable&lt;any&gt;

    post(
      url: string,
      body: any,
      options: { /* ...same */ } = {}
    ): Observable&lt;any&gt;

    put(
      url: string,
      body: any,
      options: { /* ...same */ } = {}
    ): Observable&lt;any&gt;

    patch(
      url: string,
      body: any,
      options: { /* ...same */ } = {}
    ): Observable&lt;any&gt;
    /*
    patchHero (id: number, heroName: string): Observable<{}> {
      const url = `${this.heroesUrl}/${id}`;   // PATCH api/heroes/42
      return this.httpClient.patch(url, {name: heroName}, httpOptions)
        .pipe(catchError(this.handleError('patchHero')));
    }
    */

    delete(
      url: string,
      options: { /* ...same */ } = {}
    ): Observable&lt;any&gt;

    request(
      method | req: string | HttpRequest&lt;any&gt;,
      url?: string,
      options: { body?: any; /* ...same */ } = {}
    ): Observable&lt;any&gt;
    /*
    searchHeroes(term: string): observable&lt;Hero[]&gt;{
      const params = new HttpParams({fromString: 'name=term'});
      return this.httpClient.request(
        'GET',
        this.heroesUrl,
        {responseType:'json', params}
      );
    }
    */

    options(
      url: string,
      options: { /* ...same */ } = {}
    ): Observable&lt;any&gt;

    head(
      url: string,
      options: { /* ...same */ } = {}
    ): Observable&lt;any&gt;

    jsonp&lt;T&gt;(
      url: string,
      callbackParam: string
    ): Observable&lt;T&gt;
    /*
    requestJsonp(url, callback = 'callback') {
      return this.httpClient.jsonp(this.heroesURL, callback);
    }
    */
  </code></pre></details>

  <details>
  <summary>HttpParams, class is immutable - all mutation operations return a new instance</summary>
  <pre><code class="ts">
    //constructor(options: HttpParamsOptions = {} as HttpParamsOptions)

    // whether the body has one or more values for the given parameter name
    has(param: string): boolean
    // first value for the given parameter name, or null if its not present
    get(param: string): string | null
    // all values for the given parameter name, or null if its not present
    getAll(param: string): string[] | null
    // all the parameter names for this body
    keys(): string[]
    // construct a new body with an appended value for the given parameter name
    append(param: string, value: string): HttpParams
    // construct a new body with a new value for the given parameter name
    set(param: string, value: string): HttpParams
    // construct a new body with either the given value for the given parameter removed,
    // if a value is given, or all values for the given parameter removed if not
    delete(param: string, value?: string): HttpParams
    // serialize the body to an encoded string,
    // where key-value pairs (separated by =) are separated by &s
    toString(): string
  </code></pre></details>

  <details>
  <summary>HttpHeaders</summary>
  <pre><code class="ts">
    // constructor(headers?: string | { [name: string]: string | string[]; })

    // checks for existence of a header by a given name
    has(name: string): boolean
    // returns the first header value that matches a given name
    get(name: string): string | null
    // returns the names of the headers
    keys(): string[]
    // returns a list of header values for a given header name
    getAll(name: string): string[] | null
    // appends a new header value to the existing set of header values
    append(name: string, value: string | string[]): HttpHeaders
    // sets a header value for a given name
    // value is replaced with the given value if the header name already exists
    set(name: string, value: string | string[]): HttpHeaders
    // deletes all header values for a given name
    delete(name: string, value?: string | string[]): HttpHeaders
  </code></pre></details>

  <details>
  <summary>HttpResponseBase, HttpResponse and HttpHeaderResponse</summary>
  <pre><code class="ts">
    /*
    constructor(
      init: {
        headers?: HttpHeaders;
        status?: number;
        statusText?: string;
        url?: string;
      },
      defaultStatus: number = 200,
      defaultStatusText: string = 'OK'
    )
    */
    headers: HttpHeaders
    status: number
    statusText: string
    url: string | null
    ok: boolean
    type: HttpEventType.Response | HttpEventType.ResponseHeader

    // HttpResponse
    /*
    constructor(
      init: {
        body?: T;
        headers?: HttpHeaders;
        status?: number;
        statusText?: string;
        url?: string;
      } = {}
    )
    */
    body: T | null
    type: HttpEventType.Response
    clone(
      update: {
        body?: any;
        headers?: HttpHeaders;
        status?: number;
        statusText?: string;
        url?: string;
      } = {}
    ): HttpResponse&lt;any&gt;
    // then, inherited from common/http/HttpResponseBase...

    // HttpHeaderResponse
    /*
    constructor(
      init: {
        headers?: HttpHeaders;
        status?: number;
        statusText?: string;
        url?: string;
      } = {}
    )
    */
    type: HttpEventType.ResponseHeader
    // copy this HttpHeaderResponse, overriding its contents with the given parameter hash
    clone(
      update: {
        headers?: HttpHeaders;
        status?: number;
        statusText?: string;
        url?: string;
      } = {}
    ): HttpHeaderResponse
    // then, inherited from common/http/HttpResponseBase...
  </code></pre></details>



<h2 id="routing">Routing</h2>

  <ul>
    <li>add a base-element to the index.html as the first child in the head-tag: <code>&lt;base href="/"&gt;</code> or if unavailable:
      <ul>
        <li>provide the router with an appropriate [APP_BASE_HREF][] value</li>
        <li>use root URLs for all web resources: CSS, images, scripts, and template HTML files</li>
      </ul>
    </li>
    <li>Angular Router (@angular/router) is an optional service that presents a particular component view for a given URL</li>
    <li>keep routing deinitions as separate module for large apps</li>
    <li>order of the routes in the configuration matters and this is by design, first-match wins strategy when matching routes, more specific routes should be placed above less specific routes, routes with a static path are listed first, followed by an empty path route, that matches the default route, then wildcard</li>
    <li><strong>Routes</strong> - represents router configuration
      <ul>
        <li>path - string that uses the route matcher DSL</li>
        <li>pathMatch - string that specifies the matching strategy Options are "prefix" (default) and "full"</li>
        <li>matcher - defines a custom strategy for path matching and supersedes "path" and "pathMatch"</li>
        <li>component - component type</li>
        <li>redirectTo - url fragment which will replace the current matched segment, <u>query parameters and the fragment</u>:
          <ul>
            <li>absolute redirects (begins with a slash (/)) - from the redirectTo in the route config</li>
            <li>relative redirects - from the source URL</li>
          </ul>
        </li>
        <li>outlet - name of the outlet the component should be placed into</li>
        <li>canActivate - array of DI tokens used to look up CanActivate handlers</li>
        <li>canActivateChild - is an array of DI tokens used to look up CanActivateChild handlers</li>
        <li>canDeactivate - array of DI tokens used to look up CanDeactivate handlers</li>
        <li>canLoad - array of DI tokens used to look up CanLoad handlers</li>
        <li>data - additional data provided to the component via ActivatedRoute</li>
        <li>resolve - map of DI tokens used to look up data resolvers</li>
        <li>runGuardsAndResolvers - defines when guards and resolvers will be run By default they run only when the matrix parameters of the route change Options include:
          <ul>
            <li>paramsChange (default) - run guards and resolvers when path or matrix params change, this mode ignores query param changes</li>
            <li>paramsOrQueryParamsChange - guards and resolvers will run when any parameters change, this includes path, matrix, and query params</li>
            <li>pathParamsChange - run guards and resolvers path or any path params change, this mode is useful if you want to ignore changes to all optional parameters such as query and matrix params</li>
            <li>pathParamsOrQueryParamsChange - same as pathParamsChange, but also rerun when any query param changes</li>
            <li>always - run guards and resolvers on every navigation</li>
            <li>(from: ActivatedRouteSnapshot, to: ActivatedRouteSnapshot) =&gt; boolean - Use a predicate
            function when none of the pre-configured modes fit the needs of the application An example
            might be when you need to ignore updates to a param such as <code>sortDirection</code>, but need to
            reload guards and resolvers when changing the <code>searchRoot</code> param</li>
          </ul>
        </li>
        <li>children - array of child route definitions</li>
        <li>loadChildren - reference to lazy loaded child routes</li>
      </ul>
    </li>
    <li>use empty <u>path</u> routes to group routes together without adding any additional path segments to the URL, users will still visit /admin and the AdminComponent still serves as the Routing Component containing child routes</li>
    <li>use the <strong>RouterModule.forRoot</strong> method in the root module, AppModule, to register top-level application routes and providers, for feature modules, call the <strong>RouterModule.forChild</strong> method to register additional routes (only give the router components and not providing again the services)</li>
    <li>enableTracing:true option in the object passed as the second argument to the RouterModule.forRoot() method - outputs each router event that took place during each navigation lifecycle to the browser console</li>
    <li>router builds a tree of ActivatedRoute objects that make up the current state of the router, route path and parameters are available through an injected router service called the <strong>ActivatedRoute</strong>
      <ul>
        <li>url - Observable of the route path(s), represented as an array of strings for each part of the route path</li>
        <li>data - Observable that contains the data object provided for the route, also contains any resolved values from the resolve guard</li>
        <li>paramMap - Observable that contains a map of the required and optional parameters specific to the route, supports retrieving single and multiple values from the same parameter
          <ul>
            <li>has(name) - returns true if the parameter name is in the map of parameters</li>
            <li>get(name) - returns the parameter name value (a string) if present, or null if the parameter name is not in the map, returns the first element if the parameter value is actually an array of values</li>
            <li>getAll(name) - returns a string array of the parameter name value if found, or an empty array if the parameter name value is not in the map, use getAll when a single parameter could have multiple values</li>
            <li>keys - returns a string array of all parameter names in the map</li>
          </ul>
        </li>
        <li>queryParamMap - Observable that contains a map of the query parameters available to all routes, supports retrieving single and multiple values from the query parameter</li>
        <li>fragment - Observable of the URL fragment available to all routes</li>
        <li>outlet - name of the RouterOutlet used to render the route, for an unnamed outlet, the outlet name is primary</li>
        <li>routeConfig - route configuration used for the route that contains the origin path</li>
        <li>parent - route parent ActivatedRoute when this route is a child route</li>
        <li>firstChild - contains the first ActivatedRoute in the list of this route child routes</li>
        <li>children - contains all the child routes activated under the current route</li>
      </ul>
    </li>
    <li>Router emits navigation events through the <strong>Router.events</strong> property
      <ul>
        <li>NavigationStart - navigation starts</li>
        <li>RouteConfigLoadStart - before the Router lazy loads a route configuration</li>
        <li>RouteConfigLoadEnd - after a route has been lazy loaded</li>
        <li>RoutesRecognized - Router parses the URL and the routes are recognized</li>
        <li>GuardsCheckStart - Router begins the Guards phase of routing</li>
        <li>ChildActivationStart - Router begins activating a route children</li>
        <li>ActivationStart - Router begins activating a route</li>
        <li>GuardsCheckEnd - Router finishes the Guards phase of routing successfully</li>
        <li>ResolveStart - Router begins the Resolve phase of routing</li>
        <li>ResolveEnd - Router finishes the Resolve phase of routing successfuly</li>
        <li>ChildActivationEnd - Router finishes activating a route children</li>
        <li>ActivationEnd - Router finishes activating a route</li>
        <li>NavigationEnd - navigation ends successfully</li>
        <li>NavigationCancel - navigation is canceled, due to a Route Guard returning false during navigation</li>
        <li>NavigationError - navigation fails due to an unexpected error</li>
        <li>Scroll - event that represents a scrolling event</li>
        <li><strong>logged to the console when the enableTracing option is enabled</strong></li>
      </ul>
    </li>
    <li>AppRoutingModule is last in module imports array, after all other app modules import</li>
    <li>ActivatedRoute observables are among exceptions that dont need unsubscription - Router destroys a routed component when it is no longer needed and the injected ActivatedRoute dies with it, feel free to unsubscribe anyway, harmless and never a bad practice</li>
    <li>use <i>paramMap/switchMap</i> handling of url params if you dont discard component by visiting another and just updating its parameters AND use <i>ActivatedRoute.snapshot.paramMap.get('id')</i> in other cases</li>
    <li><strong>guards</strong> - works as component middleware checker and transorfms navigation scenarios
      <ul>
        <li>guard could ask the user a question, save changes to the server, or fetch fresh data - asynchronous operations, return Observable&lt;boolean&gt; or a Promise&lt;boolean&gt; and the router will wait for the observable to resolve to true or false</li>
        <li>guard <i>might</i> return its boolean answer synchronously, but in many cases, cant produce such an answer</li>
        <li>returned value controls route: true, false (and ,if required ,navigates to other place) or urlTree (current navigation cancels and a new navigation is initiated to the UrlTree returned)</li>
        <li>interfaces:</li>
        <li><strong>CanActivate</strong> - mediate navigation <u>to a route</u></li>
        <li><strong>CanActivateChild</strong> - mediate navigation <u>to a child route</u>, runs before any child route is activated, protect child routes within the feature module</li>
        <li><strong>CanDeactivate</strong> - mediate navigation <u>away</u> from the current route</li>
        <li><strong>Resolve</strong> - to perform route data retrieval <u>before</u> route activation, delay rendering the routed component until all necessary data have been fetched, cames vs ngOnInit method</li>
        <li><strong>CanLoad</strong> - mediate navigation to a feature module loaded <u>asynchronously</u></li>
        <li>you can have multiple guards at every level of a routing hierarchy</li>
        <li>if any guard returns false, pending guards that have not completed will be canceled, and the entire navigation is canceled</li>
      </ul>
    </li>
    <li>component-less route (group routes under main one) makes it easier to guard child routes</li>
    <li>NavigationExtras - extra options used during navigation (<code>this.router.navigate(['/login'], navigationExtras)</code>)
      <ul>
        <li><strong>relativeTo</strong>?:ActivatedRoute|null - enables relative navigation from the current ActivatedRoute</li>
        <li><strong>queryParams</strong>?:Params|null - sets query parameters to the URL</li>
        <li><strong>queryParamsHandling</strong>?:QueryParamsHandling|null - config strategy to handle the query parameters for the next navigation</li>
        <li><strong>fragment</strong>?:string - sets the hash fragment for the URL</li>
        <li><strong>preserveFragment</strong>?:boolean - preserves the fragment for the next navigation</li>
        <li><strong>skipLocationChange</strong>?:boolean - navigates without pushing a new state into history</li>
        <li><strong>replaceUrl</strong>?:boolean - navigates while replacing the current state in history</li>
        <li><strong>state</strong>?:{[k:string]:any;} - state passed to any navigation, value will be accessible through the extras object returned from router.getCurrentNavigation() while a navigation is executing, once a navigation completes, this value will be written to history.state when the location.go or location.replaceState method is called before activating of this route, history.state will not pass an object equality test because the navigationId will be added to the state before being written, while history.state can accept any type of value, because the router adds the navigationId on each navigation, the state must always be an object</li>
        <li><strong>query parameters and fragments are also available through the ActivatedRoute service</strong>, like route parameters, query parameters and fragments are provided as an Observable, use AsyncPipe to feed them in template</li>
        <li>preserve params while navigating, in components !</li>
        <li>query params and fragment can also be preserved using a RouterLink with the queryParamsHandling and preserveFragment bindings respectively:
          <ul>
            <li><code>&lt;a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" queryParamsHandling="merge"&gt; link to user component &lt;/a&gt;</code></li>
          </ul>
        </li>
        <li>values of queryParams, fragment or queryParamsHandling might need to relax typing to also accept undefined and null</li>
      </ul>
    </li>
    <li><strong>RouterLink</strong> - link to specific routes,
      <ul>
        <li>first segment name can be prepended:</li>
        <li>/ - router will look up the route from the root of the app</li>
        <li>./ - or does not begin with a slash, the router will instead look in the children of the current activated route</li>
        <li>../ - router will go up one level</li>
        <li>directive always treats the provided input as a delta to the current url, if current url is /user/(box//aux:team), then the following link &lt;a [routerLink]="['/user/jim']"&gt;Jim&lt;/a&gt; will generate the link /user/(jim//aux:team)</li>
      </ul>
    </li>
    <li>after each successful navigation, the router looks in its configuration for an unloaded module that it can preload, whether it preloads a module, and which modules it preloads, depends upon the <strong>preload strategy</strong>
      <ul>
        <li>preloading strategies out of the box:
        <li>1 - no preloading (default), lazy loaded feature areas are still loaded on demand</li>
        <li>2 - preloading of all lazy loaded feature areas</li>
        <li>import <strong>PreloadAllModules</strong> token from the Angular router package and add it in second parameters object of RouterModule.forRoot method: { preloadingStrategy:PreloadAllModules,... }, this tells the Router preloader to immediately load all lazy loaded routes (routes with a loadChildren property)</li>
        <li>NoPreloading (default) - strategy that does not preload any modules</li>
        <li>CanLoad guard blocks preload, drop the canLoad() guard method and rely on the canActivate() guard alone to preload a module and guard against unauthorized access</li>
        <li>you can control what and how the router preloads with a custom preloading strategy, defining it in place of PreloadAllModules</li>
      </ul>
    </li>
    <li>observable provided to the Router must complete or the navigation will not continue</li>
  </ul>

  <pre><code class="ts">
    const routes: Routes = [
      { path: '', component: HomeComponent },
      { path: 'path/:routeParam', component: MyComponent },
      { path: 'staticPath', component: ... },
      { path: '**', component: ... },
      { path: 'oldPath', redirectTo: '/staticPath' },
      { path: ..., component: ..., data: { message: 'Custom' } }
    ];

    const crisisCenterRoutes: Routes = [{
      path: 'crisis-center',
      title: 'Crisis Center',
      component: CrisisCenterComponent,
      // display following in component outlet not in root
      children: [
        {
          path: '',
          component: CrisisListComponent,
          children: [
            ...
      ]}]
    }];

    this.router.navigate([
      '../',
      { id: crisisId, foo: 'foo' }
    ], { relativeTo: this.route });

    // --- lazy loading a standalone component
    export const ROUTES: Route[] = [
      {
        path: 'admin',
        loadComponent: () => import('./admin/panel.component').then(mod => mod.AdminPanelComponent)},
        // omit ".then" for "default" exports
        loadComponent: () => import('./admin/panel.component')},
        // ...
    ];
    // many routes at once, main application:
    export const ROUTES: Route[] = [
      {path: 'admin', loadChildren: () => import('./admin/routes').then(mod => mod.ADMIN_ROUTES)},
      // omit ".then" for "default" exports
      {path: 'admin', loadChildren: () => import('./admin/routes')},
      // ...
    ];
    // admin/routes.ts:
    export const ADMIN_ROUTES: Route[] = [
      {path: 'home', component: AdminHomeComponent},
      {path: 'users', component: AdminUsersComponent},
      // ...
    ];
    // lazy loading and default exports, main application:
    export const ROUTES: Route[] = [
      {path: 'admin', loadChildren: () => import('./admin/routes')},
      // ...
    ];
    // admin/routes.ts:
    export default [
      {path: 'home', component: AdminHomeComponent},
      {path: 'users', component: AdminUsersComponent},
      // ...
    ] as Route[];

    // --- specifying additional providers on a Route
    // allows this same scoping without the need for either lazy loading or NgModule
    export const ROUTES: Route[] = [
      {
        path: 'admin',
        providers: [
          AdminService,
          {provide: ADMIN_API_KEY, useValue: '12345'},
        ],
        children: [
          path: 'users', component: AdminUsersComponent,
          path: 'teams', component: AdminTeamsComponent,
        ],
      },
      // ... other application routes that don't
      //     have access to ADMIN_API_KEY or AdminService.
    ];
    // combine providers with loadChildren of additional routing configuration
    // same effect of lazy loading an NgModule with additional routes and route-level providers
    // configure the same providers/child routes as above, but behind a lazy loaded boundary:
    // main application:
    export const ROUTES: Route[] = {
      // Lazy-load the admin routes.
      {path: 'admin', loadChildren: () => import('./admin/routes').then(mod => mod.ADMIN_ROUTES)},
      // ... rest of the routes
    }
    // admin/routes.ts:
    export const ADMIN_ROUTES: Route[] = [{
      path: '',
      pathMatch: 'prefix',
      providers: [
        AdminService,
        {provide: ADMIN_API_KEY, useValue: 12345},
      ],
      children: [
        {path: 'users', component: AdminUsersCmp},
        {path: 'teams', component: AdminTeamsCmp},
      ],
    }];
  </code></pre>

  <h3>Router</h3>
  <pre><code class="ts">
    interface Route {
      // path to match against, default is "/" (the root path)
      path?: string
      // path-matching strategy
      // "prefix"(default) OR "full" - important when redirecting empty-path routes
      pathMatch?: 'prefix' | 'full'
      // URL-matching function as a custom strategy for path matching
      // supersedes "path" and "pathMatch"
      matcher?: UrlMatcher
      // component to instantiate when the path matches
      // can be empty if child routes specify components
      component?: Type&lt;any&gt;
      // URL to which to redirect when a the path matches
      // absolute if the URL begins with a slash (/),
      // otherwise relative to the path URL
      redirectTo?: string
      // RouterOutlet object where the component can be placed
      outlet?: string
      // developer-defined data provided to the component via ActivatedRoute
      data?: Data
      // map of DI tokens used to look up data resolvers
      resolve?: ResolveData
      // array of child Route objects that specifies a nested route configuration
      children?: Routes
      // lazy-loaded child routes
      loadChildren?: LoadChildren
      // defines when guards and resolvers will be run
      // by default, run only when the matrix parameters of the route change
      // paramsOrQueryParamsChange - run when query parameters change
      // always - run on every execution
      runGuardsAndResolvers?: RunGuardsAndResolvers
      // handlers tokens
      canActivate?: any[]
      canActivateChild?: any[]
      canDeactivate?: any[]
      canLoad?: any[]
    }

    router.resetConfig([
      { path: 'team/:id', component: TeamCmp, children: [
        { path: 'simple', component: SimpleCmp },
        { path: 'user/:name', component: UserCmp }
      ]}
    ]);

    // create /team/33/user/11
    router.createUrlTree(['/team', 33, 'user', 11]);
    // create /team/33;expand=true/user/11
    router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
    // you can collapse static segments like this
    // works only with the first passed-in value:
    router.createUrlTree(['/team/33/user', userId]);
    // If the first segment can contain slashes,
    // and you do not want the router to split it, you
    // can do the following:
    router.createUrlTree([{segmentPath: '/one/two'}]);
    // create /team/33/(user/11//right:chat)
    router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);
    // remove the right secondary node
    router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);
    // assuming the current url is `/team/33/user/11` and the route points to `user/11`
    // navigate to /team/33/user/11/details
    router.createUrlTree(['details'], {relativeTo: route});
    // navigate to /team/33/user/22
    router.createUrlTree(['../22'], {relativeTo: route});
    // navigate to /team/44/user/22
    router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});

    router.navigateByUrl("/team/33/user/11");
    // Navigate without updating the URL
    router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });

    router.navigate(['team', 33, 'user', 11], {relativeTo: route});
    // Navigate without updating the URL
    router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});
  </code></pre>

  <h3>Routes examples</h3>
  <pre><code class="ts">
    // Simple Configuration
    // for /team/11/user/bob
    // create the team component with the user component in it
    [{
      path: 'team/:id',
      component: Team,
      children: [{
        path: 'user/:name',
        component: User
      }]
    }]

    // Multiple Outlets
    // for /team/11(aux:chat/jim)
    // create the team component next to the chat component, placed into the aux outlet
    [{
      path: 'team/:id',
      component: Team
    }, {
      path: 'chat/:user',
      component: Chat
      outlet: 'aux'
    }]

    // Wild Cards
    [{
      path: '**',
      component: Sink
    }]

    // Redirects
    // for '/team/11/legacy/user/jim'
    // change the url to '/team/11/user/jim'
    // and then instantiate the team component with the user component in it.
    // if the redirectTo value starts with a '/', then it is an absolute redirect:
    // if we change the redirectTo to /user/:name, the result url will be '/user/jim'
    [{
      path: 'team/:id',
      component: Team,
      children: [{
        path: 'legacy/user/:name',
        redirectTo: 'user/:name'
      }, {
        path: 'user/:name',
        component: User
      }]
    }]

    // Empty Path
    // for team/11, instantiate the AllUsers component
    [{
      path: 'team/:id',
      component: Team,
      children: [{
        path: '',
        component: AllUsers
      }, {
        path: 'user/:name',
        component: User
      }]
    }]
    // for /team/11/user/jim
    // instantiate the wrapper component with the user component in it
    [{
      path: 'team/:id',
      component: Team,
      children: [{
        path: '',
        component: WrapperCmp,
        children: [{
          path: 'user/:name',
          component: User
        }]
      }]
    }]

    // Matching Strategy
    // change matching strategy to make sure that path covers the whole unconsumed url
    // even when navigating to '/main', the router will still apply the redirect
    [{
      path: '',
      pathMatch: 'prefix', //default
      redirectTo: 'main'
    }, {
      path: 'main',
      component: Main
    }]
    // if pathMatch: full is provided
    // router will apply the redirect if and only if navigating to '/'
    [{
      path: '',
      pathMatch: 'full',
      redirectTo: 'main'
    }, {
      path: 'main',
      component: Main
    }]

    // Componentless Routes
    // two components require some id parameter
    // for parent/10/(a//aux:b)
    // instantiate the main child and aux child components next to each other
    // router will also merge the params, data, and resolve of the componentless parent
    // into the params, data, and resolve of the children
    [{
      path: 'parent/:id',
      children: [
        { path: 'a', component: MainChild },
        { path: 'b', component: AuxChild, outlet: 'aux' }
      ]
    }]
    // also merges the 'params', 'data', and 'resolve'
    // of the componentless parent into the childrens
    // done because there is no component
    // that can inject the activated route of the componentless parent.
    // '/parent/10' will create the main child and aux components
    [{
      path: 'parent/:id',
      children: [
        { path: '', component: MainChild },
        { path: '', component: AuxChild, outlet: 'aux' }
      ]
    }]

    // Lazy Loading
    // fetch an NgModule associated with 'team'
    // extract the set of routes defined in that NgModule
    // transparently add those routes to the main configuration
    // using an ES dynamic import() expression
    [{
      path: 'lazy',
      loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),
      // omit ".then" for "default" exports
      loadChildren: () => import('./lazy-route/lazy.module'),
    }];

    // --- REUSE COMMON LAYOUTS
    const routes: Routes = [{
        path: '',
        redirectTo: '/dashboard',
        pathMatch: 'full'
      },{
        path: '',
        component: MainLayoutComponent,
        children: [
          {
            path: 'dashboard',
            loadChildren: () => import(
              './dashboard/dashboard.module'
            ).then(mod => mod.DashboardModule)
          },{
            path: 'users',
            loadChildren: () => import(
              './users/users.module'
            ).then(mod => mod.UsersModule)
          },{
            path: 'account-settings',
            loadChildren: () => import(
              './account-settings/account-settings.module'
            ).then(mod => mod.AccountSettingsModule)
          },
        ]
      },{
        path: '',
        component: FooterOnlyLayoutComponent,
        children: [
          {
            path: 'login',
            loadChildren: () => import(
              './login/login.module'
            ).then(mod => mod.LoginModule)
          },{
            path: 'registration',
            loadChildren: () => import(
              './registration/registration.module'
            ).then(mod => mod.RegistrationModule)
          }
        ]
    }];
    // --- main-layout
    &lt;app-header&gt;&lt;/app-header&gt;
    &lt;div&gt;
      &lt;app-sidebar&gt;&lt;/app-sidebar&gt;
      &lt;div class="content"&gt;
        &lt;router-outlet&gt;&lt;/router-outlet&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;app-footer&gt;&lt;/app-footer&gt;
    // --- footer-only-layout
    &lt;div class="content"&gt;
      &lt;router-outlet&gt;&lt;/router-outlet&gt;
    &lt;/div&gt;
    &lt;app-footer&gt;&lt;/app-footer&gt;
  </code></pre>

  <h3>RouterLink examples</h3>
  <pre><code class="html">
    &lt;a routerLink="/path"&gt;
    &lt;a [routerLink]="[ '/path', routeParam ]"&gt;
    &lt;a [routerLink]="[ '/path', { matrixParam: 'value' } ]"&gt;
    &lt;a [routerLink]="[ '/path' ]" [queryParams]="{ page: 1 }"&gt;
    &lt;a [routerLink]="[ '/path' ]" fragment="anchor"&gt;

    &lt;!-- /team/11/user/bob;details=true --&gt;
    &lt;a routerLink="['/team', teamId, 'user', userName, {details: true}]"&gt;&lt;/a&gt;
    &lt;a routerLink="['/team/11/user', userName, {details: true}]"&gt;&lt;/a&gt;

    &lt;!-- /user/bob#education?debug=true --&gt;
    &lt;a
      [routerLink]="['/user/bob']"
      [queryParams]="{debug: true}"
      fragment="education"
    &gt;&lt;/a&gt;

    &lt;!--
      preserve the current query params(?*=*&...) and fragment(#)
      queryParamsHandling:
        merge - merge the queryParams into the current queryParams
        preserve - preserve the current queryParams
        default/'' - use the queryParams only
    --&gt;
    &lt;a
      [routerLink]="['/user/bob']"
      queryParamsHandling='preserve'
      preserveFragment
    &gt;&lt;/a&gt;

    &lt;!--
      provide a state value
      to be persisted to the browser History.state property
      later the value can be read
      from the router through router.getCurrentNavigation:
      // Get NavigationStart events
      router.events.pipe(
        filter(e =&gt; e instanceof NavigationStart)
      ).subscribe(e =&gt; {
        const navigation = router.getCurrentNavigation();
        tracingService.trace({id: navigation.extras.state.tracingId});
      });
    --&gt;
    &lt;a
      [routerLink]="['/user/bob']"
      [state]="{tracingId: 123}"
    &gt;&lt;/a&gt;
  </code></pre>

  <h3>Guards examples</h3>
  <pre><code class="ts">
    @Injectable({ providedIn: 'root' })
    export class MyGuardWithDependency implements CanActivate {
      constructor(private loginService: LoginService) {}
      canActivate() {
        return this.loginService.isLoggedIn();
      }
    }
    const route = {
      path: 'somePath',
      canActivate: [MyGuardWithDependency]
    };
    // refactored to:
    const route = {
      path: 'admin',
      canActivate: [() => inject(LoginService).isLoggedIn()]
    };
    // function-based guard:
    export const authGuard: CanActivateFn {
      const loginService = inject(LoginService);
      const router = inject(Router);
      if (loginService.isLoggedIn) {
        return true;
      }
      return router.parseUrl('/login'); // redirect
    }

    // ---

    it('can run functional guards serially', fakeAsync(() => {
      function runSerially(guards: CanActivateFn[]|CanActivateChildFn[]): CanActivateFn|CanActivateChildFn {
        return (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {
          const injector = coreInject(EnvironmentInjector);
          const observables = guards.map(guard => {
            const guardResult = injector.runInContext(() => guard(route, state));
            return wrapIntoObservable(guardResult).pipe(first());
          });
          return concat(...observables).pipe(takeWhile(v => v === true), last());
        };
      }

      const guardDone: string[] = [];

      const guard1: CanActivateFn = () =>
          of(true).pipe(delay(100), tap(() => guardDone.push('guard1')));
      const guard2: CanActivateFn = () => of(true).pipe(tap(() => guardDone.push('guard2')));
      const guard3: CanActivateFn = () =>
          of(true).pipe(delay(50), tap(() => guardDone.push('guard3')));
      const guard4: CanActivateFn = () =>
          of(true).pipe(delay(200), tap(() => guardDone.push('guard4')));
      const router = TestBed.inject(Router);
      router.resetConfig([{
        path: '**',
        component: BlankCmp,
        canActivate: [runSerially([guard1, guard2, guard3, guard4])]
      }]);
      router.navigateByUrl('');
      tick(100);
      expect(guardDone).toEqual(['guard1', 'guard2']);
      tick(50);
      expect(guardDone).toEqual(['guard1', 'guard2', 'guard3']);
      tick(200);
      expect(guardDone).toEqual(['guard1', 'guard2', 'guard3', 'guard4']);
    }));
  </code></pre>

  <table><tbody>
    <tr>
      <th>
        Router Part
      </th>
      <th>
        Meaning
      </th>
    </tr>
    <tr>
      <td>
        <strong>Router</strong>
      </td>
      <td>
        Displays the application component for the active URL.
        Manages navigation from one component to the next.
      </td>
    </tr>
    <tr>
      <td>
        <strong>RouterModule</strong>
      </td>
      <td>
        A separate NgModule that provides the necessary service providers
        and directives for navigating through application views.
      </td>
    </tr>
    <tr>
      <td>
        <strong>Routes</strong>
      </td>
      <td>
        Defines an array of Routes, each mapping a URL path to a component.
      </td>
    </tr>
    <tr>
      <td>
        <strong>Route</strong>
      </td>
      <td>
        Defines how the router should navigate to a component based on a URL pattern.
        Most routes consist of a path and a component type.
      </td>
    </tr>
    <tr>
      <td>
        <strong>RouterOutlet</strong>
      </td>
      <td>
        The directive (<code>&lt;router-outlet&gt;</code>) that marks where the router displays a view.
      </td>
    </tr>
    <tr>
      <td>
        <strong>RouterLink</strong>
      </td>
      <td>
        The directive for binding a clickable HTML element to
        a route, clicking an element with a <code>routerLink</code> directive
        that is bound to a <i>string</i> or a <i>link parameters array</i> triggers a navigation.
      </td>
    </tr>
    <tr>
      <td>
        <strong>RouterLinkActive</strong>
      </td>
      <td>
        The directive for adding/removing classes from an HTML element when an associated
        <code>routerLink</code> contained on or inside the element becomes active/inactive.
      </td>
    </tr>
    <tr>
      <td>
        <strong>ActivatedRoute</strong>
      </td>
      <td>
        A service that is provided to each route component that contains route specific
        information such as route parameters, static data, resolve data, global query params, and the global fragment.
      </td>
    </tr>
    <tr>
      <td>
        <strong>RouterState</strong>
      </td>
      <td>
        The current state of the router including a tree of the currently activated
        routes together with convenience methods for traversing the route tree.
      </td>
    </tr>
    <tr>
      <td>
        <b><i>Link parameters array</i></b>
      </td>
      <td>
        An array that the router interprets as a routing instruction, you can bind that array to a <code>RouterLink</code> or pass the array as an argument to the <code>Router.navigate</code> method.
      </td>
    </tr>
    <tr>
      <td>
        <b><i>Routing component</i></b>
      </td>
      <td>
        An Angular component with a <code>RouterOutlet</code> that displays views based on router navigations.
      </td>
    </tr>
  </tbody></table>

  <img src="../images/routing-1.png"
  style="position:relative;width:75%;margin-left:10%;">
  <img src="../images/routing-2.png"
  style="position:relative;width:75%;margin-left:10%;">
  <img src="../images/routing-3.png"
  style="position:relative;width:75%;margin-left:10%;">



<h2 id="animations">Animations</h2>

  <ul>
    <li>built on CSS functionality, can animate any property that the browser considers animatable</li>
    <li>@angular/animations and @angular/platform-browser - main modules for animations</li>
    <li><strong>state(state_name, style_fn)</strong> - define different states to call at the end of each transition, takes two arguments: a unique name like open or closed and a style() function</li>
    <li><strong>style({style:prop,...})</strong> - define a set of styles to associate with a given state name</li>
    <li><strong>transition(direction_exp, animate_fn)</strong> - specify the changes that occur between one state and another over a period of timefunction accepts two arguments: expression that defines the direction between two transition states, and an animate() function, direction_exp: <strong>=></strong> - uniderictional, <strong>&lt;=></strong> - bidirectional</li>
    <li><strong>animate('duration|100|100ms|0.1s delay|* easing|curve')</strong> - define the length, delay, and easing of a transition, and to designate the style function for defining styles while transitions are taking place, also use to define the keyframes() function for multi-step animations, these definitions are placed in the second argument of the animate() function</li>
    <li>notes on using styles within state and transition functions:
      <ul>
        <li>use state() to define styles that are applied at <u>the end of each transition</u>, they persist after the animation has completed</li>
        <li>use transition() to define <u>intermediate styles</u>, which create the illusion of motion during the animation</li>
        <li>when animations are disabled, transition() styles can be skipped, but state() styles cant</li>
        <li>you can include <u>multiple state pairs</u> within the same transition() argument:
          transition( 'on => off, off => void' )</li>
      </ul>
    </li>
    <li><strong>trigger()</strong> - collects the states and transitions, and gives the animation a name, so that you can attach it to the triggering element in the HTML template, describes the property name to watch for changes, knows when to start and initiates the actions included in its definition: transitions,...</li>
    <li>for elements entering or leaving a page (inserted or removed from the DOM), you can make the animations conditional, use *ngIf with the animation trigger in the HTML template</li>
    <li><strong>keyframes([style(cssProp:val, offset:0|1),...])</strong> - allows a several style changes within a single timing segment, use within animate(), can include multiple style() calls within each keyframe(), uses array syntax</li>
    <li><strong>group()</strong> - runs multiple animation steps in parallel, group animation steps, rather than animated elements, applied to the same element in parallel, but run independently, animation continues only after all inner animation steps have completed, used within sequence() or transition()</li>
    <li><strong>query(el|selector, multi_bool)</strong> - to find one or more inner HTML elements entering or leaving the page within the current element, meeting certain CSS class criteria</li>
    <li><strong>sequence(style_OR_animate)</strong> - specifies a list of animation steps that are run sequentially, one by one</li>
    <li><strong>stagger(delay, animations)</strong> - use within an animation query() call to issue a timing gap after each queried item is animated, cascading delay to animations for multiple elements</li>
    <li><strong>animation(animate_OR_sequence [,{time:'2s',start:1,end:0}] )</strong> - produces a reusable animation that can be invoked from elsewhere, used together with useAnimation()</li>
    <li><strong>useAnimation(animation [,params:{time:'2s',start:1,end:0}])</strong> - activates a reusable animation, used with animation()</li>
    <li><strong>animateChild()</strong> - allows animations on child components to be run within the same timeframe as the parent, parent animation has priority and any child animations are blocked, for a child animation to run, the parent animation must query each of the elements containing child animations, and run them using this function, feature is designed to be used with query() and it will only work with animations that are assigned using the Angular animation library, CSS keyframes and transitions are not handled by this API</li>
    <li><strong>*</strong> or wildcard - matches any animation state, useful for defining transitions that apply regardless of the HTML element start or end state: open => * applies when the element state changes from open to anything else (and also: open=>closed, *=>closed, *=>*), allows to add new states without having to include separate transitions for each one</li>
    <li><u>transitions are matched in the order in which they are defined</u>, list the more specific transitions before * => *</li>
    <li><u>wildcard is a fallback value</u> that is used if the state being animated isnt declared within the trigger</li>
    <li>use the <strong>void</strong> state to configure transitions for an element that is entering or leaving a page
      <ul>
        <li><strong>* => void</strong> (alias is <i>:leave</i>)  - applies when the element leaves a view, regardless of what state it was in before it left</li>
        <li><strong>void => *</strong> (alias is <i>:enter</i>) - applies when the element enters a view, regardless of what state it assumes when entering</li>
        <li>wildcard state <u>* matches to any state, including void</u></li>
        <li><u>use *ngIf and *ngFor with :enter and :leave</u></li>
        <li><strong>:increment</strong> and <strong>:decrement</strong> - when a numeric value has increased or decreased in value</li>
      </ul>
    </li>
    <li>element entering or leaving a view is equivalent to being inserted or removed from the DOM</li>
    <li><strong>@.disabled</strong> - special animation control binding placed on an HTML element to disable animations on that element, and any nested elements, prevents all animations from rendering, animations can still be run:
      <ul>
        <li>parent animation can use the <u>query()</u> function to collect inner elements located in disabled areas of the HTML template and animate them</li>
        <li>subanimation can be queried by a parent and then later animated with the <u>animateChild()</u> function</li>
      </ul>
    </li>
    <li>disabling animations application-wide is useful during end-to-end (E2E) testing, <u>place the @.disabled host binding on the topmost Angular component: @HostBinding('@.disabled')</u></li>
    <li>animation event is passed back via $event, as <strong>@trigger.start</strong> and <strong>@trigger.done</strong>, where trigger is the name of the trigger being used in the HTML template</li>
    <li>Angular assumes a default unit of pixels, or px: 50 pixels as 50 is the same as saying '50px'</li>
    <li>wildcard * property value under style() for elements that have widths and heights that depend on their content and the screen size, value of that particular style property is computed at runtime and then plugged into the animation
      <ul>
        <li><code>transition('* => void', [ style({ height: '*' }), animate(250, style({ height: 0 }))</code></li>
      </ul>
    </li>
    <li>functions that control complex animation sequences
      <ul>
        <li>query()</li>
        <li>stagger()</li>
        <li>group()</li>
        <li>sequence()</li>
      </ul>
    </li>
    <li>to produce an <strong>animation sequence when switching between routes</strong>, you need to define nested animation sequences, start with the top-level component that hosts the view, and nest additional animations in the components that host the embedded views</li>
    <li>route animations:
      <ul>
        <li>@routeAnimations - attribute directive that contains data about active routes and their states, based on the data property that we set in the route configuration</li>
        <li>define a method that can detect when a view changes</li>
        <li>assign an animation state value to the animation trigger (@routeAnimation) based on the route configuration data property value</li>
        <li>wrap outlet (in app.component)<br>
          <code>
          &lt;div [@routeAnimations]="prepareRoute(outlet)" &gt;<br>
            &lt;router-outlet #outlet="outlet"&gt;&lt;/router-outlet&gt;<br>
          &lt;/div&gt;
          </code>
        </li>
        <li>define method (in app.component)<br>
          <code>
          prepareRoute(outlet: RouterOutlet) {<br>
          return outlet && outlet.activatedRouteData &&<br>
          outlet.activatedRouteData['animation']; }<br>
          </code>
        </li>

        <li>route animation links animations<br>
          <code>
            ...<br>
            { path: 'home', component: HomeComponent, <br>
            data: {animation: 'HomePage'} },<br>
            { path: 'about', component: AboutComponent, <br>
            data: {animation: 'AboutPage'}<br>
            ...
          </code>
        </li>

        <li>define animations (app.component)<br>
          <code>
          const slideInAnimation =<br>
          trigger('routeAnimations', [<br>
            transition('HomePage <=> AboutPage', [<br>
              style({ position: 'relative' }),<br>
              query(':enter, :leave', [...<br>
          </code>
          and use <br>
          <code>
          ...<br>
          animations: [ slideInAnimation ]<br>
          ...
          </code>
        </li>

        <li><u>data property names can be arbitrary</u>>, for example, the name <u>animation</u> used in the example is an arbitrary choice</li>
      </ul>
    </li>
    <li>style attributes must be in camelCase</li>
  </ul>

  <pre><code class="ts">
    // 1 - enable animations modules
    import { BrowserModule } from '@angular/platform-browser';
    import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
    // ...
    @NgModule({
      imports: [
        BrowserModule,
        BrowserAnimationsModule
      ],
      declarations: [ ],
      bootstrap: [ ]
    })
    export class AppModule { }

    // 2 - importing animation functions into component files
    import { Component, HostBinding } from '@angular/core';
    import {
      trigger,
      state,
      style,
      animate,
      transition,
      // ...
    } from '@angular/animations';

    // 3 - adding the animation metadata property
    @Component({
      selector: 'app-root',
      templateUrl: 'app.component.html',
      styleUrls: ['app.component.css'],
      animations: [
        // animation triggers go here
      ]
    })
  </code></pre>

  <h3>app/animations/animations.component.ts</h3>
  <pre><code class="ts">
    import {
      Component, OnInit, HostBinding, EventEmitter
    } from '@angular/core';
    import {
      state, style, trigger,
      animate, transition, group,
      query, stagger, keyframes,
      useAnimation,
      AnimationEvent
    } from '@angular/animations';
    import {
      transOnAnimation, transOffAnimation
    } from '../animations';
    import { NOTES } from '../notes/mock-notes';

    @Component({
      selector: 'app-animations',
      templateUrl: './animations.component.html',
      styleUrls: ['./animations.component.css'],
      animations: [

        trigger('openClose', [
          state('true', style({
            height: '8em',
            opacity: 1,
            backgroundColor: 'yellow'
          })),
          state('false', style({
            height: '4em',
            opacity: 0.5,
            backgroundColor: 'green'
          })),
          transition('false &lt;=> true', [
            animate('1s'
              // , keyframes ( [
              //   style({ opacity: 0.1, offset: 0.1 }),
              //   style({ opacity: 0.6, offset: 0.2 }),
              //   style({ opacity: 1,   offset: 0.5 }),
              //   style({ opacity: 0.2, offset: 0.7 })
              // ])
            )
          ]),
        ]),

        trigger('importedOpenClose', [
          transition('false => true', [
            useAnimation(transOnAnimation)
          ]),
          transition('true => false', [
            useAnimation(transOffAnimation, {
              params: {
                time: '.2s'
              }
            })
          ])
        ]),

        trigger('openClose2', [
          state('open2', style({
            height: '200px',
            // opacity: 1,
            backgroundColor: 'yellow'
          })),
          state('closed2', style({
            height: '100px',
            // opacity: 0.5,
            backgroundColor: 'green'
          })),
          transition('open2 => closed2', [
            animate('1s')
          ]),
          transition('closed2 => open2', [
            animate('0.5s')
          ]),

          transition('* => closed2', [
            animate('1s')
          ]),
          transition('* => open2', [
            animate('0.5s')
          ]),

          transition('open2 &lt;=> closed2', [
            animate('0.5s')
          ]),
          transition ('* => open2', [
            animate ('1s',
              style ({ opacity: '*' }),
            ),
          ]),
          transition('* => *', [
            animate('1s')
          ]),
        ]),

        trigger('enterLeaveTrigger', [
          transition(':enter', [
            style({ opacity: 0 }),
            animate('0.5s', style({ opacity: 1 })),
          ]),
          transition(':leave', [
            animate('0.5s', style({ opacity: 0 }))
          ])
        ]),

        trigger('shrinkOut', [
          state('in', style({ height: '*' })),
          transition('* => void', [
            style({ height: '*' }),
            animate(250, style({ height: 0 }))
          ])
        ]),

        trigger('kfSample', [
          state('inactive', style({ backgroundColor: 'blue' })),
          state('active', style({ backgroundColor: 'orange' })),
          transition('* => active', [
            animate('2s', keyframes([
              style({ backgroundColor: 'blue', offset: 0}),
              style({ backgroundColor: 'red', offset: 0.8}),
              style({ backgroundColor: 'orange', offset: 1.0})
            ])),
          ]),
          transition('* => inactive', [
            animate('2s', keyframes([
              style({ backgroundColor: 'orange', offset: 0}),
              style({ backgroundColor: 'red', offset: 0.2}),
              style({ backgroundColor: 'blue', offset: 1.0})
            ]))
          ]),
          transition('* => active', [
            animate('2s', keyframes([
              style({ backgroundColor: 'blue' }),
              style({ backgroundColor: 'red' }),
              style({ backgroundColor: 'orange' })
            ]))
          ]),
        ]),

        trigger('enterPageAnimations', [
          transition(':enter', [
            query('.note, form', [
              // invisible and use transform to move it out of position
              style({opacity: 0, transform: 'translateY(-100px)'}),
              // delay each animation by 30 milliseconds
              stagger(-30, [
                // animate each element on screen for 0.5 seconds
                // using a custom-defined easing curve,
                // simultaneously fading it in and un-transforming it
                animate(
                  '500ms cubic-bezier(0.35, 0, 0.25, 1)',
                  style({ opacity: 1, transform: 'none' })
                )
              ])
            ])
          ])
        ]),
        trigger('filterAnimation', [
          transition(':enter, * => 0, * => -1', []),
          transition(':increment', [
            query(':enter', [
              style({ opacity: 0, width: '0px' }),
              stagger(50, [
                animate(
                  '300ms ease-out',
                  style({ opacity: 1, width: '*' })
                ),
              ]),
            ], { optional: true })
          ]),
          transition(':decrement', [
            query(':leave', [
              stagger(50, [
                animate(
                  '300ms ease-out',
                  style({ opacity: 0, width: '0px' })
                ),
              ]),
            ]/*, { optional: true } */)
          ]),
        ]),

      ],
    })
    export class AnimationsComponent implements OnInit {
      constructor() { }
      isDisabled = false;
      toggleAnimations() { this.isDisabled = !this.isDisabled; }

      isOpen = false;
      toggle() { this.isOpen = !this.isOpen; }

      isImportedOpenClose = false;
      toggleImportedOpenClose() {
        this.isImportedOpenClose = !this.isImportedOpenClose;
      }

      isOpen2 = false;
      onAnimationEvent ( event: AnimationEvent ) {
        // // openClose is trigger name in this example
        // console.warn(`Animation Trigger: ${event.triggerName}`);
        // // phaseName is start or done
        // console.warn(`Phase: ${event.phaseName}`);
        // // in our example, totalTime is 1000 or 1 second
        // console.warn(`Total time: ${event.totalTime}`);
        // // in our example, fromState is either open or closed
        // console.warn(`From: ${event.fromState}`);
        // // in our example, toState either open or closed
        // console.warn(`To: ${event.toState}`);
        // // the HTML element itself, the button in this case
        // console.warn(`Element: ${event.element}`);
      }
      toggle2() { this.isOpen2 = !this.isOpen2; }

      notes_1 = NOTES.slice();
      removeNote(id: number) {
        this.notes_1 = this.notes_1.filter(note => note.id !== id);
      }

      // insert/remove
      enterLeave = false;
      toggleEnterLeave() { this.enterLeave = !this.enterLeave; }

      // keyframes
      kfStatus: 'active' | 'inactive' = 'inactive';
      kfToggle() {
        if (this.kfStatus === 'active') { this.kfStatus = 'inactive'; }
        else { this.kfStatus = 'active'; }
      }

      // animate multiple elements filter/stagger
      @HostBinding('@enterPageAnimations')
      ngOnInit() { this.notes_2_2 = NOTES; }
      public animatePage = true;
      notes_2_2 = [];
      noteTotal = -1;
      get notes_2_1() { return this.notes_2_2; }
      updateCriteria(criteria: string) {
        criteria = criteria ? criteria.trim() : '';
        this.notes_2_2 = NOTES.filter(
          note => note.title.toLowerCase().includes(criteria.toLowerCase())
        );
        const newTotal = this.notes_2_1.length;
        if (this.noteTotal !== newTotal) {
          this.noteTotal = newTotal;
        } else if (!criteria) {
          this.noteTotal = -1;
        }
      }

    }
  </code></pre>

  <h3>app/animations/animations.component.html</h3>
  <pre><code class="html">
    &lt;nav&gt;
      &lt;button (click)="toggleAnimations()"&gt;
        Toggle Animations
      &lt;/button&gt;
    &lt;/nav&gt;

    &lt;br&gt;
    &lt;nav&gt;
      &lt;button (click)="toggle()"&gt;
        Toggle Open/Closed
      &lt;/button&gt;
    &lt;/nav&gt;
    &lt;div [@.disabled]="isDisabled"&gt;
      &lt;div [@openClose]="isOpen ? true : false"
        class="open-close-container"&gt;
        &lt;p&gt;openClose box is {{ isOpen ? 'Open' : 'Closed' }}!&lt;/p&gt;
        &lt;p *ngIf="isOpen" &gt;additional content&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;br&gt;
    &lt;nav&gt;
      &lt;button (click)="toggleImportedOpenClose()"&gt;
        Toggle Imported Open/Closed
      &lt;/button&gt;
    &lt;/nav&gt;
    &lt;div [@.disabled]="isDisabled"&gt;
      &lt;div [@importedOpenClose]="isImportedOpenClose ? true : false"
        class="open-close-container"&gt;
        importedOpenClose box is {{ isImportedOpenClose ? 'Open' : 'Closed' }}!
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;br&gt;
    &lt;nav&gt;
      &lt;button (click)="toggle2()"&gt;Toggle Open/Close 2&lt;/button&gt;
    &lt;/nav&gt;
    &lt;div [@.disabled]="isDisabled"&gt;
      &lt;div [@openClose2]="isOpen2 ? 'open2' : 'closed2'"
        (@openClose2.start)="onAnimationEvent($event)"
        (@openClose2.done)="onAnimationEvent($event)"
        class="open-close-container"&gt;
        &lt;p&gt;openClose2 box is {{ isOpen2 ? 'Open' : 'Closed' }}!&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;br&gt;
    &lt;nav&gt;
      &lt;button (click)="toggleEnterLeave()"&gt;
        toggleEnterLeave()
      &lt;/button&gt;
    &lt;/nav&gt;
    &lt;div
      @enterLeaveTrigger
      *ngIf="enterLeave"
      class="insert-remove-container"
    &gt;
      &lt;p&gt;The box is inserted&lt;/p&gt;
    &lt;/div&gt;

    &lt;br&gt;
    &lt;nav&gt;
      &lt;button (click)="kfToggle()"&gt;kfToggle()&lt;/button&gt;
    &lt;/nav&gt;
    &lt;div [@kfSample]="kfStatus" class="kfBox"&gt;
      {{ kfStatus == 'active' ? 'Active' : 'Inactive' }}
    &lt;/div&gt;

    &lt;br&gt;
    &lt;div class="w_100pc"&gt;
      &lt;div class="w_32pc"&gt;
        &lt;ul class="notes"&gt;
          &lt;li
            *ngFor="let note of notes_1"
            [@shrinkOut]="'in'"
            (click)="removeNote(note.id)"&gt;
              &lt;div class="inner"&gt;
                &lt;span class="id"&gt;{{ note.id }}&lt;/span&gt;
                &lt;span&gt;{{ note.title }}&lt;/span&gt;
              &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class="w_32pc"&gt;
        &lt;ul
          class="notes"
          [@filterAnimation]="noteTotal"&gt;
            &lt;li *ngFor="let note of notes_2_2" class="note"&gt;
              &lt;div class="inner"&gt;
                &lt;span class="id"&gt;{{ note.id }}&lt;/span&gt;
                &lt;span&gt;{{ note.title }}&lt;/span&gt;
              &lt;/div&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;form&gt;
        &lt;input
          #criteria (input)="updateCriteria(criteria.value)"
          placeholder="Search Notes"
        /&gt;&lt;/form&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  </code></pre>

  <h3>app/animations.ts</h3>
  <pre><code class="ts">
    import {
      trigger, animateChild, group,
      transition, animate, style, query,
      animation
    } from '@angular/animations';

    // reusable animations
    export const transOnAnimation = animation([
      style({
        height: '{{ height }}',
        opacity: '{{ opacity }}',
        backgroundColor: '{{ backgroundColor }}'
      }), animate('{{ time }}') ],
      // defaults
      {
        params: {
          height: '6em',
          opacity: 1,
          backgroundColor: 'green',
          time: '2s'
        }
      }
    );
    export const transOffAnimation = animation([
      style({
        height: '3em',
        opacity: 0.2,
        backgroundColor: 'red'
      }), animate('{{ time }}') ],
      // defaults
      {
        params: {
          time: '.5s'
        }
      }
    );

    // routable animations
    export const slideInAnimation = trigger('routeAnimation', [
      transition('notes &lt;=> note, * &lt;=> dashboard', [
        // host view must use relative positioning
        style({ position: 'relative' }),
        // child views must use absolute positioning
        query(':enter, :leave', [
          style({
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            backgroundColor: 'white'
          })
        ]),
        query(':enter', [
          style({ left: '-100%'})
        ]),
        query(':leave', animateChild()),
        group([
          query(':leave', [
            animate(
              '300ms ease-out',
              style({ left: '100%', opacity: 0})
            )
          ]),
          query(':enter', [
            animate(
              '300ms ease-out',
              style({ left: '0%', opacity: 1})
            )
          ])
        ]),
        query(':enter', animateChild()),
      ])
    ]);
  </code></pre>

<br/>
<a href="../index.html" id="main_page_link">Back to Main Page</a>
<br/>
<br/>
<br/>

</body>
</html>
