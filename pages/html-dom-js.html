<!DOCTYPE html>
<html lang="en-US">
<head>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="HTML DOM, document, element, event tutorials and examples, Web Engineer Book">
  <meta name="keywords" content="html, dom, document, element, event, web components, api, tutorials, examples, cheat sheet, help, documentation, web, engineer, book">
  <meta name="author" content="Andrei, andreivinyl@gmail.com">

  <link rel="manifest" href="../manifest.webmanifest">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">

  <link rel="stylesheet" href="../js/highlight/styles/default.css">
  <link rel="stylesheet" href="../css/css.css">

  <script src="../js/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script src="../js/utils.js"></script>

  <title>HTML DOM, document, element, event tutorials and examples - Web Engineer Book</title>

</head>

<body onhashchange="hashFunction(event)">

<h2 id="nodes">DOM Nodes</h2>
  <ul>
    <li>HTML DOM (Document Object Model) - created when a web page is loaded, constructed as a tree of Objects</li>
    <li>everything in an HTML document is a node: entire document, every element, text is text node, comments are comment nodes</li>
    <li>*.nodeType constants definition
      <ul>
        <li>1 - ELEMENT_NODE - <strong>Element</strong> node such as p or div</li>
        <li>2 - ATTRIBUTE_NODE - an Attribute of an Element</li>
        <li>3 - TEXT_NODE - actual Text of Element or Attr</li>
        <li>4 - CDATA_SECTION_NODE - CDATASection</li>
        <li>7 - PROCESSING_INSTRUCTION_NODE - ProcessingInstruction of an XML doc (like &lt;?xml-stylesheet ... ?&gt;)</li>
        <li>8 - COMMENT_NODE - Comment node</li>
        <li>9 - DOCUMENT_NODE - Document node</li>
        <li>10 - DOCUMENT_TYPE_NODE - DocumentType node e.g. &lt;!DOCTYPE htm?&gt; for HTML5 document</li>
        <li>11 - DOCUMENT_FRAGMENT_NODE - DocumentFragment node</li>
      </ul>
    </li>
    <li>*.nodeName - uppercase tag name of an HTML element</li>
    <li>*.nodeValue
      <ul>
        <li>for element nodes is undefined</li>
        <li>for text nodes is the text itself</li>
        <li>for attribute nodes is the attribute value</li>
      </ul>
    </li>
    <li>common base node structure
      <ul>
        <li>html is the root node</li>
        <li>html has no parents</li>
        <li>html is the parent of head and body</li>
        <li>head is the first child of html</li>
        <li>body is the last child of htmle</li>
      </ul>
    </li>
  </ul>


<h2 id="document">document.*</h2>

  <ul>
    <li>when an HTML document is loaded into a web browser, it becomes a document object</li>
    <li>serves as an entry point into the web page's content, which is the DOM tree</li>
    <li>info
      <ul>
        <li>documentElement - Document Element of the document (the html element)</li>
        <li>defaultView - window object associated with a document, or null if none is available</li>
        <li>activeElement - currently focused element in the document</li>
        <li>scrollingElement - reference to the Element that scrolls the document, document.documentElement OR body element</li>
        <li>head - head element of the document</li>
        <li>doctype - Document Type Declaration associated with the document</li>
        <li>contentType - MIME type that the document is being rendered as, come from HTTP headers or other sources of MIME information, and might be affected by automatic type conversions performed by either the browser or extensions</li>
        <li>implementation - DOMImplementation object that handles this document</li>
        <li>inputEncoding - encoding, character set, used for the document</li>
        <li>characterSet - character encoding for the document</li>
        <li>domain - domain name of the server that loaded the document</li>
        <li>location - Location object, which contains information about the URL of the document and provides methods for changing that URL and loading another URL</li>
        <li>baseURI - absolute base URI of a document</li>
        <li>URL - full URL of the HTML document</li>
        <li>referrer - returns the URL of the document that loaded the current document</li>
        <li>readyState - returns the (loading) status of the document</li>
        <li>lastModified - date and time the document was last modified</li>
        <li>documentMode - mode used by the browser to render the document</li>
        <li>compatMode - whether the document is rendered in Quirks mode (BackCompat) or Standards mode (CSS1Compat)</li>
        <li>cookie - all name/value pairs of cookies in the document</li>
        <li>visibilityState - visibility of the document (Page Visibility API), that is in which context this element is now visible:
          <ul>
            <li>visible - content may be at least partially visible (foreground tab of a non-minimized window)</li>
            <li>hidden - page content is not visible to the user (user minimizes the window or switches to another tab, or the OS screen lock is active)</li>
            <li>prerender - page content is being prerendered and is not visible to the user (considered hidden for purposes of document.hidden), document may start in this state, but will never transition to it from another value. Note: browser support is optional</li>
            <li>unloaded - page is in the process of being unloaded from memory</li>
          </ul>
        </li>
        <li>hidden - whether the page is considered hidden or not</li>
        <li>fullscreenEnabled - Boolean value indicating whether the document can be viewed in fullscreen mode</li>
        <li>fullscreenElement - current element that is displayed in fullscreen mode</li>
      </ul>
    </li>
    <li>modify
      <ul>
        <li>title - sets or returns the title of the document</li>
        <li>body - sets or returns the document's body (body element)</li>
        <li>hasFocus() - boolean value indicating whether the document has focus</li>
        <li>documentURI - sets or returns the location of the document</li>
        <li>strictErrorChecking - sets or returns whether error-checking is enforced or not</li>
        <li>importNode(externalNode,bool_copyChildren) - returns a copy of a Node or DocumentFragment from another document, to insert in current document later, call appendChild() or insertBefore() with a node that is currently in the document tree</li>
        <li>adoptNode(externalNode) - returns extracted node from another document, adopted node and its subtree is removed from its original document (if any), and its ownerDocument is changed to the current document</li>
        <li>write(markup_str) - writes HTML expressions or JavaScript code to a document</li>
        <li>writeln(markup_str) - same as write(), but adds a newline character after each statement</li>
        <li>open() - opens an HTML output stream to collect output from document.write()</li>
        <li>close() - closes the output stream previously opened with document.open(), tells the browser to finish loading the page</li>
      </ul>
    </li>
    <li>elements
      <ul>
        <li>getElementById() - returns the element that has the ID attribute with the specified value</li>
        <li>getElementsByClassName() - returns a NodeList containing all elements with the specified class name</li>
        <li>getElementsByName() - returns a NodeList containing all elements with a specified name</li>
        <li>getElementsByTagName() - returns a NodeList containing all elements with the specified tag name</li>
        <li>querySelector() - returns the first element that matches a specified CSS selector(s) in the document (escape - \\:)</li>
        <li>querySelectorAll() - returns a static NodeList containing all elements that matches a specified CSS selector(s) in the document (escape - \\:)</li>
        <li>scripts - collection of script elements in the document</li>
        <li>currentScript - script element whose script is currently being processed</li>
        <li>images - collection of all img elements in the document</li>
        <li>links - collection of all a and area elements in the document that have a href attribute</li>
        <li>anchors - collection of all a elements in the document that have a name attribute</li>
        <li>forms - collection of all form elements in the document</li>
        <li>applets - collection of all applet elements in the document</li>
        <li>embeds - collection of all object elements the document</li>
        <li>plugins - collection of all embed elements the document</li>
        <li>createTreeWalker(rootNode[,whatToShowConst, nodeFilterObj, entityReferenceExpansion]) - new TreeWalker object</li>
        <li>createNodeIterator(rootNode[,whatToShowConst,nodeFilterObj]) -  new NodeIterator object</li>
        <li>createAttribute() - creates an attribute node</li>
        <li>createComment() - creates a Comment node with the specified text</li>
        <li>createDocumentFragment() - creates an empty DocumentFragment node</li>
        <li>createElement() - creates an Element node</li>
        <li>createTextNode() - creates a Text node</li>
        <li>renameNode() - renames the specified node</li>
      </ul>
    </li>
    <li>css styles
      <ul>
        <li>fonts - FontFaceSet interface: loading new fonts, checking the status of previously loaded fonts etc</li>
        <li>styleSheets - StyleSheetList of CSSStyleSheet objects, for stylesheets explicitly linked into or embedded in a document, styles properties:
          <ul>
            <li>title</li>
            <li>type</li>
            <li>href</li>
            <li>disabled</li>
            <li>media</li>
            <li>ownerNode</li>
            <li>parentStyleSheet</li>
          </ul>
        </li>
        <li>enableStyleSheetsForSet() - enables the style sheets matching the specified name in the current style sheet set, and disables all other style sheets (except those without a title, which are always enabled), value is live: directly changing the disabled attribute on style sheets will affect the value of this attribute</li>
        <li>styleSheetSets - live list of all of the currently-available style sheet sets</li>
        <li>selectedStyleSheetSet - indicates the name of the style sheet set that's currently in use, setting the value of this property is equivalent to calling document.enableStyleSheetsForSet() with the value of currentStyleSheetSet, then setting the value of lastStyleSheetSet to that value as well</li>
        <li>preferredStyleSheetSet - preferred style sheet set as set by the page author (or "")</li>
        <li>lastStyleSheetSet - last enabled style sheet set (or null), value changes whenever the document.selectedStyleSheetSet property is changed</li>
      </ul>
    </li>
    <li>design mode
      <ul>
        <li>designMode - sets or returns whether the document is editable or not (set to "on" or "off")</li>
        <li>execCommand(commandName,showDefaultUI,valueArgument) - invokes the specified clipboard operation on the element currently having focus, when an HTML document has been switched to designMode, its document object exposes an execCommand method to run commands that manipulate the current editable region, such as form inputs or contentEditable elements
          <ul>
            <li><strong>commandName:</strong></li>
            <li>backColor - changes the document background color, in styleWithCss mode, it affects the background color of the containing block instead, requires a color value string to be passed in as a value argument, IE uses this to set the text background color</li>
            <li>bold - toggles bold on/off for the selection or at the insertion point, IE uses the strong tag instead of b</li>
            <li>ClearAuthenticationCache - clears all authentication credentials from the cache</li>
            <li>contentReadOnly - makes the content document either read-only or editable, requires a boolean true/false as the value argument, unsupported in IE</li>
            <li>copy - copies the current selection to the clipboard, vary from one browser to another</li>
            <li>createLink - creates an hyperlink from the selection, but only if there is a selection, requires a URI string as a value argument for the hyperlink's href. The URI must contain at least a single character, which may be whitespace. (IE creates a link with a null value)</li>
            <li>cut - removes the current selection and copies it to the clipboard, varies between browsers</li>
            <li>decreaseFontSize - adds a small tag around the selection or at the insertion point, unsupported in IE</li>
            <li>defaultParagraphSeparator - changes the paragraph separator used when new paragraphs are created in editable text regions, see Differences in markup generation for more details</li>
            <li>delete - deletes the current selection</li>
            <li>enableAbsolutePositionEditor - enables or disables the grabber that allows absolutely-positioned elements to be moved around</li>
            <li>enableInlineTableEditing - enables or disables the table row/column insertion and deletion controls</li>
            <li>enableObjectResizing - enables or disables the resize handles on images, tables, and absolutely-positioned elements and other resizable objects</li>
            <li>fontName - changes the font name for the selection or at the insertion point, requires a font name string (like "Arial") as a value argument</li>
            <li>fontSize - changes the font size for the selection or at the insertion point, requires an integer from 1-7 as a value argument</li>
            <li>foreColor - changes a font color for the selection or at the insertion point, requires a hexidecimal color value string as a value argument</li>
            <li>formatBlock - adds an HTML block-level element around the line containing the current selection, replacing the block element containing the line if one exists, requires a tag-name string as a value argument. Virtually all block-level elements can be used. (IE supports only heading tags H1â€“H6, ADDRESS, and PRE, which must be wrapped in angle brackets, such as H1)</li>
            <li>forwardDelete - deletes the character ahead of the cursor's position, identical to hitting the Delete key on a Windows keyboard</li>
            <li>heading - adds a heading element around a selection or insertion point line, requires the tag-name string as a value argument (i.e. "H1", "H6"), unsupported in IE and Safari</li>
            <li>hiliteColor - changes the background color for the selection or at the insertion point. Requires a color value string as a value argument. useCSS must be true for this to function, unsupported in IE</li>
            <li>increaseFontSize - adds a big tag around the selection or at the insertion point, unsupported in IE</li>
            <li>indent - indents the line containing the selection or insertion point, in FF, if the selection spans multiple lines at different levels of indentation, only the least indented lines in the selection will be indented</li>
            <li>insertBrOnReturn - controls whether the Enter key inserts a br element, or splits the current block element into two, unsupported in IE</li>
            <li>insertHorizontalRule - inserts a hr element at the insertion point, or replaces the selection with it</li>
            <li>insertHTML - inserts an HTML string at the insertion point (deletes selection), requires a valid HTML string as a value argument, unsupported in IE</li>
            <li>insertImage - inserts an image at the insertion point (deletes selection), requires a URL string for the image's src as a value argument, same as createLink</li>
            <li>insertOrderedList - creates a numbered ordered list for the selection or at the insertion point</li>
            <li>insertUnorderedList - creates a bulleted unordered list for the selection or at the insertion point</li>
            <li>insertParagraph - inserts a paragraph around the selection or the current line, IE inserts a paragraph at the insertion point and deletes the selection</li>
            <li>insertText - inserts the given plain text at the insertion point (deletes selection)</li>
            <li>italic - toggles italics on/off for the selection or at the insertion point, IE uses the em element instead of i</li>
            <li>justifyCenter - centers the selection or insertion point</li>
            <li>justifyFull - justifies the selection or insertion point</li>
            <li>justifyLeft - justifies the selection or insertion point to the left</li>
            <li>justifyRight - right-justifies the selection or the insertion point</li>
            <li>outdent - outdents the line containing the selection or insertion point</li>
            <li>paste - pastes the clipboard contents at the insertion point (replaces current selection), disabled for web content</li>
            <li>redo - redoes the previous undo command</li>
            <li>removeFormat - removes all formatting from the current selection</li>
            <li>selectAll - selects all of the content of the editable region</li>
            <li>strikeThrough - toggles strikethrough on/off for the selection or at the insertion point</li>
            <li>subscript - toggles subscript on/off for the selection or at the insertion point</li>
            <li>superscript - toggles superscript on/off for the selection or at the insertion point</li>
            <li>underline - toggles underline on/off for the selection or at the insertion point</li>
            <li>undo - undoes the last executed command</li>
            <li>unlink - removes the anchor element from a selected hyperlink</li>
            <li>styleWithCSS - replaces the useCSS command, true - modifies/generates style attributes in markup, false - generates presentational elements</li>
            <li><strong>howDefaultUI</strong> - Boolean indicating whether the default user interface should be shown, not implemented in Mozilla</li>
            <li><strong>valueArgument</strong> - for commands which require an input argument, is a DOMString providing that information. For example, insertImage requires the URL of the image to insert. Specify null if no argument is needed</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>events
      <ul>
        <li>createEvent() - creates a new event</li>
        <li>addEventListener() - attaches an event handler to the document</li>
        <li>removeEventListener() - removes an event handler from the document (that has been attached with the addEventListener() method)</li>
      </ul>
    </li>
    <li>can hadle most events</li>
    <li>never use document.write() after the document is loaded, it will overwrite the document, loaded document automatically calls document.open, which will clear the document</li>
  </ul>

  <div id="document_tests" class="example h-20"></div>

  <script>
    var doc_tests = document.getElementById("document_tests");
    function doc_test() {
      var doc = document;
      doc_tests.innerHTML =
        "doc.documentElement: " + doc.documentElement + "<br>" +
        "doc.defaultView: " + doc.defaultView + "<br>" +
        "doc.activeElement: " + doc.activeElement + "<br>" +
        "doc.scrollingElement: " + doc.scrollingElement + "<br>" +
        "doc.head: " + doc.head + "<br>" +
        "doc.contentType: " + doc.contentType + "<br>" +
        "doc.implementation: " + doc.implementation + "<br>" +
        "doc.inputEncoding: " + doc.inputEncoding + "<br>" +
        "doc.characterSet: " + doc.characterSet + "<br>" +
        "doc.domain: " + doc.domain + "<br>" +
        "doc.location: " + doc.location + "<br>" +
        "doc.baseURI: " + doc.baseURI + "<br>" +
        "doc.URL: " + doc.URL + "<br>" +
        "doc.referrer: " + doc.referrer + "<br>" +
        "doc.readyState: " + doc.readyState + "<br>" +
        "doc.lastModified: " + doc.lastModified + "<br>" +
        "doc.documentMode: " + doc.documentMode + "<br>" +
        "doc.compatMode: " + doc.compatMode + "<br>" +
        "doc.cookie: " + doc.cookie + "<br>" +
        "doc.visibilityState: " + doc.visibilityState + "<br>" +
        "doc.hidden: " + doc.hidden + "<br>" +
        "doc.fullscreenEnabled: " + doc.fullscreenEnabled + "<br>" +
        "doc.fullscreenElement: " + doc.fullscreenElement + "<br>" +
        "doc.title: " + doc.title + "<br>" +
        "doc.body: " + doc.body + "<br>" +
        "doc.hasFocus(): " + doc.hasFocus() + "<br>" +
        "doc.documentURI: " + doc.documentURI + "<br>" +
        "doc.strictErrorChecking: " + doc.strictErrorChecking + "<br>" +
        "doc.scripts: " + doc.scripts + "<br>" +
        "doc.currentScript: " + doc.currentScript + "<br>" +
        "doc.images: " + doc.images + "<br>" +
        "doc.links: " + doc.links + "<br>" +
        "doc.anchors: " + doc.anchors + "<br>" +
        "doc.forms: " + doc.forms + "<br>" +
        "doc.applets: " + doc.applets + "<br>" +
        "doc.embeds: " + doc.embeds + "<br>" +
        "doc.plugins: " + doc.plugins + "<br>" +
        "doc.fonts: " + doc.fonts + "<br>" +
        "doc.styleSheets: " + doc.styleSheets + "<br>" +
        "doc.designMode: " + doc.designMode;
    }
    setInterval(doc_test,500);
  </script>

  <pre><code class="javascript">
    var doc_tests = document.getElementById("document_tests");
    function doc_test() {
      var doc = document;
      doc_tests.innerHTML =
        "doc.documentElement: " + doc.documentElement +
        "doc.defaultView: " + doc.defaultView +
        "doc.activeElement: " + doc.activeElement +
        "doc.scrollingElement: " + doc.scrollingElement +
        "doc.head: " + doc.head +
        "doc.contentType: " + doc.contentType +
        "doc.implementation: " + doc.implementation +
        "doc.inputEncoding: " + doc.inputEncoding +
        "doc.characterSet: " + doc.characterSet +
        "doc.domain: " + doc.domain +
        "doc.location: " + doc.location +
        "doc.baseURI: " + doc.baseURI +
        "doc.URL: " + doc.URL +
        "doc.referrer: " + doc.referrer +
        "doc.readyState: " + doc.readyState +
        "doc.lastModified: " + doc.lastModified +
        "doc.documentMode: " + doc.documentMode +
        "doc.compatMode: " + doc.compatMode +
        "doc.cookie: " + doc.cookie +
        "doc.visibilityState: " + doc.visibilityState +
        "doc.hidden: " + doc.hidden +
        "doc.fullscreenEnabled: " + doc.fullscreenEnabled +
        "doc.fullscreenElement: " + doc.fullscreenElement +
        "doc.title: " + doc.title +
        "doc.body: " + doc.body +
        "doc.hasFocus(): " + doc.hasFocus() +
        "doc.documentURI: " + doc.documentURI +
        "doc.strictErrorChecking: " + doc.strictErrorChecking +
        "doc.scripts: " + doc.scripts +
        "doc.currentScript: " + doc.currentScript +
        "doc.images: " + doc.images +
        "doc.links: " + doc.links +
        "doc.anchors: " + doc.anchors +
        "doc.forms: " + doc.forms +
        "doc.applets: " + doc.applets +
        "doc.embeds: " + doc.embeds +
        "doc.plugins: " + doc.plugins +
        "doc.fonts: " + doc.fonts +
        "doc.styleSheets: " + doc.styleSheets +
        "doc.designMode: " + doc.designMode;
    }
    setInterval(doc_test,500);
  </code></pre>

<h2 id="element">Element</h2>

  <ul>
    <li>properties and methods
    <ul>
      <li>INFO
        <ul>
          <li>tagName - tag name of an element</li>
          <li>nodeName - name of a node</li>
          <li>nodeType - node type of a node</li>
          <li>nodeValue - sets or returns the value of a node</li>
          <li>getBoundingClientRect() - size of an element and its position relative to the viewport</li>
          <li>ownerDocument - root element (document object) for an element</li>
          <li>offsetTop - vertical offset position of an element</li>
          <li>offsetLeft - horizontal offset position of an element</li>
          <li>offsetWidth - width of an element, including padding, border and scrollbar</li>
          <li>offsetHeight - height of an element, including padding, border and scrollbar</li>
          <li>offsetParent - offset container of an element</li>
          <li>clientTop - width of the top border of an element</li>
          <li>clientLeft - width of the left border of an element</li>
          <li>clientWidth - width of an element, including padding</li>
          <li>clientHeight - height of an element, including padding</li>
          <li>scrollWidth - entire width of an element, including padding (includes the height and width that is not viewable (because of overflow))</li>
          <li>scrollHeight - entire height of an element, including padding (includes the height and width that is not viewable (because of overflow))</li>
        </ul>
      </li>
      <li>ATTRIBUTEs
        <ul>
          <li>attributes - NamedNodeMap of an element's attributes</li>
          <li>hasAttribute(attr) - returns true if an element has the specified attribute, otherwise false</li>
          <li>hasAttributes() - returns true if an element has any attributes, otherwise false</li>
          <li>getAttributeNode() - returns the specified attribute node</li>
          <li>getAttribute(attr) - returns the specified attribute value of an element node</li>
          <li>setAttribute(attr, value) - sets or changes the specified attribute, to the specified value</li>
          <li>setAttributeNode(attr_node) - sets or changes the specified attribute node</li>
          <li>removeAttribute(attr) - removes a specified attribute from an element</li>
          <li>removeAttributeNode(attr_node) - removes a specified attribute node, and returns the removed node</li>
          <li>id - sets or returns the value of the id attribute of an element</li>
          <li>title - sets or returns the value of the title attribute of an element</li>
          <li>lang - sets or returns the value of the lang attribute of an element</li>
          <li>dir - sets or returns the value of the dir attribute of an element</li>
          <li>tabIndex - sets or returns the value of the tabindex attribute of an element</li>
        </ul>
      </li>
      <li>FIND
        <ul>
          <li>getElementById() - returns the element that has the ID attribute with the specified value</li>
          <li>getElementsByTagName(tag) - collection of all child elements with the specified tag name</li>
          <li>getElementsByClassName(class) - collection of all child elements with the specified class name</li>
          <li>querySelector(css_selector) - returns first child element that matches a specified CSS selector(s) of an element (escape - \\:)</li>
          <li>querySelectorAll(css_selector) - returns all child elements that matches a specified CSS selector(s) of an element(escape - \\:)</li>
          <li>nextSibling - next node at the same node tree level</li>
          <li>nextElementSibling - next element at the same node tree level</li>
          <li>previousSibling - previous node at the same node tree level</li>
          <li>previousElementSibling - previous element at the same node tree level</li>
          <li>accessKey - sets or returns the accesskey attribute of an element (access: [Alt]([Shift])+key, )</li>
          <li>createTreeWalker(rootNode[,whatToShowConst, nodeFilterObj, entityReferenceExpansion]) - returns a new TreeWalker object
            <ul>
              <li><strong>whatToShowConst:</strong></li>
              <li>NodeFilter.SHOW_ALL (-1)</li>
              <li>NodeFilter.SHOW_ELEMENT (1)</li>
              <li>NodeFilter.SHOW_ATTRIBUTE (2)</li>
              <li>NodeFilter.SHOW_TEXT (4)</li>
              <li>NodeFilter.SHOW_CDATA_SECTION (8)</li>
              <li>NodeFilter.SHOW_ENTITY_REFERENCE (16)</li>
              <li>NodeFilter.SHOW_ENTITY (32)</li>
              <li>NodeFilter.SHOW_PROCESSING_INSTRUCTION (64)</li>
              <li>NodeFilter.SHOW_COMMENT (128)</li>
              <li>NodeFilter.SHOW_DOCUMENT (256)</li>
              <li>NodeFilter.SHOW_DOCUMENT_TYPE (512)</li>
              <li>NodeFilter.SHOW_DOCUMENT_FRAGMENT (1024)</li>
              <li>NodeFilter.SHOW_NOTATION (2048)</li>
              <li><strong>nodeFilterObj</strong> - object with a acceptNode method, which is called by the TreeWalker to determine whether or not to accept a node that has passed the whatToShow check, returns:</li>
              <li>NodeFilter.FILTER_ACCEPT - node should be accepted</li>
              <li>NodeFilter.FILTER_REJECT - "skip this node and all its children"</li>
              <li>NodeFilter.FILTER_SKIP - "skip this node but not its children"</li>
              <li><strong>entityReferenceExpansion</strong> - Boolean flag indicating if when discarding an EntityReference its whole sub-tree must be discarded at the same time</li>
              <li><strong>TreeWalker properties:</strong> root, whatToShow, filter, expandEntityReferences, currentNode</li>
              <li><strong>TreeWalker methods:</strong> parentNode(), firstChild(), lastChild(), previousSibling(), nextSibling(), previousNode(), nextNode()</li>
            </ul>
          </li>
          <li>createNodeIterator(rootNode[,whatToShowConst,nodeFilterObj]) - returns a new NodeIterator object
            <ul>
              <li><strong>whatToShowConst:</strong> and <strong>nodeFilterObj</strong> same as in createTreeWalker</li>
              <li><strong>NodeIterator properties:</strong> root, whatToShow, filter, referenceNode, pointerBeforeReferenceNode</li>
              <li><strong>NodeIterator methods:</strong> previousNode(), nextNode()</li>
            </ul>
          </li>
          <li>NodeIterators - presents the nodes sequentially</li>
          <li>TreeWalkers - presents the nodes as a filtered tree</li>
          <li>NodeIterators and TreeWalkers are dynamic - the logical view changes to reflect changes made to the underlying document:  NodeIterators - attempt to maintain their location relative to a position in that sequence when the sequence's contents change, TreeWalkers -  maintain their location relative to their current node and remain attached to that node if it is moved to a new context</li>
        </ul>
      </li>
      <li>STYLE
        <ul>
          <li>style - sets or returns the value of the style attribute of an element</li>
          <li>classList - class name(s) of an element</li>
          <li>className - sets or returns the value of the class attribute of an element</li>
        </ul>
      </li>
      <li>CHECK
        <ul>
          <li>contains(child|grandchild|...) - returns true if a node is a descendant of a node, otherwise false</li>
          <li>isEqualNode(node) - checks if two elements are equal</li>
          <li>isSameNode(node) - checks if two elements are the same node</li>
          <li>isDefaultNamespace(ns) - returns true if a specified namespaceURI is the default, otherwise false</li>
          <li>compareDocumentPosition(node) - compares the document position of two elements with value
            <ul>
              <li>1 - no relationship, the two nodes do not belong to the same document</li>
              <li>2 - first node (p1) is positioned after the second node (p2)</li>
              <li>4 - first node (p1) is positioned before the second node (p2)</li>
              <li>8 - first node (p1) is positioned inside the second node (p2)</li>
              <li>16 - second node (p2) is positioned inside the first node (p1)</li>
              <li>32 - no relationship, or the two nodes are two attributes on the same element</li>
              <li>returnvalue 20 means that p2 is inside p1 (16) AND p1 is positioned before p2 (4)</li>
            </ul>
          </li>
          <li>isContentEditable - returns true if the content of an element is editable, otherwise false</li>
          <li>contentEditable - sets or returns whether the content of an element is editable or not</li>
        </ul>
      </li>
      <li>PARENT
        <ul>
          <li>parentNode - parent node of an element</li>
          <li>parentElement - parent element node of an element</li>
        </ul>
      </li>
      <li>CHILD
        <ul>
          <li>children - collection of an element's child element (excluding text and comment nodes)</li>
          <li>childNodes - collection of an element's child nodes (including text and comment nodes)</li>
          <li>childElementCount - number of child elements an element has</li>
          <li>appendChild(node) - adds a new child node, to an element, as the last child node</li>
          <li>removeChild(node) - removes a child node from an element</li>
          <li>replaceChild(newnode, oldnode) - replaces a child node in an element</li>
          <li>insertBefore() - inserts a new child node before a specified, existing, child node</li>
          <li>firstChild - first child node of an element</li>
          <li>lastChild - returns the last child node of an element</li>
          <li>firstElementChild - first child element of an element</li>
          <li>lastElementChild - last child element of an element</li>
          <li>hasChildNodes() - returns true if an element has any child nodes, otherwise false</li>
        </ul>
      </li>
      <li>EVENT
        <ul>
          <li>focus() - gives focus to an element</li>
          <li>blur() - removes focus from an element</li>
          <li>click() - simulates a mouse-click on an element</li>
          <li>addEventListener(event, fn [,useCapture]) - attaches an event handler to the specified element (useCapture - execute event in capturing OR in bubbling phase), if the event handler was attached two times, one with capturing and one bubbling, each must be removed separately</li>
          <li>removeEventListener() - removes an event handler that has been attached with the addEventListener() method</li>
        </ul>
      </li>
      <li>SCROLL
        <ul>
          <li>scrollIntoView( bool_alignToTop | {behavior:auto|instant|smooth, block:center|start|end|nearest, inline:nearest|start|center|end} ) - scrolls the specified element into the visible area of the browser window</li>
          <li>scrollTop - sets or returns the number of pixels an element's content is scrolled vertically</li>
          <li>scrollLeft - sets or returns the number of pixels an element's content is scrolled horizontally</li>
        </ul>
      </li>
      <li>FULLSCREEN
        <ul>
          <li>requestFullscreen() - shows an element in fullscreen mode</li>
          <li>exitFullscreen() - cancels an element in fullscreen mode</li>
          <li>see <strong>Event</strong> for example</li>
        </ul>
      </li>
      <li>innerHTML - sets or returns the content of an element</li>
      <li>innerText - sets or returns the text content of a node and its descendants</li>
      <li>insertAdjacentElement( beforebegin|afterbegin|beforeend|afterend, element ) - inserts a HTML element at the specified position relative to the current element</li>
      <li>insertAdjacentHTML( beforebegin|afterbegin|beforeend|afterend, txt ) - inserts a HTML formatted text at the specified position relative to the current element</li>
      <li>insertAdjacentText( beforebegin|afterbegin|beforeend|afterend, txt ) - inserts text into the specified position relative to the current element</li>
      <li>namespaceURI - namespace URI of an element</li>
      <li>textContent - sets or returns the textual content of a node and its descendants</li>
      <li>cloneNode() - clones an element</li>
      <li>toString() - converts an element to a string</li>
      <li>normalize() - removes empty Text nodes, and joins adjacent nodes in an element</li>
    </ul>
    </li>
  </ul>

<h3 id="e_info">INFO</h3>

  <div id="el_info_test" class="example h-25">Touch this area</div>

  <script>
    var el_it = document.getElementById("el_info_test");

    function el_info_test() {
      el_it.innerHTML =
        "el_it.tagName: " + el_it.tagName + "<br>" +
        "el_it.nodeName: " + el_it.nodeName + "<br>" +
        "el_it.nodeType: " + el_it.nodeType + "<br>" +
        "el_it.nodeValue: " + el_it.nodeValue + "<br>" +
        "el_it.offsetTop: " + el_it.offsetTop + "<br>" +
        "el_it.offsetLeft: " + el_it.offsetLeft + "<br>" +
        "el_it.offsetWidth: " + el_it.offsetWidth + "<br>" +
        "el_it.offsetHeight: " + el_it.offsetHeight + "<br>" +
        "el_it.offsetParent: " + el_it.offsetParent + "<br>" +
        "el_it.getBoundingClientRect: " + el_it.getBoundingClientRect + "<br>" +
        "el_it.ownerDocument: " + el_it.ownerDocument + "<br>" +
        "el_it.clientTop: " + el_it.clientTop + "<br>" +
        "el_it.clientLeft: " + el_it.clientLeft + "<br>" +
        "el_it.clientWidth: " + el_it.clientWidth + "<br>" +
        "el_it.clientHeight: " + el_it.clientHeight + "<br>" +
        "el_it.scrollWidth: " + el_it.scrollWidth + "<br>" +
        "el_it.scrollHeight: " + el_it.scrollHeight + "<br>" +
        "el_it.scrollTop: " + el_it.scrollTop + "<br>" +
        "el_it.scrollLeft: " + el_it.scrollLeft;
    }
    setInterval(el_info_test,500);

    // if an element is at the end of its scroll :
    // element.scrollHeight - element.scrollTop === element.clientHeight
    //
    // when the container does not scroll, but has overflowing children
    // these checks determine if the container can scroll :
    // window.getComputedStyle(element).overflowY === 'visible'
    // window.getComputedStyle(element).overflowY !== 'hidden'
  </script>

  <pre><code class="javascript">
    function el_info_test() {
      var el_it = document.getElementById("el_info_test");
      el_it.innerHTML =
        "el_it.tagName: " + el_it.tagName +
        "el_it.nodeName: " + el_it.nodeName +
        "el_it.nodeType: " + el_it.nodeType +
        "el_it.nodeValue: " + el_it.nodeValue +
        "el_it.offsetTop: " + el_it.offsetTop +
        "el_it.offsetLeft: " + el_it.offsetLeft +
        "el_it.offsetWidth: " + el_it.offsetWidth +
        "el_it.offsetHeight: " + el_it.offsetHeight +
        "el_it.offsetParent: " + el_it.offsetParent +
        "el_it.getBoundingClientRect: " + el_it.getBoundingClientRect +
        "el_it.ownerDocument: " + el_it.ownerDocument +
        "el_it.clientTop: " + el_it.clientTop +
        "el_it.clientLeft: " + el_it.clientLeft +
        "el_it.clientWidth: " + el_it.clientWidth +
        "el_it.clientHeight: " + el_it.clientHeight +
        "el_it.scrollWidth: " + el_it.scrollWidth +
        "el_it.scrollHeight: " + el_it.scrollHeight;
    }
    el_info_test();
  </code></pre>



<h3 id="e_attr">ATTRIBUTES</h3>

  <div
    id="el_attributes_test"
    class="example h-20"
    title="Attributes TEST"
    dir="ltr"
    lang="en"
    tabindex="132"
    onclick = "console.log('Dont click ME !')"
    onmouseover = "this.style.background = 'lightgray'"
    onmouseout = "this.style.background = 'white'"
    contenteditable
  >Tests DIV</div>

  <script>
    var el_at = document.getElementById("el_attributes_test");

    function el_attributes_test() {

      var attr_thing = document.createAttribute("data-thing-two");
      attr_thing.value = "thing value two";

      el_at.innerHTML = "Array.from(el_at.attributes).map((e)=>(e.name+':'+e.value)): <br>" +
        Array.from(el_at.attributes).map(
          (e)=>(e.name+" : "+e.value + " , specified: " + (e.specified ? "yes":"no") + "<br>")) +

        "el_at.attributes.getNamedItem('onclick').value: " +
        el_at.attributes.getNamedItem('onclick').value + "<br>" +

        "el_at.hasAttributes(): " + el_at.hasAttributes() + "<br>" +
        "el_at.hasAttribute('id'): " + el_at.hasAttribute('id') + "<br>" +
        "el_at.hasAttribute('data-thing'): " + el_at.hasAttribute('data-thing') + "<br>" +
        "el_at.getAttribute('id'): " + el_at.getAttribute('id') + "<br>" +
        "el_at.setAttribute('data-thing', 'thing value')" + "<br>" +
        "el_at.getAttribute('data-thing'): " + el_at.getAttribute('data-thing') + "<br>" +
        "el_at.setAttributeNode(attr_thing): " + el_at.setAttributeNode(attr_thing) + "<br>" +
        "el_at.getAttributeNode('data-thing-two'): " + el_at.getAttributeNode('data-thing-two') + "<br>" +
        "el_at.removeAttribute('data-thing')" + "<br>" +
        "el_at.hasAttribute('data-thing'): " + el_at.hasAttribute('data-thing') + "<br>" +
        "el_at.removeAttributeNode(attr_thing): " + el_at.removeAttributeNode(attr_thing).name + "<br>" + // .value
        "el_at.id: " + el_at.id + "<br>" +
        "el_at.title: " + el_at.title + "<br>" +
        "el_at.lang: " + el_at.lang + "<br>" +
        "el_at.dir: " + el_at.dir + "<br>" +
        "el_at.tabIndex: " + el_at.tabIndex + "<br>";
    }
    el_attributes_test();

    el_at.attributes.removeNamedItem("onmouseout");
    var onmouseout = document.createAttribute("onmouseout");
    onmouseout.value = "this.style.background = 'white'";
    el_at.attributes.setNamedItem(onmouseout);
  </script>

  <pre><code class="html">
    &lt;div
      id="el_attributes_test"
      class="example h-25"
      title="Attributes TEST"
      dir="ltr"
      lang="en"
      tabindex="132"
      onclick = "console.log('Dont click ME !')"
      onmouseover = "this.style.background = 'lightgray'"
      onmouseout = "this.style.background = 'white'"
      contenteditable
    &gt;Tests DIV&lt;/div&gt;
  </code></pre>

  <pre><code class="javascript">
    var el_at = document.getElementById("el_attributes_test");
    function el_attributes_test() {
      var attr_thing = document.createAttribute("data-thing-two");
      attr_thing.value = "thing value two";
      el_at.innerHTML = "Array.from(el_at.attributes).map((e)=>(e.name+':'+e.value)):" +
        Array.from(el_at.attributes).map(
          (e)=>(e.name+" : "+e.value + " , specified:" + (e.specified ? "yes":"no")) ) +
        "el_at.attributes.getNamedItem('onclick').value: " +
        el_at.attributes.getNamedItem('onclick').value +
        "el_at.hasAttributes(): " + el_at.hasAttributes() +
        "el_at.hasAttribute('id'): " + el_at.hasAttribute('id') +
        "el_at.hasAttribute('data-thing'): " + el_at.hasAttribute('data-thing') +
        "el_at.getAttribute('id'): " + el_at.getAttribute('id') +
        "el_at.setAttribute('data-thing', 'thing value')" +
        "el_at.getAttribute('data-thing'): " + el_at.getAttribute('data-thing') +
        "el_at.setAttributeNode(attr_thing): " + el_at.setAttributeNode(attr_thing) +
        "el_at.getAttributeNode('data-thing-two'): " + el_at.getAttributeNode('data-thing-two') +
        "el_at.removeAttribute('data-thing')" +
        "el_at.hasAttribute('data-thing'): " + el_at.hasAttribute('data-thing') +
        "el_at.removeAttributeNode(attr_thing): " +
          el_at.removeAttributeNode(attr_thing).name + // .value
        "el_at.id: " + el_at.id +
        "el_at.title: " + el_at.title +
        "el_at.lang: " + el_at.lang +
        "el_at.dir: " + el_at.dir +
        "el_at.tabIndex: " + el_at.tabIndex;
    }
    el_attributes_test();

    el_at.attributes.removeNamedItem("onmouseout");
    var onmouseout = document.createAttribute("onmouseout");
    onmouseout.value = "this.style.background = 'white'";
    el_at.attributes.setNamedItem(onmouseout);
  </code></pre>



<h3 id="e_find">FIND</h3>

  <div id="el_find_test" class="find_test_class example">initial value</div>

  <script>
    var el_find = document.getElementById("el_find_test");
    el_find.accessKey = "e";

    var d = document;
    el_find.innerHTML =
      "d.querySelector('#el_find_test').innerHTML: " +
      d.querySelector('#el_find_test').innerHTML + "<br>" +

      "d.querySelectorAll('h3')[1].innerHTML: " +
      d.querySelectorAll('h3')[1].innerHTML + "<br>" +

      "d.getElementsByTagName('h2')[1].id: " +
      d.getElementsByTagName('h2')[1].id + "<br>" +

      "d.getElementsByClassName('find_test_class')[0].id: " +
      d.getElementsByClassName('find_test_class')[0].id + "<br>" +

      "d.getElementById('document').nextSibling.nextSibling.tagName: " +
      d.getElementById('document').nextSibling.nextSibling.tagName + "<br>" +

      "d.getElementById('element').nextElementSibling.nextElementSibling.tagName: " +
      d.getElementById('element').nextElementSibling.nextElementSibling.tagName + "<br>" +

      "d.getElementById('el_find_test').previousSibling.previousSibling.tagName: " +
      d.getElementById('el_find_test').previousSibling.previousSibling.tagName + "<br>" +

      "d.getElementById('el_find_test').previousElementSibling.tagName: " +
      d.getElementById('el_find_test').previousElementSibling.tagName + "<br>" +

      "el_find.accessKey: " + el_find.accessKey + "<br>";

    var treeWalker = document.createTreeWalker(
      document.body,
      NodeFilter.SHOW_ELEMENT,
      {
        acceptNode: function(node) {
          if ( /^H2*$/.test(node.tagName) ) {
          // if ( ! /^\s*$/.test(node.data) ) {
            return NodeFilter.FILTER_ACCEPT;
          }
        }
      },
      false
    );
    // avoid changing DOM inside NodeFilter, make it here ...
    while(treeWalker.nextNode()) {
      el_find.innerHTML += "treeWalker.currentNode.id: " + treeWalker.currentNode.id + "<br>";
    }
    // OR
    // var node;
    // while ((node = iterator.nextNode())) { alert(node.data); }

    var nodeIterator = document.createNodeIterator(
        document.body,
        NodeFilter.SHOW_ELEMENT,
        function(node) {
            return node.nodeName === 'H3' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
        }
    );
    var currentNode;
    while (currentNode = nodeIterator.nextNode()) {
      el_find.innerHTML += "nodeIterator.nextNode() innerHTML: " + currentNode.innerHTML + "<br>";
    }
  </script>

  <pre><code class="javascript">
    var el_find = document.getElementById("el_find_test");
    el_find.accessKey = "e";

    var d = document;
    el_find.innerHTML =
      "d.querySelector('#el_find_test').innerHTML: " +
      d.querySelector('#el_find_test').innerHTML +
      d.querySelectorAll('h3')[1].innerHTML +
      d.getElementsByTagName('h2')[1].id +
      d.getElementsByClassName('find_test_class')[0].id +
      d.getElementById('document').nextSibling.nextSibling.tagName +
      d.getElementById('element').nextElementSibling.nextElementSibling.tagName +
      d.getElementById('el_find_test').previousSibling.previousSibling.tagName +
      d.getElementById('el_find_test').previousElementSibling.tagName
      "el_find.accessKey: " + el_find.accessKey;

    var treeWalker = document.createTreeWalker(
      document.body,
      NodeFilter.SHOW_ELEMENT,
      {
        acceptNode: function(node) {
          if ( /^H2*$/.test(node.tagName) ) {
          // if ( ! /^\s*$/.test(node.data) ) {
            return NodeFilter.FILTER_ACCEPT;
          }
        }
      },
      false
    );
    // avoid changing DOM inside NodeFilter, make it here ...
    while(treeWalker.nextNode()) {
      el_find.innerHTML += "treeWalker.currentNode.id: " + treeWalker.currentNode.id;
    }
    // OR
    // var node;
    // while ((node = iterator.nextNode())) { alert(node.data); }

    var nodeIterator = document.createNodeIterator(
        document.body,
        NodeFilter.SHOW_ELEMENT,
        function(node) {
            return node.nodeName === 'H3' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
        }
    );
    var currentNode;
    while (currentNode = nodeIterator.nextNode()) {
      el_find.innerHTML += "nodeIterator.nextNode() innerHTML: " + currentNode.innerHTML;
    }
  </code></pre>



<h3 id="e_style">STYLE</h3>

  <div id="el_style_test" class="example cls_tests t_class clazzz">initial value</div>

  <script>
    function el_style_test() {
      var el_style = document.getElementById("el_style_test");
      // var d = document;
      el_style.style.color = "fireBrick";
      el_style.innerHTML =
        "SET el_style.style.color = 'fireBrick'<br><br>" +
        "el_style.style.color: " + el_style.style.color + "<br>" +
        "el_style.classList: " + el_style.classList + "<br>" +
        "el_style.className: " + el_style.className + "<br>";
      el_style.className = "example";
      el_style.innerHTML +=
        "<br>SET el_style.className = 'example'<br><br>" +
        "el_style.classList: " + el_style.classList + "<br>" +
        "el_style.className: " + el_style.className + "<br>";
    }
    el_style_test();
  </script>

  <pre><code class="javascript">
    function el_style_test() {
      var el_style = document.getElementById("el_style_test");
      // var d = document;
      el_style.style.color = "fireBrick";
      el_style.innerHTML =
        "SET el_style.style.color = 'fireBrick'" +
        "el_style.style.color: " + el_style.style.color +
        "el_style.classList: " + el_style.classList +
        "el_style.className: " + el_style.className;
      el_style.className = "example";
      el_style.innerHTML +=
        "SET el_style.className = 'example'" +
        "el_style.classList: " + el_style.classList +
        "el_style.className: " + el_style.className;
    }
    el_style_test();
  </code></pre>



<h3 id="e_check">CHECK / PARENT / CHILD</h3>

  <div id="check_tests" class="example w-30 h-20">
    List 1:
    <ul id="myList1"><li>Water</li><li>Wine</li></ul>
    List 2:
    <ul id="myList2"><li>Coffee</li><li>Tea</li></ul>
    List 3:
    <ul id="myList3"><li>Water</li><li>Beer</li><li id="the_vodka">Vodka</li></ul>
    List 4:
    <ul id="myList4"><li>Vodka</li><li>Beer</li><li>Water</li></ul>
  </div>
  <div id="check_tests_result" class="example w-65 h-20"></div>

  <script>
    var check_tests = document.getElementById('check_tests');
    var check_tests_result = document.getElementById('check_tests_result');

    var list_1 = document.getElementById('myList1');
        list_1.contentEditable = true;
    var list_1_children = list_1.children;
    var list_2 = document.getElementById('myList2');
    var list_2_children = list_2.children;
    var list_3 = document.getElementById('myList3');
    var list_3_children = list_3.children;

    check_tests_result.innerHTML =
      "list_1.contains(list_1_children[0]): " + list_1.contains(list_1_children[0]) + "<br>" +
      "list_1.contains(list_2_children[0]): " + list_1.contains(list_2_children[0]) + "<br>" +

      "list_1_children[0].isEqualNode(list_3_children[0]): " +
      list_1_children[0].isEqualNode(list_3_children[0]) + "<br>" +
      "list_1_children[0].isEqualNode(list_2_children[0]): " +
      list_1_children[0].isEqualNode(list_2_children[0]) + "<br>" +

      "list_1_children[0].isSameNode(list_1_children[0]): " +
      list_1_children[0].isSameNode(list_1_children[0]) + "<br>" +
      "list_1_children[0].isSameNode(list_3_children[0]): " +
      list_1_children[0].isSameNode(list_3_children[0]) + "<br>" +

      "list_1.compareDocumentPosition(list_1_children[0]): " +
      list_1.compareDocumentPosition(list_1_children[0]) + "<br>" +
      "list_2.compareDocumentPosition(list_3): " +
      list_2.compareDocumentPosition(list_3) + "<br>" +

      "list_1.isContentEditable: " +
      list_1.isContentEditable + "<br>" +

      "list_3_children[1].parentNode.id: " +
      list_3_children[1].parentNode.id + "<br>" +

      "list_1_children[1].parentElement.id: " +
      list_1_children[1].parentElement.id + "<br>" +

      "list_1.childElementCount: " +
      list_1.childElementCount + "<br>" +

      "list_1.firstChild.innerHTML: " +
      list_1.firstChild.innerHTML + "<br>" +

      "list_2.lastChild.innerHTML: " +
      list_2.lastChild.innerHTML + "<br>" +

      "list_3.firstElementChild.innerHTML: " +
      list_3.firstElementChild.innerHTML + "<br>" +

      "list_3.lastElementChild.innerHTML: " +
      list_3.lastElementChild.innerHTML;

    // append new child to list_1
    var li_node = document.createElement("LI");
    var li_text = document.createTextNode("Juice");
    li_node.appendChild(li_text);
    list_1.appendChild(li_node);
    // then move it to the end of list_2 - appendChild
    var node = list_1.lastChild;
    list_2.appendChild(node);
    // then make it first in list_3 - insertBefore
    list_3.insertBefore(list_2.lastChild, list_3.childNodes[0])

    // remove and append same list item
    var item = document.getElementById("the_vodka");
    function removeLi() { item.parentNode.removeChild(item); }
    function appendLi() {
      list_3.appendChild(item);
    }

    // remove list item only by its ID
    // var item = document.getElementById("the_vodka");
    // item.parentNode.removeChild(item);

    // If the <ul> element has any child nodes, remove its first child node
    var list_4 = document.getElementById("myList4");
    if (list_4.hasChildNodes()) {
      // As long as <ul> has a child node, remove it
      while (list_4.hasChildNodes()) {
        list_4.removeChild(list_4.firstChild);
      }
    }

    // replace
    check_tests.replaceChild(
      document.createTextNode("No More List..."),
      check_tests.children[3]
    );

    // remove a span element from its parent and insert it to an h1 element in another document
    // var child = document.getElementById("mySpan");
    // function removeLi() { child.parentNode.removeChild(child);
    // function myFunction() {
    //   var frame = document.getElementsByTagName("IFRAME")[0]
    //   var h = frame.contentWindow.document.getElementsByTagName("H1")[0];
    //   var x = document.adoptNode(child);
    //   h.appendChild(x);
    // }

    // document.documentElement.isDefaultNamespace("http://www.w3.org/1999/xhtml")
  </script>

  <pre><code class="javascript">
    var check_tests = document.getElementById('check_tests');
    var check_tests_result = document.getElementById('check_tests_result');

    var list_1 = document.getElementById('myList1');
        list_1.contentEditable = true;
    var list_1_children = list_1.children;
    var list_2 = document.getElementById('myList2');
    var list_2_children = list_2.children;
    var list_3 = document.getElementById('myList3');
    var list_3_children = list_3.children;

    check_tests_result.innerHTML =
      list_1.contains(list_1_children[0]) +
      list_1.contains(list_2_children[0]) +
      list_1_children[0].isEqualNode(list_3_children[0]) +
      list_1_children[0].isEqualNode(list_2_children[0]) +
      list_1_children[0].isSameNode(list_1_children[0]) +
      list_1_children[0].isSameNode(list_3_children[0]) +
      list_1.compareDocumentPosition(list_1_children[0]) +
      list_2.compareDocumentPosition(list_3) +
      list_1.isContentEditable +
      list_3_children[1].parentNode.id +
      list_1_children[1].parentElement.id +
      list_1.childElementCount +
      list_1.firstChild.innerHTML +
      list_2.lastChild.innerHTML +
      list_3.firstElementChild.innerHTML +
      list_3.lastElementChild.innerHTML;

    // append new child to list_1
    var li_node = document.createElement("LI");
    var li_text = document.createTextNode("Juice");
    li_node.appendChild(li_text);
    list_1.appendChild(li_node);
    // then move it to the end of list_2 - appendChild
    var node = list_1.lastChild;
    list_2.appendChild(node);
    // then make it first in list_3 - insertBefore
    list_3.insertBefore(list_2.lastChild, list_3.childNodes[0])

    // remove and append same list item
    var item = document.getElementById("the_vodka");
    function removeLi() { item.parentNode.removeChild(item); }
    function appendLi() {
      list_3.appendChild(item);
    }

    // remove list item only by its ID
    // var item = document.getElementById("the_vodka");
    // item.parentNode.removeChild(item);

    // If the ul element has any child nodes, remove its first child node
    var list_4 = document.getElementById("myList4");
    if (list_4.hasChildNodes()) {
      // As long as ul has a child node, remove it
      while (list_4.hasChildNodes()) {
        list_4.removeChild(list_4.firstChild);
      }
    }

    // replace
    check_tests.replaceChild(
      document.createTextNode("No More List..."),
      check_tests.children[3]
    );

    // remove a span element from its parent and insert it to an h1 element in another document
    // var child = document.getElementById("mySpan");
    // function removeLi() { child.parentNode.removeChild(child);
    // function myFunction() {
    //   var frame = document.getElementsByTagName("IFRAME")[0]
    //   var h = frame.contentWindow.document.getElementsByTagName("H1")[0];
    //   var x = document.adoptNode(child);
    //   h.appendChild(x);
    // }

    // document.documentElement.isDefaultNamespace("http://www.w3.org/1999/xhtml")
  </code></pre>



<h3 id="e_event">EVENT</h3>

  <div class="example w-30 h-20">
    <button onclick="event_focus()">Focus</button><br>
    <button onclick="event_blur()">Blur</button><br>
    <button onclick="event_add()">addEventListener() for click event</button><br>
    <button onclick="event_click()">Simulate Click</button><br>
    <button onclick="event_remove()">removeEventListener()</button>
  </div>

  <div class="example w-65 h-20">
    <input id="el_event_test" class="tests-input" type="text"/>
  </div>

  <script>
    var el_event_test = document.getElementById("el_event_test");
    var the_clicks = 0;
    var clicks_inc = (e)=>{e.target.value = ++the_clicks};
    function event_focus(){
      el_event_test.focus();
    }
    function event_blur(){
      el_event_test.blur();
    }
    function event_click(){
      el_event_test.click();
    }
    function event_add(){
      el_event_test.addEventListener("click", clicks_inc);
      el_event_test.addEventListener("mousemove", clicks_inc);
      el_event_test.addEventListener("touchmove", clicks_inc);
    }
    function event_remove(){
      el_event_test.removeEventListener("click", clicks_inc);
      el_event_test.removeEventListener("mousemove", clicks_inc);
      el_event_test.removeEventListener("touchmove", clicks_inc);
    }
  </script>

  <pre><code class="javascript">
    var el_event_test = document.getElementById("el_event_test");
    var the_clicks = 0;
    var clicks_inc = (e) => {e.target.value = ++the_clicks};
    function event_focus () { el_event_test.focus(); }
    function event_blur () { el_event_test.blur(); }
    function event_click () { el_event_test.click(); }
    function event_add () {
      el_event_test.addEventListener("click", clicks_inc);
      el_event_test.addEventListener("mousemove", clicks_inc);
      el_event_test.addEventListener("touchmove", clicks_inc);
    }
    function event_remove () {
      el_event_test.removeEventListener("click", clicks_inc);
      el_event_test.removeEventListener("mousemove", clicks_inc);
      el_event_test.removeEventListener("touchmove", clicks_inc);
    }
  </code></pre>



<h3 id="e_scroll">SCROLL</h3>

  <div class="example w-50 h-10">
    <button onclick="scroll_into()" id="scroll_btn">scrollIntoView() this button</button><br>
    <button onclick="scroll_top()">scroll_top</button><br>
    <button onclick="scroll_left()">scroll_left</button>
  </div>

  <div id="scroll_test" class="example w-50 h-10">
    ------------------------------------------------------------------------------------------1------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------2------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------3------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------4------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------5------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------6------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------7------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------8------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------9------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------10------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------11------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------12------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------13------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------14------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------15------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------16------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------17------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------18------------------------------------------------------------------------------------------<br>
    ------------------------------------------------------------------------------------------19------------------------------------------------------------------------------------------<br>
  </div>

  <script>
    function scroll_into(){
      document.getElementById("scroll_btn").scrollIntoView();
    }
    function scroll_top(){
      document.getElementById("scroll_test").scrollTop += 10;
    }
    function scroll_left(){
      document.getElementById("scroll_test").scrollLeft += 10;
    }
  </script>

  <pre><code class="javascript">
    function scroll_into(){
      document.getElementById("scroll_btn").scrollIntoView();
    }
    function scroll_top(){
      document.getElementById("scroll_test").scrollTop += 10;
    }
    function scroll_left(){
      document.getElementById("scroll_test").scrollLeft += 10;
    }
  </code></pre>



<h2 id="collection">HTMLCollection</h2>

  <ul>
    <li>methods like the getElementsByTagName() returns an HTMLCollection, an array-like list of HTML elements</li>
    <li>properties
    <ul>
      <li>length - number of items in the collection</li>
    </ul>
    </li>
    <li>methods
    <ul>
      <li>item() - returns the specific node at the given zero-based index into the list, null if the index is out of range</li>
      <li>namedItem() - returns the specific node whose ID or, as a fallback, name matches the string specified by name, matching by name is only done as a last resort, only in HTML, and only if the referenced element supports the name attribute, returns null if no node exists by the given name</li>
    </ul>
    </li>
  </ul>

  <div id="coll_tests" class="example h-10"></div>

  <script>
    var ct = document.getElementById("coll_tests"),
        headers = document.getElementsByTagName("H2");

    ct.innerHTML = "header tags count: " + headers.length + "<br>IDs:<br>" +
    Array.from(headers).map((e)=>(e.id + "<br>")) +
    "headers.namedItem('collection').offsetTop: " +
    headers.namedItem("collection").offsetTop;
  </script>

  <pre><code class="javascript">
    var ct = document.getElementById("coll_tests"),
        headers = document.getElementsByTagName("H2");

    ct.innerHTML = "header tags count: " + headers.length + "IDs:" +
    Array.from(headers).map((e)=>(e.id)) +
    "headers.namedItem('collection').offsetTop: " +
    headers.namedItem("collection").offsetTop;
  </code></pre>



<h2 id="event">Event Object</h2>

  <ul>
    <li>Event handler can be assigned via <strong>attribute</strong> or <strong>JavaScript</strong></li>
    <li><strong>Event</strong> object is the parent of all event objects</li>
    <li>properties and methods
    <ul>
      <li>document.createEvent(type) - creates an event object
      <ul>
        <li>AnimationEvent</li>
        <li>ClipboardEvent</li>
        <li>DragEvent</li>
        <li>FocusEvent</li>
        <li>HashChangeEvent</li>
        <li>InputEvent</li>
        <li>KeyboardEvent</li>
        <li>MouseEvent</li>
        <li>PageTransitionEvent</li>
        <li>PopStateEvent</li>
        <li>ProgressEvent</li>
        <li>StorageEvent</li>
        <li>TouchEvent</li>
        <li>TransitionEvent</li>
        <li>UiEvent</li>
        <li>WheelEvent</li>
      </ul>
      </li>
      <li>type - type of the triggered event</li>
      <li>target - <strong>element that triggered</strong> the event</li>
      <li>currentTarget - element <strong>whose event listeners triggered</strong> the event</li>
      <li>cancelable [returns:true/false] - whether or not is a cancelable event</li>
      <li>preventDefault() - cancels the event if it is cancelable</li>
      <li>defaultPrevented [returns:true/false] - checks whether the preventDefault() method was called for the event</li>
      <li>stopImmediatePropagation() - prevents other listeners of the same event from being called, on the same element</li>
      <li>stopPropagation() - prevents propagation of the same event from being called, bubbling up to parent or capturing down to child</li>
      <li>bubbles [returns:true/false] - find out if a specific event can bubble or not through the DOM</li>
      <li>cancelBubble [setup:true/false] - prevents the event-flow from bubbling up to parent elements</li>
      <li>eventPhase [returns:0-NONE, 1-CAPTURING_PHASE, 2-AT_TARGET(evaluated), 3-BUBBLING_PHASE]</li>
      <li>isTrusted [returns:true/false] - true = invoked by the user, false = invoked by a script OR created with the createEvent</li>
      <li>composedPath() - returns an array of objects containing the elements in the event flow, in the correct execution order</li>
      <li>timeStamp - number of milliseconds since midnight of January 1, 1970, when the event occured</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li><strong>Media:</strong></li>
      <li>loadstart - when the browser starts looking for the specified audio/video. This is when the loading process starts</li>
      <li>durationchange - when the duration of the audio/video is changed (when is loaded, the duration will change from "NaN" to the actual)</li>
      <li>loadedmetadata - when meta data (duration, dimensions (video only) and text tracks) for the specified audio/video has been loaded</li>
      <li>loadeddata - when data for the current frame is loaded, but not enough data to play next frame of the specified audio/video</li>
      <li>progress - when the browser is downloading the specified audio/video</li>
      <li>canplay - when the browser can start playing the audio/video (when it has buffered enough to begin)</li>
      <li>canplaythrough - when the browser estimates it can play through the audio/video without having to stop for buffering</li>
      <li>play - when the audio/video has been started or is no longer paused</li>
      <li>playing - when the audio/video is playing after having been paused or stopped for buffering</li>
      <li>pause - when the audio/video is paused either by the user or programmatically</li>
      <li>ended - when the audio/video has reached the end</li>
      <li>seeking - when the user starts moving/skipping to a new position in the audio/video (opposite of the<li>seeked event, use currentTime property)</li>
      <li>seeked - when the user is finished moving/skipping to a new position in the audio/video</li>
      <li>ratechange - when the playing speed of the audio/video is changed (playbackRate property)</li>
      <li>volumechange - occurs each time the volume of a video/audio has been changed (volume property)</li>
      <li>timeupdate - when the playing position of an audio/video has changed (currentTime property)</li>
      <li>suspend - when the browser is intentionally not getting audio/video</li>
      <li>emptied - when something bad happens and the file is suddenly unavailable (like unexpectedly disconnects)</li>
      <li>stalled - when the browser is trying to get audio/video, but data is not available</li>
      <li>abort - when the loading of an audio/video is aborted, and not because of an error</li>
      <li>error - when an error occurs while loading an external file (img, input-type="image", object, link, and script)</li>
      <li><strong>Form:</strong></li>
      <li>change - when the content of a form element, the selection, or the checked state have changed (for input, select, and textarea)
        <ul>
          <li>for radiobuttons and checkboxes, occurs when the checked state has been changed</li>
          <li>similar to the oninput event, but works on select elements and oninput event occurs immediately after the value of an element has changed, while onchange occurs when the element loses focus, after the content has been changed</li>
        </ul>
      </li>
      <li>reset - when a form is reset</li>
      <li>submit - when a form is submitted</li>
      <li>invalid - when a submittable input element is invalid</li>
      <li>search - when a user presses the "ENTER" key or clicks the "x" button in an input element with type="search" (<strong>unsuported in IE and FF</strong>)</li>
      <li>toggle - when the user opens or closes the details element</li>
      <li><strong>Window, SSE, Worker:</strong></li>
      <li>open - when a connection with an event source is opened</li>
      <li>message - when a message is received through an event source</li>
      <li>messageerror - when a message cannot be deserialized</li>
      <li>online / offline - when the browser switches between online and offline mode, should be fired when window.navigator.onLine changes</li>
      <li><strong>Fullscreen:</strong></li>
      <li>fullscreenerror( mozfullscreenerror|webkitfullscreenerror|msfullscreenerror ) - when an element can not be viewed in fullscreen mode, even if it has been requested</li>
      <li>fullscreenchange - when an element is viewed in fullscreen mode</li>
    </ul>
    </li>
    <li>during the loading process of an audio/video, the following events occur, in this order
    <ul>
      <li>loadstart</li>
      <li>durationchange</li>
      <li>loadedmetadata</li>
      <li>loadeddata</li>
      <li>progress</li>
      <li>canplay</li>
      <li>canplaythrough</li>
    </ul>
    </li>
    <li>events that occurs when there is some kind of disturbance to the media loading process
    <ul>
      <li>abort</li>
      <li>emptied</li>
      <li>error</li>
      <li>stalled</li>
    </ul>
    </li>
  </ul>

  <div id="for_event_div" class="example h-20 w-30">click to see event info
    <div id="for_event_span" class="example h_5">click to see event info</div>
  </div>

  <div id="for_event_result" class="example h-20 w-65"></div>

  <script>
    var for_event_div = document.getElementById("for_event_div");
    for_event_div.addEventListener("click", clickTests);

    function clickTests(e) {
      e.preventDefault();
      e.stopImmediatePropagation();
      e.stopPropagation();
      e.cancelBubble = true;

      var for_event = document.getElementById("for_event");
      var for_event_result = document.getElementById("for_event_result");

      for_event_result.innerHTML = "e.type: " + e.type + "</br>" +
        "e.target.id: " + e.target.id + "</br>" +
        "e.currentTarget.id: " + e.currentTarget.id + "</br>" +
        "e.bubble: " + e.bubble + "</br>" +
        "e.cancelable: " + e.cancelable + "</br>" +
        "e.defaultPrevented: " + e.defaultPrevented + "</br>" +
        "e.eventPhase: " + e.eventPhase + " " +
        (
          !e.eventPhase ? "NONE"
          : ((e.eventPhase==1)?"CAPTURING_PHASE"
          :(e.eventPhase==2)?"AT_TARGET"
          :"BUBBLING_PHASE")
        ) + "</br>" +
        "e.isTrusted: " + e.isTrusted + "</br>" +
        "e.composedPath():</br>" + e.composedPath() + "</br>" +
        "e.timeStamp: " + e.timeStamp;
    }
  </script>

  <pre><code class="html">
    &lt;button onclick="eventTests(event)"&gt;Try it&lt;/button&gt;
  </code></pre>

  <pre><code class="javascript">
    var for_event_div = document.getElementById("for_event_div");
    for_event_div.addEventListener("click", clickTests);

    function clickTests(e) {
      e.preventDefault();
      e.stopImmediatePropagation();
      e.stopPropagation();
      e.cancelBubble = true;

      var for_event = document.getElementById("for_event");
      var for_event_result = document.getElementById("for_event_result");

      for_event_result.innerHTML = "e.type: " + e.type +
        "e.target.id: " + e.target.id +
        "e.currentTarget.id: " + e.currentTarget.id +
        "e.bubble: " + e.bubble +
        "e.cancelable: " + e.cancelable +
        "e.defaultPrevented: " + e.defaultPrevented +
        "e.eventPhase: " + e.eventPhase + " " +
        (
          !e.eventPhase ? "NONE"
          : ((e.eventPhase==1)?"CAPTURING_PHASE"
          :(e.eventPhase==2)?"AT_TARGET"
          :"BUBBLING_PHASE")
        ) +
        "e.isTrusted: " + e.isTrusted +
        "e.composedPath(): " + e.composedPath() +
        "e.timeStamp: " + e.timeStamp;

      // var x = document.createEvent("MouseEvent");
      // x.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
      // for_event.dispatchEvent(x);
    }
  </code></pre>

  <style>
    #event_tests_area * {
      display: block;
      position: relative;
      float:left;
    }
  </style>

  <div id="event_tests_area" class="example w-50 h-30">

    <h5>#img_ok</h5>
    <img id="img_ok" src="../images/colorpicker.gif"/>

    <h5>#img_nope</h5>
    <img id="img_nope" src="../images/color-picker.gif"/>

    <h5>#select_test</h5>
    <select id="select_test">
      <option value="Audi">Audi
      <option value="BMW">BMW
      <option value="Mercedes">Mercedes
      <option value="Volvo">Volvo
    </select>

    <h5>#audio_test</h5>
    <audio id="audio_test" controls>
      <source src="flappy/bg.mp3" type="audio/mpeg">
      Your browser does not support the audio element.
    </audio>

    <h5>#form_test</h5>
    <form id="form_test">
      <input id="event_input_test" type="number" min="3" max="7" required><br>
      <input type="reset"><br>
      <input type="submit">
    </form>

    <h5>fullscreen test</h5>
    <button onclick="openFullscreen();">openFullscreen</button><br>
    <button onclick="closeFullscreen();">closeFullscreen</button>

  </div>

  <div id="event_test_result" class="example w-50 h-30"></div>

  <script>
    var event_test_result = document.getElementById("event_test_result");
    var event_test_result_log = document.getElementById("event_test_result_log");

    var img_ok = document.getElementById("img_ok");
    var img_nope = document.getElementById("img_nope");
    var select_test = document.getElementById("select_test");
    var audio_test = document.getElementById("audio_test");
    var form_test = document.getElementById("form_test");
    var event_input_test = document.getElementById("event_input_test");

    img_nope.addEventListener("error", eventsTests);
    img_nope.addEventListener("load", eventsTests); // UiEvent
    img_nope.addEventListener("abort", eventsTests); // UiEvent

    select_test.addEventListener("change", eventsTests);

    audio_test.addEventListener("load", eventsTests); // UiEvent
    audio_test.addEventListener("abort", eventsTests); // UiEvent
    audio_test.addEventListener("loadstart", eventsTests);
    audio_test.addEventListener("canplaythrough", eventsTests);
    audio_test.addEventListener("canplay", eventsTests);
    audio_test.addEventListener("ended", eventsTests);
    audio_test.addEventListener("durationchange", eventsTests);
    audio_test.addEventListener("seeking", eventsTests);
    audio_test.addEventListener("seekend", eventsTests);
    audio_test.addEventListener("progress", eventsTests);
    audio_test.addEventListener("playing", eventsTests);
    audio_test.addEventListener("play", eventsTests);
    audio_test.addEventListener("pause", eventsTests);
    audio_test.addEventListener("loadedmetadata", eventsTests);
    audio_test.addEventListener("loadeddata", eventsTests);
    audio_test.addEventListener("volumechange", eventsTests);
    audio_test.addEventListener("timeupdate", eventsTests);
    audio_test.addEventListener("suspend", eventsTests);
    audio_test.addEventListener("stalled", eventsTests);

    form_test.addEventListener("reset", eventsTests);
    form_test.addEventListener("submit", eventsTests);

    event_input_test.addEventListener("invalid", eventsTests);

    function eventsTests(e) {
        event_test_result.innerHTML += e.target.id + " - " + e.type + "<br>";
        e.preventDefault();
    }

    // FULLSCREEN
    document.addEventListener("fullscreenchange",eventsTests);
    document.addEventListener("mozfullscreenchange",eventsTests);
    document.addEventListener("webkitfullscreenchange",eventsTests);
    document.addEventListener("msfullscreenchange",eventsTests);
    document.addEventListener("fullscreenerror",eventsTests);
    document.addEventListener("mozfullscreenerror",eventsTests);
    document.addEventListener("webkitfullscreenerror",eventsTests);
    document.addEventListener("msfullscreenerror",eventsTests);
    var doc = document.getElementById("event_tests_area"); // element you want displayed in fullscreen
    function openFullscreen() { // open fullscreen mode
      if (doc.requestFullscreen) {
        doc.requestFullscreen();
      } else if (doc.mozRequestFullScreen) { /* Firefox */
        doc.mozRequestFullScreen();
      } else if (doc.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
        doc.webkitRequestFullscreen();
      } else if (doc.msRequestFullscreen) { /* IE/Edge */
        doc.msRequestFullscreen();
      }
    }
    function closeFullscreen() { // close fullscreen mode
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }

    document.body.addEventListener("offline", eventsTests, false);
    document.body.addEventListener("online", eventsTests, false);
  </script>

  <pre><code class="javascript">
    var event_test_result = document.getElementById("event_test_result");

    var img_ok = document.getElementById("img_ok");
    var img_nope = document.getElementById("img_nope");
    var select_test = document.getElementById("select_test");
    var audio_test = document.getElementById("audio_test");
    var form_test = document.getElementById("form_test");
    var event_input_test = document.getElementById("event_input_test");

    img_nope.addEventListener("error", eventsTests);
    img_nope.addEventListener("load", eventsTests); // UiEvent
    img_nope.addEventListener("abort", eventsTests); // UiEvent

    select_test.addEventListener("change", eventsTests);

    audio_test.addEventListener("load", eventsTests); // UiEvent
    audio_test.addEventListener("abort", eventsTests); // UiEvent
    audio_test.addEventListener("loadstart", eventsTests);
    audio_test.addEventListener("canplaythrough", eventsTests);
    audio_test.addEventListener("canplay", eventsTests);
    audio_test.addEventListener("ended", eventsTests);
    audio_test.addEventListener("durationchange", eventsTests);
    audio_test.addEventListener("seeking", eventsTests);
    audio_test.addEventListener("seekend", eventsTests);
    audio_test.addEventListener("progress", eventsTests);
    audio_test.addEventListener("playing", eventsTests);
    audio_test.addEventListener("play", eventsTests);
    audio_test.addEventListener("pause", eventsTests);
    audio_test.addEventListener("loadedmetadata", eventsTests);
    audio_test.addEventListener("loadeddata", eventsTests);
    audio_test.addEventListener("volumechange", eventsTests);
    audio_test.addEventListener("timeupdate", eventsTests);
    audio_test.addEventListener("suspend", eventsTests);
    audio_test.addEventListener("stalled", eventsTests);

    form_test.addEventListener("reset", eventsTests);
    form_test.addEventListener("submit", eventsTests);

    event_input_test.addEventListener("invalid", eventsTests);

    function eventsTests(e) {
        event_test_result.innerHTML += e.target.id + " - " + e.type;
        e.preventDefault();
    }

    // FULLSCREEN
    document.addEventListener("fullscreenchange",eventsTests);
    document.addEventListener("mozfullscreenchange",eventsTests);
    document.addEventListener("webkitfullscreenchange",eventsTests);
    document.addEventListener("msfullscreenchange",eventsTests);
    document.addEventListener("fullscreenerror",eventsTests);
    document.addEventListener("mozfullscreenerror",eventsTests);
    document.addEventListener("webkitfullscreenerror",eventsTests);
    document.addEventListener("msfullscreenerror",eventsTests);
    // element you want displayed in fullscreen
    var doc = document.getElementById("event_tests_area");
    // open fullscreen mode
    function openFullscreen() {
      if (doc.requestFullscreen) {
        doc.requestFullscreen();
      } else if (doc.mozRequestFullScreen) { /* Firefox */
        doc.mozRequestFullScreen();
      } else if (doc.webkitRequestFullscreen) { /* Chrome, Safari &amp; Opera */
        doc.webkitRequestFullscreen();
      } else if (doc.msRequestFullscreen) { /* IE/Edge */
        doc.msRequestFullscreen();
      }
    }
    // close fullscreen mode
    function closeFullscreen() {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }

    document.body.addEventListener("offline", eventsTests, false);
    document.body.addEventListener("online", eventsTests, false);
  </code></pre>

  <pre><code class="html">
    &lt;iframe src="../js.html" name="iframe_a" id="menu_target" allowfullscreen="true"&gt;&lt;/iframe&gt;
  </code></pre>

  <h3>triggering/simulating  built-in events</h3>

  <pre><code class="javascript">
    function simulateClick() {
      var event = new MouseEvent('click', {
        view: window,
        bubbles: true,
        cancelable: true
      });
      var cb = document.getElementById('checkbox');
      var cancelled = !cb.dispatchEvent(event);
      if (cancelled) {
        // A handler called preventDefault.
        alert("cancelled");
      } else {
        // None of the handlers called preventDefault.
        alert("not cancelled");
      }
    }
  </code></pre>



<h2 id="ui">UiEvent</h2>

  <ul>
    <li>events that are triggered from the user interface belongs to the UiEvent Object</li>
    <li>properties and methods
    <ul>
      <li>detail - number with details about the event
        <ul>
          <li>for click or dblclick events = current click count</li>
          <li>for mousedown or mouseup events is 1 plus the current click count</li>
          <li>for all other = 0</li>
        </ul>
      </li>
      <li>view - reference to the Window object where the event occurred</li>
      <li>inherits all the properties and methods from <strong>Event</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>scroll - when an element's scrollbar is being scrolled</li>
      <li>select - occurs after the user selects some text inside input/textarea</li>
      <li>beforeunload - occurs before the document is about to be unloaded (if event is not assigned to the body element, you must assign/attach the event on the window object, and use the returnValue property to create a custom message (in IE only, see syntax examples below))</li>
      <li>unload - occurs once a page has unloaded (for body)</li>
      <li>resize - when the document view is resized</li>
      <li>abort - when the loading of a media is aborted</li>
      <li>error - when an error occurred during the loading of a media file</li>
      <li>load - when an object has loaded (body, frame, iframe, img, input-type="image", link, script, style)
        <ul>
          <li>most often used within the body element to execute a script once a web page has completely loaded all content (including images, script files, CSS files, etc.)</li>
          <li>can be used to check the visitor's browser type and browser version, and load the proper version of the web page based on the information</li>
          <li>can also be used to deal with cookies</li>
        </ul>
      </li>
    </ul>
    </li>
  </ul>

  <div class="example">
    <input type="text" id="ui_test" class="tests-input" value="select text or doubleclick"/>
  </div>

  <div id="ui_test_result" class="example"></div>

  <script>
    var ui_test = document.getElementById("ui_test");
    var ui_test_result = document.getElementById("ui_test_result");

    // &lt;body onbeforeunload="return myFunction()"&gt;
    // OR
    // window.addEventListener("beforeunload", function(event) {
    //     event.returnValue = "Write something clever here..";
    // });

    ui_test.addEventListener("dblclick", uiFunction);

    document.getElementsByTagName("BODY")[0].addEventListener("load", uiFunction);
    document.getElementsByTagName("BODY")[0].addEventListener("select", uiFunction);

    //ui_test_result.addEventListener("scroll", uiFunction);
    window.addEventListener("resize", uiFunction);
    document.getElementsByTagName("BODY")[0].addEventListener("beforeunload", uiFunction);
    document.getElementsByTagName("BODY")[0].addEventListener("unload", uiFunction);

    function uiFunction(e) {
      ui_test_result.innerHTML = "e.type: " + e.type + "<br>" +
      "e.detail: " + e.detail + "<br>" +
      ( !e.view ? ""
        : (
            "e.view: " + e.view + "<br>" +
            "e.view.outerWidth: " + e.view.outerWidth + "<br>" +
            "e.view.outerHeight: " + e.view.outerHeight + "<br>"
          ) + ("e.view === window: " + (e.view===window)) + "<br>"
      ) +
      ( !window ? ""
        : (
            "window: " + window + "<br>" +
            "window.outerWidth: " + window.outerWidth + "<br>" +
            "window.outerHeight: " + window.outerHeight + "<br>"
          )
      ) +
      "----------------------------------------<br>";
    }
    // &lt;body onload="checkCookies()"&gt;
    //
    // function checkCookies() {
    //   var text = "";
    //   if (navigator.cookieEnabled == true) {
    //     text = "Cookies are enabled.";
    //   } else {
    //     text = "Cookies are not enabled.";
    //   }
    //   document.getElementById("demo").innerHTML = text;
    // }
  </script>

  <pre><code class="javascript">
    var ui_test = document.getElementById("ui_test");
    var ui_test_result = document.getElementById("ui_test_result");

    // &lt;body onbeforeunload="return myFunction()"&gt;
    // OR
    // window.addEventListener("beforeunload", function(event) {
    //     event.returnValue = "Write something clever here..";
    // });

    ui_test.addEventListener("dblclick", uiFunction);

    document.getElementsByTagName("BODY")[0].addEventListener("load", uiFunction);
    document.getElementsByTagName("BODY")[0].addEventListener("select", uiFunction);

    //ui_test_result.addEventListener("scroll", uiFunction);
    window.addEventListener("resize", uiFunction);
    document.getElementsByTagName("BODY")[0].addEventListener("beforeunload", uiFunction);
    document.getElementsByTagName("BODY")[0].addEventListener("unload", uiFunction);

    function uiFunction(e) {
      ui_test_result.innerHTML = "e.type: " + e.type +
      "e.detail: " + e.detail +
      ( !e.view ? ""
        : (
            "e.view: " + e.view +
            "e.view.outerWidth: " + e.view.outerWidth +
            "e.view.outerHeight: " + e.view.outerHeight
          ) + ("e.view === window: " + (e.view===window))
      ) +
      ( !window ? ""
        : (
            "window: " + window +
            "window.outerWidth: " + window.outerWidth +
            "window.outerHeight: " + window.outerHeight
          )
      ) +
      "----------------------------------------";
    }
    // &lt;body onload="checkCookies()"&gt;
    //
    // function checkCookies() {
    //   var text = "";
    //   if (navigator.cookieEnabled == true) {
    //     text = "Cookies are enabled.";
    //   } else {
    //     text = "Cookies are not enabled.";
    //   }
    //   document.getElementById("demo").innerHTML = text;
    // }
  </code></pre>



<h2 id="keyboard">KeyboardEvent</h2>

  <ul>
    <li>events that occur when user presses a key on the keyboard, belongs to the KeyboardEvent Object</li>
    <li>properties and methods
    <ul>
      <li>altKey [returns:true/false] - whether the "ALT" key was pressed when the key event was triggered</li>
      <li>ctrlKey [returns:true/false] - whether the "CTRL" key was pressed when the key event was triggered</li>
      <li>shiftKey [returns:true/false] - whether the "SHIFT" key was pressed when the key event was triggered</li>
      <li>metaKey [returns:true/false] - whether the "meta" key was pressed when the key event was triggered</li>
      <li>code - code of the key that triggered the event</li>
      <li>charCode - Unicode character code of the key that triggered the event</li>
      <li>key - key value of the key represented by the event</li>
      <li>keyCode - Unicode character code of the key that triggered thekeypress event, or the Unicode key code of the key that triggered thekeydown orkeyup event</li>
      <li>getModifierState(modifierKey) [returns:true/false] - if the specified key is activated
        <ul>
          <li>keys activated only when they are being pressed down
          <ul>
            <li>Alt</li>
            <li>AltGraph</li>
            <li>Control</li>
            <li>Meta</li>
            <li>Shift</li>
          </ul>
          </li>
          <li>keys activated when they are clicked, and deactivated when they are clicked again
          <ul>
            <li>CapsLock</li>
            <li>NumLock</li>
            <li>ScrollLock</li>
          </ul>
        </li>
        </ul>
      </li>
      <li>location - location of a key on the keyboard or device
        <ul>
          <li>0 - DOM_KEY_LOCATION_STANDARD - not pressed on the right/left/numeric keypad</li>
          <li>1 - DOM_KEY_LOCATION_LEFT - left key was pressed(left "CTRL",...)</li>
          <li>2 - DOM_KEY_LOCATION_RIGHT - right key was pressed (right "CTRL",...)</li>
          <li>3 - DOM_KEY_LOCATION_NUMPAD - pressed on the numeric keypad</li>
        </ul>
      </li>
      <li>repeat [returns:true/false] - whether a key is being hold down repeatedly, or not</li>
      <li>which - Unicode character code of the key that triggered thekeypress event, or the Unicode key code of the key that triggered thekeydown orkeyup event</li>
      <li>isComposing [returns:true/false] - whether the state of the event is composing or not</li>
      <li>inherits all the properties and methods from <strong>UiEvent</strong> and <strong>Event</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>keydown - when the user is pressing a key</li>
      <li>keypress - when the user presses a key</li>
      <li>keyup - when the user releases a key</li>
    </ul>
    </li>
    <li>event.which || event.keyCode (as a crosbrowser solution), to find out if the user is pressing a printable key (e.g. "a" or "5"), it is recommended to use this property on thekeypress event, to find out if the user is pressing a function key (e.g. "F1", "CAPS LOCK" or "Home") use thekeydown orkeyup event</li>
  </ul>

  <div class="example w-50 h-20">
    <input
      id="kb_test"
      class="tests-input"
      type="text"
      value="Modify This Content"
    />
  </div>

  <div id="kb_test_result" class="example w-50 h-20"></div>

  <script>
    var kb_test = document.getElementById("kb_test");
    var kb_test_result = document.getElementById("kb_test_result");
    kb_test.addEventListener("keydown", kbFunction);
    kb_test.addEventListener("keypress", kbFunction);
    kb_test.addEventListener("keyup", kbFunction);
    function kbFunction(e) {
      kb_test_result.innerHTML += "e.type: " + e.type + "<br>" +
      "e.altKey: " + e.altKey + "<br>" +
      "e.ctrlKey: " + e.ctrlKey + "<br>" +
      "e.shiftKey: " + e.shiftKey + "<br>" +
      "e.metaKey: " + e.metaKey + "<br>" +
      "e.charCode: " + e.charCode + "<br>" +
      "e.code: " + e.code + "<br>" +
      "e.getModifierState('Shift'): " + e.getModifierState('Shift') + "<br>" +
      "e.key (keyboard key): " + e.key + "<br>" +
      "e.keyCode: " + e.keyCode + "<br>" +
      "e.location: " + e.location + "<br>" +
      "e.repeat: " + e.repeat + "<br>" +
      "e.which: " + e.which + "<br>" +
      "String.fromCharCode: " + String.fromCharCode( (e.which||e.keyCode) ) + "<br>" +
      "-----------------------------------------------<br>";
      var x = e.which || e.keyCode;
      if (x == 27) {  // 27 is the ESC key
          alert ("You pressed the Escape key!");
      }
    }
  </script>

  <pre><code class="javascript">
    var kb_test = document.getElementById("kb_test");
    var kb_test_result = document.getElementById("kb_test_result");
    kb_test.addEventListener("keydown", kbFunction);
    kb_test.addEventListener("keypress", kbFunction);
    kb_test.addEventListener("keyup", kbFunction);
    function kbFunction(e) {
      kb_test_result.innerHTML += "e.type: " + e.type +
      "e.altKey: " + e.altKey +
      "e.ctrlKey: " + e.ctrlKey +
      "e.shiftKey: " + e.shiftKey +
      "e.metaKey: " + e.metaKey +
      "e.charCode: " + e.charCode +
      "e.code: " + e.code +
      "e.getModifierState('Shift'): " + e.getModifierState('Shift') +
      "e.key (keyboard key): " + e.key +
      "e.keyCode: " + e.keyCode +
      "e.location: " + e.location +
      "e.repeat: " + e.repeat +
      "e.which: " + e.which +
      "String.fromCharCode: " + String.fromCharCode( (e.which||e.keyCode) ) +
      "-----------------------------------------------";
      var x = e.which || e.keyCode;
      if (x == 27) {  // 27 is the ESC key
          alert ("You pressed the Escape key!");
      }
    }
  </code></pre>



<h2 id="mouse">MouseEvent</h2>

  <ul>
    <li>events that occur when the mouse interacts with the HTML document, belongs to the MouseEvent Object</li>
    <li>properties and methods
    <ul>
      <li>button - which mouse button was pressed when the mouse event was triggered
        <ul>
          <li>0/1 - left mouse button</li>
          <li>1/4 - wheel button or middle button (if present)</li>
          <li>2 - right mouse button</li>
          <li>for a left-hand configured mouse, the return values are reversed</li>
        </ul>
      </li>
      <li>buttons - which mouse buttons were pressed when the mouse event was triggered (or sum of buttons value)
        <ul>
          <li>1 - left mouse button</li>
          <li>2 - right mouse button</li>
          <li>4 - wheel button or middle button (if present)</li>
          <li>8 - fourth mouse button (typically the "Browser Back" button)</li>
          <li>16 - fifth mouse button (typically the "Browser Forward" button)</li>
          <li>for a left-hand configured mouse, the return values are reversed</li>
        </ul>
      </li>
      <li>relatedTarget - element related to the element that triggered the mouse event</li>
      <li>screenX - horizontal coordinate of the mouse pointer, relative to the <strong>screen</strong>, when an event was triggered</li>
      <li>screenY - vertical coordinate of the mouse pointer, relative to the <strong>screen</strong>, when an event was triggered</li>
      <li>clientX - horizontal coordinate of the mouse pointer, relative to the <strong>current window</strong>, when the mouse event was triggered</li>
      <li>clientY - vertical coordinate of the mouse pointer, relative to the <strong>current window</strong>, when the mouse event was triggered</li>
      <li>pageX - horizontal coordinate of the mouse pointer, relative to the <strong>document</strong>, when the mouse event was triggered</li>
      <li>pageY - vertical coordinate of the mouse pointer, relative to the <strong>document</strong>, when the mouse event was triggered</li>
      <li>offsetX - horizontal coordinate of the mouse pointer relative to the position of the <strong>edge of the target element</strong></li>
      <li>offsetY - vertical coordinate of the mouse pointer relative to the position of the <strong>edge of the target element</strong></li>
      <li>movementX - horizontal coordinate of the mouse pointer relative to the position of the <strong>last mousemove event</strong></li>
      <li>movementY - vertical coordinate of the mouse pointer relative to the position of the <strong>last mousemove event</strong></li>
      <li>which - which mouse button was pressed when the mouse event was triggered
        <ul>
          <li>0 - no button</li>
          <li>1 - left mouse button</li>
          <li>2 - wheel button or middle button (if present)</li>
          <li>3 - right mouse button</li>
          <li>for a left-hand configured mouse, the return values are reversed</li>
        </ul>
      </li>
      <li>altKey [returns:true/false] - whether the "ALT" key was pressed when the mouse event was triggered</li>
      <li>ctrlKey [returns:true/false] - whether the "CTRL" key was pressed when the mouse event was triggered</li>
      <li>shiftKey [returns:true/false] - whether the "SHIFT" key was pressed when an event was triggered</li>
      <li>metaKey [returns:true/false] - whether the "META" key was pressed when an event was triggered</li>
      <li>getModifierState(modifierKey) [returns:true/false] - if the specified key is activated
        <ul>
          <li>keys activated only when they are being pressed down
          <ul>
            <li>Alt</li>
            <li>AltGraph</li>
            <li>Control</li>
            <li>Meta</li>
            <li>Shift</li>
          </ul>
          </li>
          <li>keys activated when they are clicked, and deactivated when they are clicked again
          <ul>
            <li>CapsLock</li>
            <li>NumLock</li>
            <li>ScrollLock</li>
          </ul>
        </li>
        </ul>
      </li>
      <li>inherits all the properties and methods from <strong>UiEvent</strong> and <strong>Event</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>click - when the user clicks on an element</li>
      <li>contextmenu - when the user right-clicks on an element to open a context menu</li>
      <li>dblclick - when the user double-clicks on an element</li>
      <li>mousedown - when the user presses a mouse button over an element</li>
      <li>mouseenter - when the pointer is moved onto an element</li>
      <li>mouseleave - when the pointer is moved out of an element</li>
      <li>mousemove - when the pointer is moving while it is over an element</li>
      <li>mouseout - when a user moves the mouse pointer out of an element, or out of one of its children</li>
      <li>mouseover - when the pointer is moved onto an element, or onto one of its children</li>
      <li>mouseup - when a user releases a mouse button over an element</li>
    </ul>
    </li>
  </ul>

  <div id="mouse_test" class="example h-35"></div>

  <script>
    var mouse_test = document.getElementById("mouse_test");

    mouse_test.addEventListener("click", mouseFunction);
    mouse_test.addEventListener("contextmenu", mouseFunction);
    mouse_test.addEventListener("dblclick", mouseFunction);
    mouse_test.addEventListener("mousedown", mouseFunction);
    mouse_test.addEventListener("mouseenter", mouseFunction);
    mouse_test.addEventListener("mouseleave", mouseFunction);
    mouse_test.addEventListener("mousemove", mouseFunction);
    mouse_test.addEventListener("mouseout", mouseFunction);
    mouse_test.addEventListener("mouseover", mouseFunction);
    mouse_test.addEventListener("mouseup", mouseFunction);

    function mouseFunction(e) {
      mouse_test.innerHTML = "e.type: " + e.type + "<br>" +
      "e.altKey: " + e.altKey + "<br>" +
      "e.ctrlKey: " + e.ctrlKey + "<br>" +
      "e.shiftKey: " + e.shiftKey + "<br>" +
      "e.metaKey: " + e.metaKey + "<br>" +
      "e.getModifierState('Shift'): " + e.getModifierState('Shift') + "<br>" +

      "e.button: " + e.button + "<br>" +
      "e.buttons: " + e.buttons + "<br>" +
      "-----------------------------------------------<br>" +
      "e.screenX: " + e.screenX + "<br>" +
      "e.screenY: " + e.screenY + "<br>" +
      "-----------------------------------------------<br>" +
      "e.clientX: " + e.clientX + "<br>" +
      "e.clientY: " + e.clientY + "<br>" +
      "-----------------------------------------------<br>" +
      "e.pageX: " + e.pageX + "<br>" +
      "e.pageY: " + e.pageY + "<br>" +
      "-----------------------------------------------<br>" +
      "e.offsetX: " + e.offsetX + "<br>" +
      "e.offsetY: " + e.offsetY + "<br>" +
      "-----------------------------------------------<br>" +
      "e.movementX: " + e.movementX + "<br>" +
      "e.movementY: " + e.movementY + "<br>" +
      "-----------------------------------------------<br>" +
      "e.region: " + e.region + "<br>" +
      "e.relatedTarget: " + e.relatedTarget + "<br>" +

      "e.which: " + e.which + "<br>";

      var x = e.which || e.keyCode;
      if (x == 27) {  // 27 is the ESC key
          alert ("You pressed the Escape key!");
      }
    }
  </script>

  <pre><code class="javascript">
    var mouse_test = document.getElementById("mouse_test");

    mouse_test.addEventListener("click", mouseFunction);
    mouse_test.addEventListener("contextmenu", mouseFunction);
    mouse_test.addEventListener("dblclick", mouseFunction);
    mouse_test.addEventListener("mousedown", mouseFunction);
    mouse_test.addEventListener("mouseenter", mouseFunction);
    mouse_test.addEventListener("mouseleave", mouseFunction);
    mouse_test.addEventListener("mousemove", mouseFunction);
    mouse_test.addEventListener("mouseout", mouseFunction);
    mouse_test.addEventListener("mouseover", mouseFunction);
    mouse_test.addEventListener("mouseup", mouseFunction);

    function mouseFunction(e) {
      mouse_test.innerHTML = "e.type: " + e.type +
      "e.altKey: " + e.altKey +
      "e.ctrlKey: " + e.ctrlKey +
      "e.shiftKey: " + e.shiftKey +
      "e.metaKey: " + e.metaKey +
      "e.getModifierState('Shift'): " + e.getModifierState('Shift') +

      "e.button: " + e.button +
      "e.buttons: " + e.buttons +
      "-----------------------------------------------" +
      "e.screenX: " + e.screenX +
      "e.screenY: " + e.screenY +
      "-----------------------------------------------" +
      "e.clientX: " + e.clientX +
      "e.clientY: " + e.clientY +
      "-----------------------------------------------" +
      "e.pageX: " + e.pageX +
      "e.pageY: " + e.pageY +
      "-----------------------------------------------" +
      "e.offsetX: " + e.offsetX +
      "e.offsetY: " + e.offsetY +
      "-----------------------------------------------" +
      "e.movementX: " + e.movementX +
      "e.movementY: " + e.movementY +
      "-----------------------------------------------" +
      "e.region: " + e.region +
      "e.relatedTarget: " + e.relatedTarget +

      "e.which: " + e.which;

      var x = e.which || e.keyCode;
      if (x == 27) {  // 27 is the ESC key
          alert ("You pressed the Escape key!");
      }
    }
  </code></pre>



<h2 id="wheel">WheelEvent</h2>

  <ul>
    <li>events that occur when the mouse wheel is scrolling, belongs to the WheelEvent Object</li>
    <li>properties and methods
    <ul>
      <li>deltaX - horizontal scroll amount of a mouse wheel (x-axis)</li>
      <li>deltaY - vertical scroll amount of a mouse wheel (y-axis)</li>
      <li>deltaZ - scroll amount of a mouse wheel for the z-axis (positive value when scrolling in, and a negative value when scrolling out, otherwise 0)</li>
      <li>deltaMode - number that represents the unit of measurements for delta values (0=pixels, 1=lines or 2=pages)</li>
      <li>inherits all the properties and methods from <strong>MouseEvent</strong>, <strong>UiEvent</strong> and <strong>Event</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>wheel - when the mouse wheel rolls up or down over an element</li>
    </ul>
    </li>
    <li>most mouse devices do not have the ability to scroll along the z-axis, and will always return 0</li>
  </ul>

  <div id="wheel_test" class="example h_5"></div>

  <script>
    var wheel_test = document.getElementById("wheel_test");
    wheel_test.addEventListener("wheel", wheelFunction);
    function wheelFunction(e) {
      wheel_test.innerHTML = "e.type: " + e.type + "<br>" +
      "e.deltaX: " + e.deltaX + "<br>" +
      "e.deltaY: " + e.deltaY + "<br>" +
      "e.deltaZ: " + e.deltaZ + "<br>" +
      "e.deltaMode: " + e.deltaMode + " = "+
      (
        !e.deltaMode ? "pixels" : ( (e.deltaMode==1) ? "lines" : "pages")
      );
    }
  </script>

  <pre><code class="javascript">
    var wheel_test = document.getElementById("wheel_test");
    wheel_test.addEventListener("wheel", wheelFunction);
    function wheelFunction(e) {
      wheel_test.innerHTML = "e.type: " + e.type +
      "e.deltaX: " + e.deltaX +
      "e.deltaY: " + e.deltaY +
      "e.deltaZ: " + e.deltaZ +
      "e.deltaMode: " + e.deltaMode + " = "+
      (
        !e.deltaMode ? "pixels" : ( (e.deltaMode==1) ? "lines" : "pages")
      );
    }
  </code></pre>



<h2 id="touch">TouchEvent</h2>

  <ul>
    <li>events that occur when user touches a touch-based device, belongs to the TouchEvent Object</li>
    <li>properties and methods
    <ul>
      <li>touches - list of all the touch objects that are currently in contact with the surface</li>
      <li>changedTouches - list of all the touch objects whose state changed between the previous touch and this touch</li>
      <li>targetTouches - list of all the touch objects that are in contact with the surface and where the touchstart event occured on the same target element as the current target element</li>
      <li>altKey [returns:true/false] - whether the "ALT" key was pressed when the key event was triggered</li>
      <li>ctrlKey [returns:true/false] - whether the "CTRL" key was pressed when the key event was triggered</li>
      <li>shiftKey [returns:true/false] - whether the "SHIFT" key was pressed when the key event was triggered</li>
      <li>metaKey [returns:true/false] - whether the "meta" key was pressed when the key event was triggered</li>
      <li>inherits all the properties and methods from <strong>UiEvent</strong> and <strong>Event</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>touchstart  - when a finger is placed on a touch screen</li>
      <li>touchmove - when a finger is dragged across the screen</li>
      <li>touchend - when a finger is removed from a touch screen</li>
      <li>touchcancel - when the touch is interrupted</li>
    </ul>
    </li>
    <li>preventing things like pinchZoom on a page is to call preventDefault() on the second touch in a series, this behavior is not well defined in the touch events spec, and results in different behavior for different browsers, it's not recommended to depend on any particular behavior in this case, but rather to depend on meta viewport to prevent zooming</li>
  </ul>

  <div id="touch_test" class="example w-50 h-20">Touch this area</div>
  <div id="touch_test_result" class="example w-50 h-20"></div>

  <script>
    var touch_test = document.getElementById("touch_test");
    var touch_test_result = document.getElementById("touch_test_result");

    touch_test.addEventListener("touchstart", touchFunction);
    touch_test.addEventListener("touchmove", touchFunction);
    touch_test.addEventListener("touchend", touchFunction);
    touch_test.addEventListener("touchcancel", touchFunction);

    function touchFunction(e) {
      touch_test_result.innerHTML += "e.type: " + e.type + "<br>" +
      "e.targetTouches: " + e.targetTouches + "<br>" +
      "e.targetTouches.length: " + e.targetTouches.length + "<br>" +
      "e.changedTouches: " + e.changedTouches + "<br>" +
      "e.changedTouches.length: " + e.changedTouches.length + "<br>" +
      "e.touches: " + e.touches + "<br>" +
      "e.touches.length: " + e.touches.length + "<br>" +
      "e.touches[0].target.tagName: " + e.touches[0].target.tagName + "<br>" +
      "-------------------------------------<br>";
    }
  </script>

  <pre><code class="javascript">
    var touch_test = document.getElementById("touch_test");
    var touch_test_result = document.getElementById("touch_test_result");

    touch_test.addEventListener("touchstart", touchFunction);
    touch_test.addEventListener("touchmove", touchFunction);
    touch_test.addEventListener("touchend", touchFunction);
    touch_test.addEventListener("touchcancel", touchFunction);

    function touchFunction(e) {
      touch_test_result.innerHTML += "e.type: " + e.type +
      "e.targetTouches: " + e.targetTouches +
      "e.targetTouches.length: " + e.targetTouches.length +
      "e.changedTouches: " + e.changedTouches +
      "e.changedTouches.length: " + e.changedTouches.length +
      "e.touches: " + e.touches +
      "e.touches.length: " + e.touches.length +
      "e.touches[0].target.tagName: " + e.touches[0].target.tagName +
      "-------------------------------------";
    }

    // since calling preventDefault() on a touchstart
    // or the first touchmove event of a series
    // prevents the corresponding mouse events from firing
    // it's common to call preventDefault() on touchmove rather than touchstart
    // that way, mouse events can still fire and things like links will continue to work
    // alternatively, some frameworks have taken to refiring touch events as mouse events
    // this example is oversimplified and may result in strange behavior
    function onTouch(evt) {
      evt.preventDefault();
      if (evt.touches.length > 1 || (evt.type == "touchend" &amp;&amp; evt.touches.length > 0))
        return;
      var newEvt = document.createEvent("MouseEvents");
      var type = null;
      var touch = null;
      switch (evt.type) {
        case "touchstart":
          type = "mousedown";
          touch = evt.changedTouches[0];
          break;
        case "touchmove":
          type = "mousemove";
          touch = evt.changedTouches[0];
          break;
        case "touchend":
          type = "mouseup";
          touch = evt.changedTouches[0];
          break;
      }
      newEvt.initMouseEvent(type, true, true, evt.originalTarget.ownerDocument.defaultView, 0,
        touch.screenX, touch.screenY, touch.clientX, touch.clientY,
        evt.ctrlKey, evt.altKey, evt.shiftKey, evt.metaKey, 0, null);
      evt.originalTarget.dispatchEvent(newEvt);
    }
  </code></pre>

  <h3>draw on canvas with touch</h3>

  <ul>
    <li>use/change clientX/Y to pageX/Y to fix cursor location definiton</li>
  </ul>

  <div class="example">
    <button onclick="startup()">Initialize canvas</button>
  </div>

  <canvas id="touch_canvas" class="example w-50 h-20">
    Your browser does not support canvas element
  </canvas>

  <div id="touch_canvas_log" class="example w-50 h-20"></div>

  <script type="text/javascript">
    function startup() {
      cnv = document.getElementById("touch_canvas");
      ctx = cnv.getContext("2d");
      cnv.addEventListener("touchstart", handleStart, false);
      cnv.addEventListener("touchend", handleEnd, false);
      cnv.addEventListener("touchcancel", handleCancel, false);
      cnv.addEventListener("touchmove", handleMove, false);
      log("initialized");
    }
    function log(msg) {
      var p = document.getElementById('touch_canvas_log');
      p.innerHTML = msg + "<br>" + p.innerHTML;
    }
    var ongoingTouches = [],
        cnv = null,
        ctx = null;
    function handleStart(evt) {
      // keep the browser from continuing to process the touch event
      // (this also prevents a mouse event from also being delivered)
      evt.preventDefault();
      log("touchstart.");
      var touches = evt.changedTouches;
      for (var i = 0; i < touches.length; i++) {
        log("touchstart:" + i + "...");
        ongoingTouches.push(copyTouch(touches[i]));
        var color = colorForTouch(touches[i]);
        // 4-pixel wide line
        ctx.beginPath();
        ctx.arc(touches[i].clientX, touches[i].clientY, 4, 0, 2 * Math.PI, false);
        ctx.fillStyle = color;
        ctx.fill();
        log("touchstart:" + i + ".");
      }
    }
    function handleMove(evt) {
      evt.preventDefault();
      var touches = evt.changedTouches;
      // console.log(touches)
      for (var i = 0; i < touches.length; i++) {
        var color = colorForTouch(touches[i]);
        var idx = ongoingTouchIndexById(touches[i].identifier);
        if (idx >= 0) {
          log("continuing touch "+idx);
          ctx.beginPath();
          log("ctx.moveTo(" + ongoingTouches[idx].clientX + ", " + ongoingTouches[idx].clientY + ");");
          ctx.moveTo(ongoingTouches[idx].clientX, ongoingTouches[idx].clientY);
          log("ctx.lineTo(" + touches[i].clientX + ", " + touches[i].clientY + ");");
          ctx.lineTo(touches[i].clientX, touches[i].clientY);
          ctx.lineWidth = 4;
          ctx.strokeStyle = color;
          ctx.stroke();
          ongoingTouches.splice(idx, 1, copyTouch(touches[i]));  // swap in the new touch record
          log("---------------");
        } else {
          log("cant figure out which touch to continue");
        }
      }
    }
    function handleEnd(evt) {
      evt.preventDefault();
      log("touchend");
      var touches = evt.changedTouches;
      for (var i = 0; i < touches.length; i++) {
        var color = colorForTouch(touches[i]);
        var idx = ongoingTouchIndexById(touches[i].identifier);
        if (idx >= 0) {
          ctx.lineWidth = 4;
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.moveTo(ongoingTouches[idx].clientX, ongoingTouches[idx].clientY);
          ctx.lineTo(touches[i].clientX, touches[i].clientY);
          ctx.fillRect(touches[i].clientX - 4, touches[i].clientY - 4, 8, 8);  // and a square at the end
          ongoingTouches.splice(idx, 1);  // remove touch, we're done
        } else {
          log("cant figure out which touch to end");
        }
      }
    }
    function handleCancel(evt) {
      evt.preventDefault();
      log("touchcancel.");
      var touches = evt.changedTouches;
      for (var i = 0; i < touches.length; i++) {
        var idx = ongoingTouchIndexById(touches[i].identifier);
        ongoingTouches.splice(idx, 1);  // remove it; we're done
      }
    }
    function colorForTouch(touch) {
      var r = touch.identifier % 16;
      var g = Math.floor(touch.identifier / 3) % 16;
      var b = Math.floor(touch.identifier / 7) % 16;
      r = r.toString(16); // make it a hex digit
      g = g.toString(16); // make it a hex digit
      b = b.toString(16); // make it a hex digit
      var color = "#" + r + g + b;
      log("color for touch with identifier " + touch.identifier + " = " + color);
      return color;
    }
    // some browsers (mobile Safari, for one) re-use touch objects between events
    // so it's best to copy the bits you care about, rather than referencing the entire object
    function copyTouch(touch) {
      return { identifier: touch.identifier, clientX: touch.clientX, clientY: touch.clientY };
    }
    // scans through the ongoingTouches array to find the touch matching the given identifier
    // then returns that touch's index into the array
    function ongoingTouchIndexById(idToFind) {
      for (var i = 0; i < ongoingTouches.length; i++) {
        var id = ongoingTouches[i].identifier;
        if (id == idToFind) { return i; }
      }
      return -1;    // not found
    }
  </script>

  <pre><code class="javascript">
    function startup() {
      cnv = document.getElementById("touch_canvas");
      ctx = cnv.getContext("2d");
      cnv.addEventListener("touchstart", handleStart, false);
      cnv.addEventListener("touchend", handleEnd, false);
      cnv.addEventListener("touchcancel", handleCancel, false);
      cnv.addEventListener("touchmove", handleMove, false);
      log("initialized.");
    }
    function log(msg) {
      var p = document.getElementById('touch_canvas_log');
      p.innerHTML = msg + " - " + p.innerHTML;
    }
    var ongoingTouches = [],
        cnv = null,
        ctx = null;
    function handleStart(evt) {
      // keep the browser from continuing to process the touch event
      // (this also prevents a mouse event from also being delivered)
      evt.preventDefault();
      log("touchstart.");
      var touches = evt.changedTouches;
      for (var i = 0; i &lt; touches.length; i++) {
        log("touchstart:" + i + "...");
        ongoingTouches.push(copyTouch(touches[i]));
        var color = colorForTouch(touches[i]);
        // 4-pixel wide line
        ctx.beginPath();
        ctx.arc(touches[i].clientX, touches[i].clientY, 4, 0, 2 * Math.PI, false);
        ctx.fillStyle = color;
        ctx.fill();
        log("touchstart:" + i + ".");
      }
    }
    function handleMove(evt) {
      evt.preventDefault();
      var touches = evt.changedTouches;
      // console.log(touches)
      for (var i = 0; i &lt; touches.length; i++) {
        var color = colorForTouch(touches[i]);
        var idx = ongoingTouchIndexById(touches[i].identifier);
        if (idx >= 0) {
          log("continuing touch "+idx);
          ctx.beginPath();
          log("ctx.moveTo(" + ongoingTouches[idx].clientX + ", " + ongoingTouches[idx].clientY + ");");
          ctx.moveTo(ongoingTouches[idx].clientX, ongoingTouches[idx].clientY);
          log("ctx.lineTo(" + touches[i].clientX + ", " + touches[i].clientY + ");");
          ctx.lineTo(touches[i].clientX, touches[i].clientY);
          ctx.lineWidth = 4;
          ctx.strokeStyle = color;
          ctx.stroke();
          ongoingTouches.splice(idx, 1, copyTouch(touches[i]));  // swap in the new touch record
          log(".");
        } else {
          log("can't figure out which touch to continue");
        }
      }
    }
    function handleEnd(evt) {
      evt.preventDefault();
      log("touchend");
      var touches = evt.changedTouches;
      for (var i = 0; i &lt; touches.length; i++) {
        var color = colorForTouch(touches[i]);
        var idx = ongoingTouchIndexById(touches[i].identifier);
        if (idx >= 0) {
          ctx.lineWidth = 4;
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.moveTo(ongoingTouches[idx].clientX, ongoingTouches[idx].clientY);
          ctx.lineTo(touches[i].clientX, touches[i].clientY);
          ctx.fillRect(touches[i].clientX - 4, touches[i].clientY - 4, 8, 8);  // and a square at the end
          ongoingTouches.splice(idx, 1);  // remove touch, we're done
        } else {
          log("can't figure out which touch to end");
        }
      }
    }
    function handleCancel(evt) {
      evt.preventDefault();
      log("touchcancel.");
      var touches = evt.changedTouches;
      for (var i = 0; i &lt; touches.length; i++) {
        var idx = ongoingTouchIndexById(touches[i].identifier);
        ongoingTouches.splice(idx, 1);  // remove it; we're done
      }
    }
    function colorForTouch(touch) {
      var r = touch.identifier % 16;
      var g = Math.floor(touch.identifier / 3) % 16;
      var b = Math.floor(touch.identifier / 7) % 16;
      r = r.toString(16); // make it a hex digit
      g = g.toString(16); // make it a hex digit
      b = b.toString(16); // make it a hex digit
      var color = "#" + r + g + b;
      log("color for touch with identifier " + touch.identifier + " = " + color);
      return color;
    }
    // some browsers (mobile Safari, for one) re-use touch objects between events
    // so it's best to copy the bits you care about, rather than referencing the entire object
    function copyTouch(touch) {
      return { identifier: touch.identifier, clientX: touch.clientX, clientY: touch.clientY };
    }
    // scans through the ongoingTouches array to find the touch matching the given identifier
    // then returns that touch's index into the array
    function ongoingTouchIndexById(idToFind) {
      for (var i = 0; i &lt; ongoingTouches.length; i++) {
        var id = ongoingTouches[i].identifier;
        if (id == idToFind) { return i; }
      }
      return -1;    // not found
    }
  </code></pre>



<h2 id="pointer">PointerEvent</h2>

  <ul>
    <li>designed to create a single DOM event model to handle pointing input devices such as a mouse, pen/stylus or touch (such as one or more fingers)</li>
    <li>terminology
    <ul>
      <li>pointer capture - allows the events for a pointer to be retargeted to a particular element other than the normal hit test result of the pointer's location</li>
      <li>active pointer - any pointer input device that can produce events, considered active if it can still produce further events</li>
      <li>digitizer - sensing device with a surface that can detect contact</li>
      <li>pointer event - DOM event fired for a pointer</li>
      <li>hit test - process the browser uses to determine a target element for a pointer event, typically, this is determined by considering the pointer's location and also the visual layout of elements in a document on screen media</li>
      <li>pointer - representation of input devices that can target a specific coordinate (or set of coordinates) on a screen: mouse, pen/stylus, and touch contacts</li>
      <li>pointer capture - allows events for a particular pointer event (PointerEvent) to be re-targeted to a particular element instead of the normal target (or hit test) at a pointer's location, can be used to ensure that an element continues to receive pointer events even if the pointer device's contact moves off the element (for example by scrolling)</li>
    </ul>
    <li>properties and methods
    <ul>
      <li>pointerId - unique identifier for the pointer causing the event</li>
      <li>width - the width (magnitude on the X axis), in CSS pixels, of the contact geometry of the pointe</li>
      <li>height - the height (magnitude on the Y axis), in CSS pixels, of the contact geometry of the pointer</li>
      <li>pressure - the normalized pressure of the pointer input in the range of 0 to 1, where 0 and 1 represent the minimum and maximum pressure the hardware is capable of detecting, respectively</li>
      <li>tiltX - the plane angle (in degrees, in the range of -90 to 90) between the Y-Z plane and the plane containing both the transducer (e.g. pen stylus) axis and the Y axis</li>
      <li>tiltY - the plane angle (in degrees, in the range of -90 to 90) between the X-Z plane and the plane containing both the transducer (e.g. pen stylus) axis and the X axis</li>
      <li>pointerType - indicates the device type that caused the event:
        <ul>
          <li>mouse</li>
          <li>pen</li>
          <li>touch</li>
        </ul>
      </li>
      <li>isPrimary - indicates if the pointer represents the primary pointer of this pointer type</li>
      <li>inherits all the properties and methods from <strong>MouseEvent</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>pointerenter - pointing device is moved into the hit test boundaries of an element or one of its descendants, including as a result of a pointerdown event from a device that does not support hover (see pointerdown)</li>
      <li>pointerover - pointing device is moved into an element's hit test boundaries</li>
      <li>pointermove - pointer changes coordinates</li>
      <li>pointerdown - pointer becomes active</li>
      <li>pointerup - pointer is no longer active</li>
      <li>pointercancel - pointer will no longer be able to generate events (for example the related device is deactived)</li>
      <li>pointerout - fired for several reasons, including: pointing device is moved out of the hit test boundaries of an element; firing the pointerup event for a device that does not support hover (see pointerup); after firing the pointercancel event (see pointercancel); when a pen stylus leaves the hover range detectable by the digitizer</li>
      <li>pointerleave - pointing device is moved out of the hit test boundaries of an element, for pen devices, this event is fired when the stylus leaves the hover range detectable by the digitizer</li>
      <li>gotpointercapture - element receives pointer capture</li>
      <li>lostpointercapture - pointer capture is released for a pointer</li>
      <li>gotpointercapture - returns the event handler (function) for the gotpointercapture event type</li>
      <li>lostpointercapture - returns the event handler (function) for the lostpointercapture event type</li>
      <li>setPointerCapture(pointerId) - designates a specific element as the capture target of future pointer events</li>
      <li>releasePointerCapture(pointerId) - releases (stops) pointer capture that was previously set for a specific pointer event</li>
    </ul>
    </li>
    <li>navigator.maxTouchPoints - maximum number of simultaneous touch contact points are supported by the current device</li>
    <li>when pointer capture is set, pointerover, pointerout pointerenter and pointerleave events are only generated when crossing the boundary of the element that has capture set since other elements can no longer be targeted by the pointer. This has the effect of suppressing these events on all other elements</li>
    <li>browser may map generic pointer input to mouse events for compatibility with mouse-based content, if you prevent the production of certain compatibility mouse events by canceling the pointerdown event note that: mouse events can only be prevented when the pointer is down; hovering pointers (e.g. a mouse with no buttons pressed) cannot have their mouse events prevented; mouseover, mouseout, mouseenter, and mouseleave events are never prevented (even if the pointer is down)</li>
    <li><strong>touch-action</strong> CSS property - whether or not the browser should apply its default (native) touch behavior (such as zooming or panning) to a region, <u>should work in pair with event to coordinate action</u>:
    <ul>
      <li>auto | none | [[ pan-x|pan-left|pan-right] || [pan-y|pan-up|pan-down] || pinch-zoom]] | manipulation</li>
      <li>auto - enable browser handling of all panning and zooming gestures</li>
      <li>none - disable browser handling of all panning and zooming gestures on an element (and its non-scrollable descendants), for example that provides its own dragging and zooming behavior â€“ such as a map or game surface</li>
      <li>pan-x/pan-y - enable single-finger horizontal/vertical  panning gestures. May be combined with pan-x/y, pan-up,pan-down/pan-left,pan-right and/or pinch-zoom</li>
      <li>manipulation - enable panning and pinch zoom gestures, but disable additional non-standard gestures such as double-tap to zoom. Disabling double-tap to zoom removes the need for browsers to delay the generation of click events when the user taps the screen (alias for "pan-x pan-y pinch-zoom" (which, for compatibility, is itself still valid))</li>
      <li>pan-left, pan-right, pan-up, pan-down - enable single-finger gestures that begin by scrolling in the given direction(s). Once scrolling has started, the direction may still be reversed. Note that scrolling "up" (pan-up) means that the user is dragging their finger downward on the screen surface, and likewise pan-left means the user is dragging their finger to the right. Multiple directions may be combined except when there is a simpler representation (for example, "pan-left pan-right" is invalid since "pan-x" is simpler, but "pan-left pan-down" is valid)</li>
      <li>pinch-zoom - enable multi-finger panning and zooming of the page. This may be combined with any of the pan- values</li>
    </ul>
    </li>
  </ul>

  <table style="margin-left:1em;">
  <caption>various device button states</caption>
  <tbody>
    <tr>
    <th>Device Button State</th>
    <th>button</th>
    <th>buttons</th>
    </tr>
    <tr>
    <td>Mouse move with no buttons pressed</td>
    <td>-1</td>
    <td>0</td>
    </tr>
    <tr>
    <td>Left Mouse, Touch Contact, Pen contact (with no modifier buttons pressed)</td>
    <td>0</td>
    <td>1</td>
    </tr>
    <tr>
    <td>Middle Mouse</td>
    <td>1</td>
    <td>4</td>
    </tr>
    <tr>
    <td>Right Mouse, Pen contact with barrel button pressed</td>
    <td>2</td>
    <td>2</td>
    </tr>
    <tr>
    <td>X1 (back) Mouse</td>
    <td>3</td>
    <td>8</td>
    </tr>
    <tr>
    <td>X2 (forward) Mouse</td>
    <td>4</td>
    <td>16</td>
    </tr>
    <tr>
    <td>Pen contact with eraser button pressed</td>
    <td>5</td>
    <td>32</td>
    </tr>
  </tbody>
  </table>

  <div id="pointer_test" class="example w-50 h-50">

    <div id="pointer_test_inner" class="example w-80 h-40">
    Interact for changes
    </div>

  </div>

  <div id="pointer_test_result" class="example w-50 h-50"></div>

  <script>
    var pointer_test = document.getElementById("pointer_test");
    var pointer_test_inner = document.getElementById("pointer_test_inner");
    var pointer_test_result = document.getElementById("pointer_test_result");

    pointer_test.addEventListener("pointerenter", pointerFunction);
    pointer_test.addEventListener("pointerover", pointerFunction);
    pointer_test.addEventListener("pointermove", pointerFunction);
    pointer_test.addEventListener("pointerdown", pointerFunction);
    pointer_test.addEventListener("pointerup", pointerFunction);
    pointer_test.addEventListener("pointercancel", pointerFunction);
    pointer_test.addEventListener("pointerout", pointerFunction);
    pointer_test.addEventListener("pointerleave", pointerFunction);
    pointer_test.addEventListener("gotpointercapture", pointerFunction);
    pointer_test.addEventListener("lostpointercapture", pointerFunction);

    var prev_action = "";
    function pointerFunction(e) {
      if (prev_action != e.type) {
        pointer_test_inner.innerHTML = e.type + "<br>" + pointer_test_inner.innerHTML;
        if(e.type == "pointerleave" || e.type == "pointerout") {
          pointer_test_inner.innerHTML = "------------<br>" + pointer_test_inner.innerHTML;
        }
      }
      pointer_test_result.innerHTML = "e.type: " + e.type + "<br>" +
      "-----------------------------------------------<br>" +
      "e.target.id: " + e.target.id + "<br>" +
      "-----------------------------------------------<br>" +
      "e.pointerType: " + (e.pointerType?e.pointerType:"unsuported") + "<br>" +
      "e.pointerId: " + e.pointerId + "<br>" +
      "e.isPrimary: " + e.isPrimary + "<br>" +
      "e.width: " + e.width + "<br>" +
      "e.height: " + e.height + "<br>" +
      "e.width*e.height: " + (e.width*e.height) + "<br>" +
      "e.pressure: " + e.pressure + "<br>" +
      "e.tiltX: " + e.tiltX + "<br>" +
      "e.tiltY: " + e.tiltY + "<br>" +
      "-----------------------------------------------<br>" +
      "e.screenX: " + e.screenX + "<br>" +
      "e.screenY: " + e.screenY + "<br>" +
      "-----------------------------------------------<br>" +
      "e.clientX: " + e.clientX + "<br>" +
      "e.clientY: " + e.clientY + "<br>" +
      "-----------------------------------------------<br>" +
      "e.pageX: " + e.pageX + "<br>" +
      "e.pageY: " + e.pageY + "<br>" +
      "-----------------------------------------------<br>" +
      "e.offsetX: " + e.offsetX + "<br>" +
      "e.offsetY: " + e.offsetY + "<br>" +
      "-----------------------------------------------<br>" +
      "e.movementX: " + e.movementX + "<br>" +
      "e.movementY: " + e.movementY + "<br>" +
      "-----------------------------------------------<br>" +
      "e.altKey: " + e.altKey + "<br>" +
      "e.ctrlKey: " + e.ctrlKey + "<br>" +
      "e.shiftKey: " + e.shiftKey + "<br>" +
      "e.metaKey: " + e.metaKey + "<br>" +
      "e.getModifierState('Shift'): " + e.getModifierState('Shift') + "<br>" +
      "e.button: " + e.button + "<br>" +
      "e.buttons: " + e.buttons + "<br>" +
      "-----------------------------------------------<br>" +
      "e.region: " + e.region + "<br>" +
      "e.relatedTarget: " + e.relatedTarget + "<br>" +
      "e.which: " + e.which + "<br>";
      var x = e.which || e.keyCode;
      if (x == 27) {  // 27 is the ESC key
          alert ("You pressed the Escape key!");
      }
      prev_action = e.type;
    }
  </script>

  <pre><code class="javascript">
    var pointer_test = document.getElementById("pointer_test");
    var pointer_test_inner = document.getElementById("pointer_test_inner");
    var pointer_test_result = document.getElementById("pointer_test_result");

    pointer_test.addEventListener("pointerenter", pointerFunction);
    pointer_test.addEventListener("pointerover", pointerFunction);
    pointer_test.addEventListener("pointermove", pointerFunction);
    pointer_test.addEventListener("pointerdown", pointerFunction);
    pointer_test.addEventListener("pointerup", pointerFunction);
    pointer_test.addEventListener("pointercancel", pointerFunction);
    pointer_test.addEventListener("pointerout", pointerFunction);
    pointer_test.addEventListener("pointerleave", pointerFunction);
    pointer_test.addEventListener("gotpointercapture", pointerFunction);
    pointer_test.addEventListener("lostpointercapture", pointerFunction);

    var prev_action = "";
    function pointerFunction(e) {
      if (prev_action != e.type) {
        pointer_test_inner.innerHTML = e.type + pointer_test_inner.innerHTML;
        if(e.type == "pointerleave" || e.type == "pointerout") {
          pointer_test_inner.innerHTML = "------------" + pointer_test_inner.innerHTML;
        }
      }
      pointer_test_result.innerHTML = "e.type: " + e.type +
      "e.target.id: " + e.target.id +
      "e.pointerType: " + (e.pointerType?e.pointerType:"unsuported") +
      "e.pointerId: " + e.pointerId +
      "e.isPrimary: " + e.isPrimary +
      "e.width: " + e.width +
      "e.height: " + e.height +
      "e.width*e.height: " + (e.width*e.height) +
      "e.pressure: " + e.pressure +
      "e.tiltX: " + e.tiltX +
      "e.tiltY: " + e.tiltY +
      "e.screenX: " + e.screenX +
      "e.screenY: " + e.screenY +
      "e.clientX: " + e.clientX +
      "e.clientY: " + e.clientY +
      "e.pageX: " + e.pageX +
      "e.pageY: " + e.pageY +
      "e.offsetX: " + e.offsetX +
      "e.offsetY: " + e.offsetY +
      "e.movementX: " + e.movementX +
      "e.movementY: " + e.movementY +
      "e.altKey: " + e.altKey +
      "e.ctrlKey: " + e.ctrlKey +
      "e.shiftKey: " + e.shiftKey +
      "e.metaKey: " + e.metaKey +
      "e.getModifierState('Shift'): " + e.getModifierState('Shift') +
      "e.button: " + e.button +
      "e.buttons: " + e.buttons +
      "e.region: " + e.region +
      "e.relatedTarget: " + e.relatedTarget +
      "e.which: " + e.which;
      var x = e.which || e.keyCode;
      if (x == 27) {  // 27 is the ESC key
          alert ("You pressed the Escape key!");
      }
      prev_action = e.type;
    }

    function downHandler(ev) {
      var el=document.getElementById("target");
      // Element "target" will receive/capture further events
      el.setPointerCapture(ev.pointerId);
    }
    function cancelHandler(ev) {
      var el=document.getElementById("target");
      // Release the pointer capture
      el.releasePointerCapture(ev.pointerId);
    }
    function init() {
      var el=document.getElementById("target");
      // Register pointerdown and pointercancel handlers
      el.onpointerdown = downHandler;
      el.onpointercancel = cancelHandler;
    }
  </code></pre>



<h2 id="input">InputEvent</h2>

  <ul>
    <li>events that occur when an form element's content changes (<strong>input</strong> and <strong>textarea</strong>), belongs to the InputEvent Object</li>
    <li>properties and methods
    <ul>
      <li>data - inserted characters</li>
      <li>dataTransfer - object containing information about the inserted/deleted data</li>
      <li>getTargetRanges() - array containing target ranges that will be affected by the insertion/deletion</li>
      <li>inputType - type of the change (i.e "inserting" or "deleting")</li>
      <li>isComposing [returns:true/false] - whether the state of the event is composing or not</li>
      <li>inherits all the properties and methods from <strong>UiEvent</strong> and <strong>Event</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>input - when an element gets user input</li>
    </ul>
    </li>
    <li>event is similar to the onchange event, difference is that the oninput <strong>event occurs immediately after the value of an element has changed</strong>, while onchange occurs when the element loses focus, after the content has been changed, other difference is that the onchange event also works on select-elements</li>
  </ul>

  <div  class="example w-50 h-20">
    <input
      id="input_test"
      type="text"
      value="Modify This Content"
      class="tests-input"
    />
  </div>

  <div id="input_test_result" class="example w-50 h-20"></div>

  <script>
    var input_test = document.getElementById("input_test");
    var input_test_result = document.getElementById("input_test_result");
    input_test.addEventListener("input", inputFunction);
    function inputFunction(event) {
      input_test_result.innerHTML += "event.data: " + event.data + "<br>" +
      "event.dataTransfer: " + event.dataTransfer + "<br>" +
      // "event.getTargetRanges: " + event.getTargetRanges().toString() + "<br>" +
      "event.inputType: " + event.inputType + "<br>" +
      "-----------------------------------------------<br>";
    }
  </script>

  <pre><code class="javascript">
    var input_test = document.getElementById("input_test");
    var input_test_result = document.getElementById("input_test_result");
    input_test.addEventListener("input", inputFunction);
    function inputFunction(event) {
      input_test_result.innerHTML += "event.data: " + event.data +
      "event.dataTransfer: " + event.dataTransfer +
      // "event.getTargetRanges: " + event.getTargetRanges().toString() +
      "event.inputType: " + event.inputType +
      "-----------------------------------------------";
    }
  </code></pre>



<h2 id="focus">FocusEvent</h2>

  <ul>
    <li>events that occur when elements gets or loses focus, belongs to the FocusEvent Object</li>
    <li>properties and methods
    <ul>
      <li>relatedTarget - element related to the element that triggered the event
      <ul>
        <li>focus and focusin - element that LOST focus</li>
        <li>blur and focusout - element is the element that GOT focus</li>
      </ul>
      </li>
      <li>inherits all the properties and methods from <strong>UiEvent</strong> and <strong>Event</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>focusin - when an element is about to get focus</li>
      <li>focus - when an element gets focus</li>
      <li>focusout - when an element is about to lose focus</li>
      <li>blur - when an element loses focus (does not bubble)</li>
    </ul>
    </li>
    <li>focusout event is the opposite of the focusin event</li>
    <li>if you want to find out whether an element or its child loses focus, you should use the focusout event</li>
  </ul>

  <div class="example w-50 h-20">
    <input
      id="focus_test_1"
      type="text"
      value="focus_test_1"
      class="tests-input"
    />
    </br>
    <input
      id="focus_test_2"
      type="text"
      value="focus_tests_target"
      class="tests-input"
    />
    </br>
    <input
      id="focus_test_3"
      type="text"
      value="focus_test_3"
      class="tests-input"
    />
  </div>

  <div id="focus_test_result" class="example w-50 h-20">
  </div>

  <script>
    var focus_test = document.getElementById("focus_test_2");
    var focus_test_result = document.getElementById("focus_test_result");

    focus_test.addEventListener("focusin", focusFunction);
    focus_test.addEventListener("focus", focusFunction, true);
    focus_test.addEventListener("focusout", focusFunction);
    focus_test.addEventListener("blur", focusFunction, true);

    function focusFunction(event) {
      focus_test_result.innerHTML += "<strong>"+event.type+"</strong>:<br>" +
      "relatedTarget: " + event.relatedTarget.id + "<br>" +
      "target: " +  event.target.id + "<br>";
    }
  </script>

  <pre><code class="javascript">
    var focus_test = document.getElementById("focus_test_2");
    var focus_test_result = document.getElementById("focus_test_result");

    focus_test.addEventListener("focusin", focusFunction);
    focus_test.addEventListener("focus", focusFunction, true);
    focus_test.addEventListener("focusout", focusFunction);
    focus_test.addEventListener("blur", focusFunction, true);

    function focusFunction(event) {
      focus_test_result.innerHTML += event.type+
        "relatedTarget: " + event.relatedTarget.id +
        "target: " +  event.target.id;
    }
  </code></pre>



<h2 id="clipboard">ClipboardEvent</h2>

  <ul>
    <li>events that occur when the clipboard is modified, belongs to the ClipboardEvent Object</li>
    <li>properties and methods
    <ul>
      <li>clipboardData - object containing the data affected by the clipboard operation</li>
      <li>inherits all the properties and methods from <strong>Event</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>copy - when the user copies the content of an element</li>
      <li>cut - when the user cuts the content of an element</li>
      <li>paste - when the user pastes some content in an element</li>
    </ul>
    </li>
  </ul>


  <div class="example w-50 h_5">
    <input
      id="clipboard_test"
      type="text"
      value="Copy, Cut, Paste values"
      class="tests-input"
    />
  </div>
  <div class="example w-50 h_5">
    <span id="clipboard_test_result"></span>
  </div>

  <script>
    var clipboard_test = document.getElementById("clipboard_test");
    clipboard_test.addEventListener("copy", clipboardFunction);
    clipboard_test.addEventListener("cut", clipboardFunction);
    clipboard_test.addEventListener("paste", clipboardFunction);
    var clipboard_test_result = document.getElementById("clipboard_test_result");
    function clipboardFunction(event) {
        clipboard_test_result.innerHTML = event.type;
    }
  </script>

  <pre><code class="html">
    &lt;input
      id="clipboard_test"
      type="text"
      value="Copy, Cut, Paste values"
    /&gt;
     &lt;span id="clipboard_test_result"&gt;&lt;/span&gt;
  </code></pre>

  <pre><code class="javascript">
    var clipboard_test = document.getElementById("clipboard_test");
    clipboard_test.addEventListener("copy", clipboardFunction);
    clipboard_test.addEventListener("cut", clipboardFunction);
    clipboard_test.addEventListener("paste", clipboardFunction);
    var clipboard_test_result = document.getElementById("clipboard_test_result");
    function clipboardFunction(event) {
        clipboard_test_result.innerHTML = event.type;
    }
  </code></pre>



<h2 id="drag">DragEvent</h2>

  <ul>
    <li>events that occur when elements are dragged and/or dropped, belongs to the DragEvent Object</li>
    <li>properties and methods
    <ul>
      <li>dataTransfer - data that is dragged/dropped</li>
      <li>inherits all the properties and methods from <strong>MouseEvent</strong> and <strong>Event</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>dragstart - when the user starts to drag an element</li>
      <li>drag - when an element is being dragged (fires every 350 milliseconds)</li>
      <li>dragenter - when the dragged element enters the drop target</li>
      <li>dragover - when the dragged element is over the drop target (fires every 350 milliseconds)</li>
      <li>dragleave - when the dragged element leaves the drop target</li>
      <li>dragend - when the user has finished dragging an element</li>
      <li>drop - when the dragged element is dropped on the drop target</li>
    </ul>
    </li>
  </ul>

  <style>
    .dragtarget {
      margin: 5px;
      padding: 5px;
      /*padding: 20px;*/
      border: 1px solid #aaaaaa;
      cursor: pointer;
    }
  </style>

  <div
    id="droptarget_1"
    class="droptarget example w-50 h-15"
    ondragenter="dragEnter(event)"
    ondragover="dragOver(event)"
    ondragleave="dragLeave(event)"
    ondrop="drop(event)"
  >
    <div
      id="dragtarget_1"
      class="dragtarget"
      draggable="true"
      ondragstart="dragStart(event)"
      ondrag="dragging(event)"
      ondragend="dragEnd(event)"
    >Dragable_1</div>
    <div
      id="dragtarget_2"
      class="dragtarget"
      draggable="true"
      ondragstart="dragStart(event)"
      ondrag="dragging(event)"
      ondragend="dragEnd(event)"
    >Dragable_2</div>
  </div>

  <div
    id="droptarget_2"
    class="droptarget example w-50 h-15"
    ondragenter="dragEnter(event)"
    ondragover="dragOver(event)"
    ondragleave="dragLeave(event)"
    ondrop="drop(event)"
  >
    <div
      id="dragtarget_3"
      class="dragtarget"
      draggable="true"
      ondragstart="dragStart(event)"
      ondrag="dragging(event)"
      ondragend="dragEnd(event)"
    >Dragable_3</div>
  </div>

  <div id="drag_info" class="example w-50 h-15"></div>
  <div id="drag_info_2" class="example w-50 h-15"></div>

  <script>
    var drag_info = document.getElementById("drag_info");
    var drag_info_2 = document.getElementById("drag_info_2");

    // dragable element
    function dragStart(event) {
        // set data type and the value of the dragged data
        event.dataTransfer.setData("Text", event.target.id);
        drag_info_2.innerHTML = event.target.id+" drag started";
        event.target.style.opacity = "0.4";
    }
    function dragging(event) {
        //drag_info.innerHTML += "element is dragged<br>";
        drag_info_2.innerHTML = event.target.id+" element is draged";
        drag_info_2.style.color = "red";
    }
    function dragEnd(event) {
        drag_info.innerHTML += event.target.id+" drag ended<br>";
        drag_info_2.innerHTML = event.target.id+" drag ended";
        event.target.style.opacity = "1";
    }

    // containers
    function dragEnter(event) {
        drag_info.innerHTML += event.target.id+" container entrance<br>";
        drag_info_2.innerHTML = event.target.id+" container entrance";
        if ( event.target.className == "droptarget" ) {
          event.target.style.border = "3px dotted red";
        }
    }
    function dragOver(event) {
        // allow drop inside element (disabled by default for data/elements)
        event.preventDefault();
        //drag_info.innerHTML += "element dragging is over<br>";
        drag_info_2.innerHTML = event.target.id+" is under draggable";
    }
    function dragLeave(event) {
        event.preventDefault();
        drag_info.innerHTML += event.target.id+" out of container<br>";
        drag_info_2.innerHTML = event.target.id+" out of container";
        if ( event.target.className == "droptarget" ) {
          event.target.style.border = "";
        }
    }
    function drop(event) {
      // prevent default handling (open as link on drop) of the data
      event.preventDefault();
      drag_info.innerHTML += event.target.id+" received dragable<br>";
      drag_info_2.innerHTML = event.target.id+" received dragable";
      // if ( event.target.className == "droptarget" ) {
        drag_info_2.style.color = "";
        event.target.style.border = "";
        // get dragged data with the dataTransfer.getData() method
        var data = event.dataTransfer.getData("Text");
        // append the dragged element into the drop element
        event.target.appendChild(document.getElementById(data));
      // }
    }
  </script>

  <pre>
  <code class="html">
    &lt;div
      class="droptarget"
      ondragenter="dragEnter(event)"
      ondragover="dragOver(event)"
      ondragleave="dragLeave(event)"
      ondrop="drop(event)"
      style="width:200px;height:300px"
    &gt;
        &lt;div
          id="dragtarget_1"
          class="dragtarget"
          draggable="true"
          ondragstart="dragStart(event)"
          ondrag="dragging(event)"
          ondragend="dragEnd(event)"
        &gt;Dragable_1&lt;/div&gt;

        // dragable elements ?

    &lt;/div&gt;

    &lt;div
      class="droptarget"
      ondragenter="dragEnter(event)"
      ondragover="dragOver(event)"
      ondragleave="dragLeave(event)"
      ondrop="drop(event)"
      style="width:200px;height:300px"
    &gt;

        // dragable elements ?

    &lt;/div&gt;
  </code></pre>

  <pre><code class="javascript">
    var drag_info = document.getElementById("drag_info");
    var drag_info_2 = document.getElementById("drag_info_2");

    // dragable element
    function dragStart(event) {
        // set data type and the value of the dragged data
        event.dataTransfer.setData("Text", event.target.id);
        drag_info_2.innerHTML = event.target.id+" drag started";
        event.target.style.opacity = "0.4";
    }
    function dragging(event) {
        //drag_info.innerHTML += "element is dragged";
        drag_info_2.innerHTML = event.target.id+" element is draged";
        drag_info_2.style.color = "red";
    }
    function dragEnd(event) {
        drag_info.innerHTML += event.target.id+" drag ended";
        drag_info_2.innerHTML = event.target.id+" drag ended";
        event.target.style.opacity = "1";
    }

    // containers
    function dragEnter(event) {
        drag_info.innerHTML += event.target.id+" container entrance";
        drag_info_2.innerHTML = event.target.id+" container entrance";
        if ( event.target.className == "droptarget" ) {
          event.target.style.border = "3px dotted red";
        }
    }
    function dragOver(event) {
        // allow drop inside element (disabled by default for data/elements)
        event.preventDefault();
        //drag_info.innerHTML += "element dragging is over";
        drag_info_2.innerHTML = event.target.id+" is under draggable";
    }
    function dragLeave(event) {
        event.preventDefault();
        drag_info.innerHTML += event.target.id+" out of container";
        drag_info_2.innerHTML = event.target.id+" out of container";
        if ( event.target.className == "droptarget" ) {
          event.target.style.border = "";
        }
    }
    function drop(event) {
      // prevent default handling (open as link on drop) of the data
      event.preventDefault();
      drag_info.innerHTML += event.target.id+" received dragable";
      drag_info_2.innerHTML = event.target.id+" received dragable";
      if ( event.target.className == "droptarget" ) {
        drag_info_2.style.color = "";
        event.target.style.border = "";
        // get dragged data with the dataTransfer.getData() method
        var data = event.dataTransfer.getData("Text");
        // append the dragged element into the drop element
        event.target.appendChild(document.getElementById(data));
      }
    }
  </code></pre>



<h2 id="progress">ProgressEvent</h2>

  <ul>
    <li>events that occur when loading external resources, belongs to the ProgressEvent Object</li>
    <li>properties and methods
    <ul>
      <li>lengthComputable - whether the length of the progress can be computable or not</li>
      <li>loaded - how much work has been loaded</li>
      <li>total - total amount of work that will be loaded</li>
      <li>inherits all the properties and methods from <strong>Event</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>error - when an error occurs while loading an external file </li>
      <li>loadstart - when the browser starts looking for the specified media</li>
    </ul>
    </li>
    <li>see <strong>Event</strong> object for examples</li>
  </ul>



<h2 id="transition">TransitionEvent</h2>

  <ul>
    <li>events that occur when a CSS transition runs, belongs to the TransitionEvent Object</li>
    <li>properties and methods
    <ul>
      <li>propertyName - name of the transition</li>
      <li>elapsedTime - number of seconds a transition has been running</li>
      <li>pseudoElement - name of the pseudo-element of the transition</li>
      <li>inherits all the properties and methods from <strong>Event</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>transitionend(webkitTransitionEnd|mozTransitionEnd|oTransitionEnd) - when a CSS transition has completed</li>
      <li>transitioncancel(webkitTransitionEnd|mozTransitionEnd|oTransitionEnd) - when a CSS transition is canceled: value of the transition-property property is changed, display property is set to "none", transition is stopped before it has run to completion, like moving the mouse off a hover-transitioning element</li>
    </ul>
    </li>
    <li>if the transition is removed before completion, e.g. if the CSS transition-property property is removed, the transitionend event will not fire</li>
  </ul>

  <style>
    #transition_test {
      width: 30%;
      height: 200px;
      background: red;
      padding:1em;
      overflow: auto;
      -webkit-transition: all 1.5s;
      transition: all 1.5s;
    }
    #transition_test:hover {
      width: 90%;
      opacity: 0.7;
      background: dodgerblue;
    }
  </style>

  <div class="example">
    <div id="transition_test">Hover for changes</div>
  </div>

  <script>
    var transition_test = document.getElementById("transition_test");

    transition_test.addEventListener("transitionend", transitionFunction);
    transition_test.addEventListener("webkitTransitionEnd", transitionFunction);
    //transition_test.addEventListener("mozTransitionEnd", touchFunction);
    //transition_test.addEventListener("oTransitionEnd", touchFunction);

    transition_test.addEventListener("transitioncancel", transitionFunction);

    function transitionFunction(e) {
      transition_test.innerHTML = "e.type: " + e.type + "<br>" +
      "e.propertyName: " + e.propertyName + "<br>" +
      "e.elapsedTime: " + e.elapsedTime + "<br>" +
      "e.pseudoElement: " + e.pseudoElement + "<br>";
    }
  </script>

  <pre><code class="css">
    #transition_test {
      width: 100px;
      height: 100px;
      background: red;
      padding:1em;
      -webkit-transition: all 1s; /* For Safari 3.1 to 6.0 */
      transition: all 1s;
    }
    #transition_test:hover {
      width: 400px;
      opacity: 0.3;
    }
  </code></pre>

  <pre><code class="javascript">
    var transition_test = document.getElementById("transition_test");

    transition_test.addEventListener("transitionend", transitionFunction);
    transition_test.addEventListener("webkitTransitionEnd", transitionFunction);
    //transition_test.addEventListener("mozTransitionEnd", touchFunction);
    //transition_test.addEventListener("oTransitionEnd", touchFunction);

    transition_test.addEventListener("transitioncancel", transitionFunction);

    function transitionFunction(e) {
      transition_test.innerHTML = "e.type: " + e.type +
      "e.propertyName: " + e.propertyName +
      "e.elapsedTime: " + e.elapsedTime +
      "e.pseudoElement: " + e.pseudoElement;
    }
  </code></pre>



<h2 id="animation">AnimationEvent</h2>

  <ul>
    <li>events that occur when a CSS animation runs, belongs to the AnimationEvent Object</li>
    <li>properties and methods
    <ul>
      <li>animationName - name of the animation</li>
      <li>elapsedTime - number of seconds an animation has been running</li>
      <li>pseudoElement - name of the pseudo-element of the animation</li>
      <li>inherits all the properties and methods from <strong>Event</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>animationend - when a CSS animation has completed</li>
      <li>animationiteration - when a CSS animation is repeated</li>
      <li>animationstart - when a CSS animation has started</li>
    </ul>
    </li>
  </ul>

  <div class="example">
    <div id="animation_test_div" onclick="test_div_move()">Click to start</div>
  </div>

  <style>
    #animation_test_div {
      width: 250px;
      height: 100px;
      background: orange;
      position: relative;
      font-size: 20px;
      padding:1em;
    }

    /* Chrome, Safari, Opera */
    @-webkit-keyframes my_test_div_move {
      from {left: 0px;}
      to {left: 200px;}
    }

    @keyframes my_test_div_move {
      from {left: 0px;}
      to {left: 200px;}
    }
  </style>

  <script>
    var animation_test_div = document.getElementById("animation_test_div");

    // Start the animation with JavaScript
    function test_div_move() {
      animation_test_div.style.WebkitAnimation = "my_test_div_move 2s 5"; // Code for Chrome, Safari and Opera
      animation_test_div.style.animation = "my_test_div_move 2s 5";       // Standard syntax
    }

    // Code for Chrome, Safari and Opera
    animation_test_div.addEventListener("webkitAnimationStart", animationStartFunction);
    animation_test_div.addEventListener("webkitAnimationIteration", animationRepeatFunction);
    animation_test_div.addEventListener("webkitAnimationEnd", animationEndFunction);
    // Standard syntax
    animation_test_div.addEventListener("animationstart", animationStartFunction);
    animation_test_div.addEventListener("animationiteration", animationRepeatFunction);
    animation_test_div.addEventListener("animationend", animationEndFunction);

    function animationStartFunction() {
      this.innerHTML = "animationstart";
      this.style.backgroundColor = "pink";
    }
    var iteration = 1;
    function animationRepeatFunction(event) {
      iteration++;
      this.innerHTML = "animationiteration: " + iteration+
        "</br> elapsed: " + event.elapsedTime + " seconds";
      this.style.backgroundColor = "lightblue";
    }
    function animationEndFunction() {
      this.innerHTML = "animationend";
      this.style.backgroundColor = "lightgray";
    }
  </script>

  <pre><code class="css">
    #animation_test_div {
      width: 250px;
      height: 100px;
      background: orange;
      position: relative;
      font-size: 20px;
      padding:1em;
    }

    /* Chrome, Safari, Opera */
    @-webkit-keyframes my_test_div_move {
      from {left: 0px;}
      to {left: 200px;}
    }

    @keyframes my_test_div_move {
      from {left: 0px;}
      to {left: 200px;}
    }
  </code></pre>

  <pre><code class="javascript">
    var animation_test_div = document.getElementById("animation_test_div");

    // Start the animation with JavaScript
    function test_div_move() {
      // Chrome, Safari and Opera
      animation_test_div.style.WebkitAnimation = "my_test_div_move 4s 5";
      // standard syntax
      animation_test_div.style.animation = "my_test_div_move 4s 5";
    }

    // Code for Chrome, Safari and Opera
    animation_test_div.addEventListener("webkitAnimationStart", myStartFunction);
    animation_test_div.addEventListener("webkitAnimationIteration", myRepeatFunction);
    animation_test_div.addEventListener("webkitAnimationEnd", myEndFunction);
    // Standard syntax
    animation_test_div.addEventListener("animationstart", myStartFunction);
    animation_test_div.addEventListener("animationiteration", myRepeatFunction);
    animation_test_div.addEventListener("animationend", myEndFunction);

    function myStartFunction() {
      this.innerHTML = "animationstart";
      this.style.backgroundColor = "pink";
    }
    var iteration = 1;
    function myRepeatFunction(event) {
      iteration++;
      this.innerHTML = "animationiteration: " + iteration +
        ", elapsed: " + event.elapsedTime + " seconds";
      this.style.backgroundColor = "lightblue";
    }
    function myEndFunction() {
      this.innerHTML = "animationend";
      this.style.backgroundColor = "lightgray";
    }
  </code></pre>



<h2 id="hash">HashChangeEvent</h2>

  <ul>
    <li>events that occur when the anchor part of the URL changes (begins with a '#' symbol), belongs to the HashChange Event Object</li>
    <li>properties and methods
    <ul>
      <li>newURL - URL of the document, after the hash has been changed</li>
      <li>oldURL - URL of the document, before the hash was changed</li>
      <li>inherits all the properties and methods from <strong>Event</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>hashchange - when there has been changes to the anchor part of a URL</li>
    </ul>
    </li>
    <li>event invokation
    <ul>
      <li>change the anchor part by setting the <strong>location.hash</strong> or <strong>location.href</strong> property of the Location Object</li>
      <li>navigate to the current page with a different bookmark (Use the "back" or "forward" buttons)</li>
      <li>click on a link to a bookmark anchor</li>
    </ul>
  </ul>

  <div id="hash_test_result" class="example h-20">
    <h5>change page hash (# anchor in tab link, or select other links in this chapter) to see changes</h5>
  </div>

  <script type="text/javascript">
    // window.onhashchange = hashFunction;
    function hashFunction(event) {
      document.getElementById("hash_test_result").innerHTML += "location.hash: " + location.hash + "<br>" +
      "event.newURL: " + event.newURL + "<br>" +
      "event.oldURL: " + event.oldURL + "<br>" +
      "-----------------------------------------------<br>";
    }
  </script>

  <pre><code class="html">
    &lt;body onhashchange="hashFunction(event)"&gt;
  </code></pre>

  <pre><code class="javascript">
    // window.onhashchange = hashFunction;
    function hashFunction(event) {
      document.getElementById("hash_test_result").innerHTML += "location.hash: " + location.hash +
      "event.newURL: " + event.newURL +
      "event.oldURL: " + event.oldURL +
      "-----------------------------------------------";
    }
  </code></pre>



<h2 id="pagetransition">PageTransitionEvent</h2>

  <ul>
    <li>events that occur when user navigates to, and away from, a webpage</li>
    <li>properties and methods
    <ul>
      <li>persisted [returns:true/false] - whether the webpage was cached by the browser or loaded rom server</li>
      <li>inherits all the properties and methods from <strong>Event</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>pagehide - when the user navigates away from a webpage (clicking on a link, refreshing the page, submitting a form, closing the browser window, etc.)</li>
      <li>pageshow - when the user navigates to a webpage</li>
    </ul>
    </li>
    <li>pageshow event is similar to the onload event, except that it <strong>occurs after the onload event when the page first loads</strong>, every time the page is loaded, whereas the onload event does not occur when the page is loaded from the cache</li>
  </ul>

  <script>
    window.addEventListener("pageshow", transitionFunction);
    window.addEventListener("pagehide", transitionFunction);
    function transitionFunction(e) {
      //console.log(["e.type: "+e.type,"e.persisted: "+e.persisted]);
    }
  </script>

  <pre><code class="javascript">
    window.addEventListener("pageshow", transitionFunction);
    window.addEventListener("pagehide", transitionFunction);
    function transitionFunction(e) {
      console.log(["e.type: "+e.type,"e.persisted: "+e.persisted]);
    }
  </code></pre>



<h2 id="pop">PopStateEvent</h2>

  <ul>
    <li>events that occur when active history entry changes between two history entries for the same document</li>
    <li>properties and methods
    <ul>
      <li>state - object containing a copy of the history entries</li>
      <li>inherits all the properties and methods from <strong>Event</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>popstate - when the window's history changes</li>
    </ul>
    </li>
    <li>just calling history.pushState() or history.replaceState() won't trigger a popstate event, it is only triggered by doing a browser action such as a clicking on the back button (or calling history.back() in JavaScript)</li>
  </ul>

  <pre><code class="javascript">
    window.onpopstate = function(event) {
      console.log([
        "location: " + document.location,
        "state: " + JSON.stringify(event.state)
      ]);
    };

    history.pushState({page: 1}, "keyboard", "#keyboard");
    history.pushState({page: 2}, "mouse", "#mouse");
    history.replaceState({page: 3}, "pop", "#pop");
    history.back();
    history.back();
    history.go(2);
  </code></pre>



<h2 id="storage">StorageEvent</h2>

  <ul>
    <li>events that occur when there is changes in the window's storage area</li>
    <li>properties and methods
    <ul>
      <li>key - key of the changed storage item</li>
      <li>newValue - new value of the changed storage item</li>
      <li>oldValue - old value of the changed storage item</li>
      <li>storageArea - an object representing the affected storage object</li>
      <li>url - URL of the changed item's document</li>
      <li>inherits all the properties and methods from <strong>Event</strong> Object</li>
    </ul>
    </li>
    <li>types
    <ul>
      <li>storage - when a Web Storage area is updated, only triggered <strong>when a window other than itself makes the changes</strong> (like in example)</li>
    </ul>
    </li>
  </ul>

  <div
    id="storage_test"
    onclick="storageValue()"
    class="example w-50 h-10"
  >Click to Change a Storage Item</div>

  <div id="storage_test_result" class="example w-50 h-10"></div>

  <script>
    var storage_test_result = document.getElementById("storage_test_result");
    window.addEventListener("storage", storageFunction);
    function storageFunction(e) {
      storage_test_result.innerHTML = "e.key: " + e.key + "<br>" +
      "e.newValue: " + e.newValue + "<br>" +
      "e.oldValue: " + e.oldValue + "<br>" +
      "e.storageArea: " + e.storageArea + "<br>" +
      "e.url: " + e.url;
    }
    function storageValue() {
      var w = window.open("", "myWindow", "width=200,height=100");
      if (w.localStorage.clickcount) {
        w.localStorage.clickcount = Number(w.localStorage.clickcount)+1;
      } else {
        w.localStorage.clickcount = 1;
      }
      w.close();
    }
  </script>

  <pre><code class="javascript">
    var storage_test_result = document.getElementById("storage_test_result");
    window.addEventListener("storage", storageFunction);
    function storageFunction(e) {
      storage_test_result.innerHTML = "e.key: " + e.key +
      "e.newValue: " + e.newValue +
      "e.oldValue: " + e.oldValue +
      "e.storageArea: " + e.storageArea +
      "e.url: " + e.url;
    }
    function storageValue() {
      var w = window.open("", "myWindow", "width=200,height=100");
      if (w.localStorage.clickcount) {
        w.localStorage.clickcount = Number(w.localStorage.clickcount)+1;
      } else {
        w.localStorage.clickcount = 1;
      }
      w.close();
    }
  </code></pre>



<h2 id="custom">Custom events</h3>

  <pre><code class="javascript">
    var event = new Event('build');
    // Listen for the event.
    elem.addEventListener('build', function (e) { /* ... */ }, false);
    // Dispatch the event.
    elem.dispatchEvent(event);

    // Adding custom data â€“ CustomEvent()
    var event = new CustomEvent(
      'build',
      { detail: elem.dataset.time }
    );
    function eventHandler(e) {
      console.log('The time is: ' + e.detail);
    }

    // The old-fashioned way
    // Create the event.
    var event = document.createEvent('Event');
    // Define that the event name is 'build'.
    event.initEvent('build', true, true);
    // Listen for the event.
    elem.addEventListener('build', function (e) {
      // e.target matches elem
    }, false);
    // target can be any Element or other EventTarget.
    elem.dispatchEvent(event);

    // Event bubbling
    &lt;form&gt;
    &lt;textarea&gt;&lt;/textarea&gt;
    &lt;//form&gt;
    // -----
    const form = document.querySelector('form');
    const textarea = document.querySelector('textarea');
    // Create a new event, allow bubbling
    // and provide any data you want to pass to the "details" property
    const eventAwesome = new CustomEvent('awesome', {
      bubbles: true,
      detail: { text: () => textarea.value }
    });
    // The form element listens for the custom "awesome" event
    // and then consoles the output of the passed text() method
    form.addEventListener('awesome', e => console.log(e.detail.text()));
    // As the user types, textarea inside the form dispatches/triggers the event to fire
    // and uses itself as the starting point
    textarea.addEventListener('input', e => e.target.dispatchEvent(eventAwesome));
  </code></pre>



<h2 id="sel">Selection/Range</h2>

  <ul>
    <li><strong>Selection object</strong> represents the range of text selected by the user or the current position of the caret</li>
    <li>selection properties
    <ul>
      <li>anchorNode - Node in which the selection begins</li>
      <li>anchorOffset - number representing the offset of the selection's anchor within the anchorNode. If anchorNode is a text node, this is the number of characters within anchorNode preceding the anchor. If anchorNode is an element, this is the number of child nodes of the anchorNode preceding the anchor</li>
      <li>focusNode - Node in which the selection ends</li>
      <li>focusOffset - number representing the offset of the selection's anchor within the focusNode. If focusNode is a text node, this is the number of characters within focusNode preceding the focus. If focusNode is an element, this is the number of child nodes of the focusNode preceding the focus</li>
      <li>isCollapsed - Boolean indicating whether the selection's start and end points are at the same position</li>
      <li>rangeCount - number of ranges in the selection</li>
      <li>type - type of the current selection: None, Caret: selection is collapsed (i.e. caret is placed on some text but no range has been selected), Range</li>
    </ul>
    <li>selection methods
    <ul>
      <li>addRange(range) - Range object that will be added to the selection</li>
      <li>collapse(node,offset) - collapses the current selection to a single point</li>
      <li>collapseToEnd() - collapses the selection to the end of the last range in the selection</li>
      <li>collapseToStart() - collapses the selection to the start of the first range in the selection</li>
      <li>containsNode(node,partialContainment) - indicates if a certain node is part of the selection</li>
      <li>deleteFromDocument() - deletes the selection's content from the document</li>
      <li>extend(node,offset) - moves the focus of the selection to a specified point</li>
      <li>getRangeAt(index) - returns Range object representing one of the ranges currently selected</li>
      <li>modify( alter[move|extend], direction[forward|backward|left|right], granularity[character|word|sentence|line|paragraph | lineboundary|sentenceboundary|paragraphboundary|documentboundary] ) - changes the current selection</li>
      <li>removeRange(range) - removes a range from the selection</li>
      <li>removeAllRanges()|empty() - removes all ranges from the selection</li>
      <li>selectAllChildren(parentNode) - adds all the children of the specified node to the selection</li>
      <li>setBaseAndExtent(anchorNode,anchorOffset,focusNode,focusOffset) - sets the selection to be a range including all or parts of two specified DOM nodes, and any content located between them</li>
      <li>setPosition() - collapses the current selection to a single point. This is an alias for collapse() â€” See Selection.collapse() for more details</li>
      <li>toString() - returns a string currently being represented by the selection object, i.e. the currently selected text</li>
    </ul>
    <li><strong>Range interface</strong> represents a fragment of a document that can contain nodes and parts of text nodes, can be created using the createRange() method of the Document object, can also be retrieved by using the getRangeAt() method of the Selection object or the caretRangeFromPoint() method of the Document object, there also is the Range() constructor available</li>
    <li>range properties
      <ul>
        <li>collapsed - Boolean indicating whether the range's start and end points are at the same position</li>
        <li>commonAncestorContainer - deepest Node that contains the startContainer and endContainer nodes</li>
        <li>endContainer - Node within which the Range ends</li>
        <li>endOffset - number representing where in the endContainer the Range ends</li>
        <li>startContainer - Node within which the Range starts</li>
        <li>startOffset - number representing where in the startContainer the Range starts</li>
      </ul>
    </li>
    <li>range methods
      <ul>
        <li>setStart(startNode,startOffset) - sets the start position of a Range</li>
        <li>setEnd(endNode,endOffset) - sets the end position of a Range</li>
        <li>setStartBefore(refNode) - sets the start position of a Range relative to another Node</li>
        <li>setStartAfter(refNode) - sets the start position of a Range relative to another Node</li>
        <li>setEndBefore(refNode) - sets the end position of a Range relative to another Node</li>
        <li>setEndAfter(refNode) - sets the end position of a Range relative to another Node</li>
        <li>selectNode(refNode) - sets the Range to contain the Node and its contents</li>
        <li>selectNodeContents(refNode) - sets the Range to contain the contents of a Node</li>
        <li>collapse(toStart_bool) - collapses the Range to one of its boundary points</li>
        <li>cloneContents() - returns DocumentFragment copying the nodes of a Range</li>
        <li>deleteContents() - removes the contents of a Range from the Document</li>
        <li>extractContents() - moves contents of a Range from the document tree into a returned DocumentFragment</li>
        <li>insertNode(newNode) - insert a Node at the start of a Range</li>
        <li>surroundContents(newNode) - moves content of a Range into a new Node</li>
        <li>compareBoundaryPoints(how,sourceRange) - compares the boundary points of the Range with another Range</li>
        <li>cloneRange() - returns Range object with boundary points identical to the cloned Range</li>
        <li>detach() - releases the Range from use to improve performance</li>
        <li>toString() - text of the Range</li>
        <li>comparePoint(refNode,offset) - returns -1, 0, or 1 indicating whether the point occurs before, inside, or after the Range</li>
        <li>createContextualFragment(tagString) - returns DocumentFragment created from a given string of code</li>
        <li>getBoundingClientRect() - returns OMRect object which bounds the entire contents of the Range; this would be the union of all the rectangles returned by range.getClientRects()</li>
        <li>getClientRects() - list of DOMRect objects that aggregates the results of Element.getClientRects() for all the elements in the Range</li>
        <li>intersectsNode(refNode) - Boolean indicating whether the given node intersects the Range</li>
        <li>isPointInRange(refNode,offset) - Boolean indicating whether the given point is in the Range</li>
      </ul>
    </li>
    <li>new Range() - range constructor, with start and end as global Document object</li>
    <li>terminology
      <ul>
        <li>editing host - editable element (HTML element with contenteditable set on it, or the HTML child of a document that has designMode enabled)</li>
        <li>anchor - where the user began the selection</li>
        <li>focus - where the user ends the selection</li>
        <li>range - contiguous part of a document, contain entire nodes as well as portions of nodes, such as a portion of a text node, can be retrieved from a selection as a range object (which can also be created via the DOM and programmatically added or removed from a selection), it's possible for a user to select multiple ranges (e.g. by using the Control key)</li>
        <li>anchor and focus should not be confused with the start and end positions of a selection, depending on the direction you made your selection anchor can be placed before the focus or vice versa</li>
      </ul>
    </li>
  </ul>

  <div id="selection_tests_result" class="example h-50" style="font-size:0.8em;"></div>

  <script>
    var selection_tr = document.getElementById("selection_tests_result");
    var sel = window.getSelection();
    function selectionFunction () {
      selection_tr.innerHTML =
        "sel.toString(): " + sel.toString() + "<br>" +
        "sel.anchorNode.tagName: " + sel.anchorNode + "<br>" +
        "sel.anchorOffset: " + sel.anchorOffset + "<br>" +
        "sel.focusNode.tagName: " + sel.focusNode + "<br>" +
        "sel.focusOffset: " + sel.focusOffset + "<br>" +
        "sel.isCollapsed: " + sel.isCollapsed + "<br>" +
        "sel.type: " + sel.type + "<br>" +
        "sel.rangeCount: " + sel.rangeCount + "<br>";

        for (var i=0; i<sel.rangeCount; i++) {
          var rng = sel.getRangeAt(i);
          selection_tr.innerHTML += "---------------------<br>" +
            "rng["+i+"].toString(): " + rng.toString() + "<br>" +
            "rng["+i+"].collapsed: " + rng.collapsed + "<br>" +
            "rng["+i+"].startContainer: " + rng.startContainer +
            " - rng["+i+"].endContainer: " + rng.endContainer + "<br>" +
            "rng["+i+"].startOffset: " + rng.startOffset +
            " - rng["+i+"].endOffset: " + rng.endOffset + "<br>" +
            "rng["+i+"].cloneContents(): " + rng.cloneContents() + "<br>" +
            "rng["+i+"].cloneRange(): " + rng.cloneRange() + "<br>" +
            "rng["+i+"].getBoundingClientRect(): " + rng.getBoundingClientRect() + "<br>" +
            "rng["+i+"].getClientRects(): " + rng.getClientRects() + "<br>" +
            "rng["+i+"].commonAncestorContainer: " + rng.commonAncestorContainer + "<br>";
        }

    }
    setInterval(selectionFunction, 500);
  </script>

  <pre><code class="javascript">
    var selection_tr = document.getElementById("selection_tests_result");
    var sel = window.getSelection();
    function selectionFunction () {
      selection_tr.innerHTML =
        "sel.toString(): " + sel.toString() +
        "sel.anchorNode.tagName: " + sel.anchorNode +
        "sel.anchorOffset: " + sel.anchorOffset +
        "sel.focusNode.tagName: " + sel.focusNode +
        "sel.focusOffset: " + sel.focusOffset +
        "sel.isCollapsed: " + sel.isCollapsed +
        "sel.type: " + sel.type +
        "sel.rangeCount: " + sel.rangeCount;

        for (var i=0; i&lt;sel.rangeCount; i++) {
          var rng = sel.getRangeAt(i);
          selection_tr.innerHTML += "---------------------" +
            "rng["+i+"].toString(): " + rng.toString() +
            "rng["+i+"].collapsed: " + rng.collapsed +
            "rng["+i+"].startContainer: " + rng.startContainer +
            " - rng["+i+"].endContainer: " + rng.endContainer +
            "rng["+i+"].startOffset: " + rng.startOffset +
            " - rng["+i+"].endOffset: " + rng.endOffset +
            "rng["+i+"].cloneContents(): " + rng.cloneContents() +
            "rng["+i+"].cloneRange(): " + rng.cloneRange() +
            "rng["+i+"].getBoundingClientRect(): " + rng.getBoundingClientRect() +
            "rng["+i+"].getClientRects(): " + rng.getClientRects() +
            "rng["+i+"].commonAncestorContainer: " + rng.commonAncestorContainer;
        }

    }
    setInterval(selectionFunction, 500);
  </code></pre>



<h2 id="debth">Debounce/Throttle</h2>

  <ul>
    <li>prevent a function from being called too quickly or too many times in a row</li>
  </ul>

  <div id="moveonme" class="example h-30 w-20">mousemove/touchmove over this area</div>
  <canvas id="paintonme" class="example h-30 w-80"></canvas>

  <script>
    var helpers = {
      // debouncing, executes the function if there was no new event in $wait milliseconds
      debounce: function (func, wait, scope) {
        var timeout;
        return function () {
          var context = scope || this, args = arguments;
          var later = function () {
            timeout = null;
            func.apply(context, args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      },
      // in case of a "storm of events", this executes once every $threshold
      throttle: function (fn, threshhold, scope) {
        threshhold || (threshhold = 250);
        var last,
            deferTimer;
        return function () {
          var context = scope || this;
          var now = +new Date,
            args = arguments;
          if (last && now < last + threshhold) {
            // hold on to it
            clearTimeout(deferTimer);
            deferTimer = setTimeout(function () {
              last = now;
              fn.apply(context, args);
            }, threshhold);
          } else {
            last = now;
            fn.apply(context, args);
          }
        };
      }
    }

    function NIM_demo(){
      this.canvas =   document.getElementById("paintonme");
      this.context =  this.canvas.getContext("2d");
      this.movearea = document.getElementById("moveonme");
      this.canvasTimeScale = 5 * 1000;
      this.paintColors = ["#bbd","#464","#d88"];
      this.totalLanes =  this.paintColors.length;
      this.leftMargin = 100;
      var self = this;
      this.init = function(){
        this.canvas.width = window.innerWidth - 250;
        this.flush();
        this.movearea.addEventListener("mousemove",this.regularHandler);
        this.movearea.addEventListener("mousemove",helpers.debounce(self.debounceHandler,100,this));
        this.movearea.addEventListener("mousemove",helpers.throttle(self.throttleHander,100,this));

        this.movearea.addEventListener("touchmove",this.regularHandler);
        this.movearea.addEventListener("touchmove",helpers.debounce(self.debounceHandler,100,this));
        this.movearea.addEventListener("touchmove",helpers.throttle(self.throttleHander,100,this));
      }
      // painting the rectangle / line
      this.paintRect = function(lane,time){
        if(time > this.canvasTimeScale){
          this.startTime += time;
          time = 0;
          this.flush()
        }
        // console.log(lane,time);
        this.context.fillStyle = this.paintColors[lane];
        var x =         (this.canvas.width - this.leftMargin)  / this.canvasTimeScale * time + this.leftMargin;
        var y =         this.canvas.height / this.totalLanes      * lane;
        var height =    this.canvas.height / this.totalLanes;
        var width =     1;
        this.context.fillRect(x,y,width,height);
      }
      this.flush = function(){
        this.context.fillStyle = "#ffffff";
        this.context.fillRect(0,0,this.canvas.width,this.canvas.height);
        this.context.font = "200 18px Roboto,Helvetica,Arial";
        this.context.fillStyle = this.paintColors[0];
        this.context.fillText("Regular", 0, 30);
        this.context.fillStyle = this.paintColors[1];
        this.context.fillText("debounce", 0, 80);
        this.context.fillStyle = this.paintColors[2];
        this.context.fillText("throttle", 0, 130);
      }
      // get the time difference
      this.getTimeDiff = function(){
        var time = new Date().getTime();
        if(!this.startTime){ this.startTime = time; }
        time -= this.startTime;
        return time;
      }
      this.regularHandler = function(){
        self.paintRect(0,self.getTimeDiff());
      }
      this.debounceHandler = function(){
        self.paintRect(1,self.getTimeDiff());
      }
      this.throttleHander = function(){
        self.paintRect(2,self.getTimeDiff());
      }
    }

    var demo = new NIM_demo();
    demo.init();
  </script>

  <pre><code class="javascript">
    var helpers = {
      // debouncing, executes the function if there was no new event in $wait milliseconds
      debounce: function (func, wait, scope) {
        var timeout;
        return function () {
          var context = scope || this, args = arguments;
          var later = function () {
            timeout = null;
            func.apply(context, args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      },
      // in case of a "storm of events", this executes once every $threshold
      throttle: function (fn, threshhold, scope) {
        threshhold || (threshhold = 250);
        var last,
            deferTimer;
        return function () {
          var context = scope || this;
          var now = +new Date,
            args = arguments;
          if (last && now < last + threshhold) {
            // hold on to it
            clearTimeout(deferTimer);
            deferTimer = setTimeout(function () {
              last = now;
              fn.apply(context, args);
            }, threshhold);
          } else {
            last = now;
            fn.apply(context, args);
          }
        };
      }
    }

    function NIM_demo(){
      this.canvas =   document.getElementById("paintonme");
      this.context =  this.canvas.getContext("2d");
      this.movearea = document.getElementById("moveonme");
      this.canvasTimeScale = 5 * 1000;
      this.paintColors = ["#bbd","#464","#d88"];
      this.totalLanes =  this.paintColors.length;
      this.leftMargin = 100;
      var self = this;
      this.init = function(){
        this.canvas.width = window.innerWidth - 250;
        this.flush();
        this.movearea.addEventListener(
          "mousemove",this.regularHandler);
        this.movearea.addEventListener(
          "mousemove",helpers.debounce(self.debounceHandler,100,this));
        this.movearea.addEventListener(
          "mousemove",helpers.throttle(self.throttleHander,100,this));

        this.movearea.addEventListener(
          "touchmove",this.regularHandler);
        this.movearea.addEventListener(
          "touchmove",helpers.debounce(self.debounceHandler,100,this));
        this.movearea.addEventListener(
          "touchmove",helpers.throttle(self.throttleHander,100,this));
      }
      // painting the rectangle / line
      this.paintRect = function(lane,time){
        if(time > this.canvasTimeScale){
          this.startTime += time;
          time = 0;
          this.flush()
        }
        // console.log(lane,time);
        this.context.fillStyle = this.paintColors[lane];
        var x = (this.canvas.width - this.leftMargin) / this.canvasTimeScale * time + this.leftMargin;
        var y = this.canvas.height / this.totalLanes * lane;
        var height = this.canvas.height / this.totalLanes;
        var width = 1;
        this.context.fillRect(x,y,width,height);
      }
      this.flush = function(){
        this.context.fillStyle = "#ffffff";
        this.context.fillRect(0,0,this.canvas.width,this.canvas.height);
        this.context.font = "200 18px Roboto,Helvetica,Arial";
        this.context.fillStyle = this.paintColors[0];
        this.context.fillText("Regular", 0, 30);
        this.context.fillStyle = this.paintColors[1];
        this.context.fillText("debounce", 0, 80);
        this.context.fillStyle = this.paintColors[2];
        this.context.fillText("throttle", 0, 130);
      }
      // get the time difference
      this.getTimeDiff = function(){
        var time = new Date().getTime();
        if(!this.startTime){ this.startTime = time; }
        time -= this.startTime;
        return time;
      }
      this.regularHandler = function(){
        self.paintRect(0,self.getTimeDiff());
      }
      this.debounceHandler = function(){
        self.paintRect(1,self.getTimeDiff());
      }
      this.throttleHander = function(){
        self.paintRect(2,self.getTimeDiff());
      }
    }

    var demo = new NIM_demo();
    demo.init();
  </code></pre>



<h2 id="webc">Web Components</h2>

  <ul>
    <li>suite of different technologies allowing you to create reusable custom elements â€” with their functionality encapsulated away from the rest of your code â€” and utilize them in your web apps
      <ul>
        <li>Custom elements - JS APIs that allow you to define custom elements and their behaviour, which can then be used as desired in your user interface
        <ul>
          <li>autonomous custom elements - standalone, nearly always extend HTMLElement, use these on a page by literally writing them out as an HTML element: &lt;popup-info&gt; or document.createElement("popup-info")</li>
          <li>customized built-in elements - inherit from basic HTML elements (HTMLElement interface extensions: HTMLAnchorElement, HTMLAudioElement,...), to create, you have to specify which element they extend, and they are used by writing out the basic element but specifying the name of the custom element in the is attribute (or property): &lt;p is="word-count"&gt; or document.createElement("p", { is: "word-count" })</li>
        </ul></li>
        <li>Shadow DOM - JS APIs for attaching an encapsulated "shadow" DOM tree to an element â€” which is rendered separately from the main document DOM â€” and controlling associated functionality, in this way you can keep an element features private, so they can be scripted and styled without the fear of collision with other parts of the document, starts with a shadow root, underneath which can be attached to any elements you want, in the same way as the normal DOM
        <ul>
          <li>shadow host - regular DOM node that the shadow DOM is attached to</li>
          <li>shadow tree - DOM tree inside the shadow DOM</li>
          <li>shadow boundary - place, where the shadow DOM ends, and the regular DOM begins</li>
          <li>shadow root - root node of the shadow tree</li>
        </ul></li>
        <li>HTML templates -  &lt;template&gt; and  &lt;slot&gt; elements enable you to write markup templates that are not displayed in the rendered page, these can then be reused multiple times as the basis of a custom element's structure or referenced using JS</li>
      </ul>
    </li>
    <li>basic approach
      <ul>
        <li>create a <strong>class or a function</strong> in which you specify your web component functionality, use the ECMAScript 2015 class syntax</li>
        <li><strong>register</strong> your new custom element using the CustomElementRegistry.define() method, passing it the element name to be defined, the class or function in which its functionality is specified, and optionally, what element it inherits from</li>
        <li>if required, attach a shadow DOM to the custom element using <strong>Element.attachShadow()</strong> method, add child elements, event listeners, etc., to the shadow DOM using regular DOM methods</li>
        <li>if required, define an HTML template using <strong>template and slot</strong>, again use regular DOM methods to clone the template and attach it to your shadow DOM</li>
        <li>use your custom element wherever you like on your page, just like you would any regular HTML element</li>
      </ul>
    </li>
  </ul>

  <h3>composed and composedPath, access to shadow root with JS</h3>

  <div class="example">
    <open-shadow text="I have an open shadow root, "></open-shadow>
    <closed-shadow text="I have a closed shadow root"></closed-shadow>
  </div>

  <script>
    customElements.define('open-shadow',
      class extends HTMLElement {
        constructor() {
          super();
          const pElem = document.createElement('p');
          pElem.textContent = this.getAttribute('text');
          const shadowRoot = this.attachShadow({mode: 'open'});
          shadowRoot.appendChild(pElem);
    }});
    customElements.define('closed-shadow',
      class extends HTMLElement {
        constructor() {
          super();
          const pElem = document.createElement('p');
          pElem.textContent = this.getAttribute('text');
          const shadowRoot = this.attachShadow({mode: 'closed'});
          shadowRoot.appendChild(pElem);
    }});
    // document.querySelector('#webc_result').addEventListener('click', e => {
    //   // console.log(e.composed);
    //   // console.log(e.composedPath());
    // });
  </script>

  <pre><code class="html">
    &lt;open-shadow text="I have an open shadow root, "&gt;&lt;/open-shadow&gt;
    &lt;closed-shadow text="I have a closed shadow root"&gt;&lt;/closed-shadow&gt;
  </code></pre>

  <pre><code class="javascript">
    customElements.define('open-shadow',
      class extends HTMLElement {
        constructor() {
          super();
          const pElem = document.createElement('p');
          pElem.textContent = this.getAttribute('text');
          const shadowRoot = this.attachShadow({mode: 'open'});
          shadowRoot.appendChild(pElem);
    }});
    customElements.define('closed-shadow',
      class extends HTMLElement {
        constructor() {
          super();
          const pElem = document.createElement('p');
          pElem.textContent = this.getAttribute('text');
          const shadowRoot = this.attachShadow({mode: 'closed'});
          shadowRoot.appendChild(pElem);
    }});
    document.querySelector('#webc_result').addEventListener('click', e => {
      // console.log(e.composed);
      // console.log(e.composedPath());
    });
  </code></pre>

  <h3>:defined pseudo-class</h3>

  <style>
    simple-custom {
      background: cyan;
    }
    /* :defined {
      font-style: italic;
    } */
    simple-custom:not(:defined) {
      display: none;
    }
    simple-custom:defined {
      display: block;
    }
  </style>

  <div class="example">
    <simple-custom text="Custom element example text"></simple-custom>
    <p>Standard paragraph example text</p>
  </div>

  <script>
    customElements.define('simple-custom',
      class extends HTMLElement {
        constructor() {
          super();
          const divElem = document.createElement('div');
          divElem.textContent = this.getAttribute('text');
          const shadowRoot = this.attachShadow({mode: 'open'});
          shadowRoot.appendChild(divElem);
    }});
  </script>

  <pre><code class="css">
    simple-custom {
      background: cyan;
    }
    :defined {
      font-style: italic;
    }
    simple-custom:not(:defined) {
      display: none;
    }
    simple-custom:defined {
      display: block;
    }
  </code></pre>

  <pre><code class="html">
    &lt;simple-custom text="Custom element example text"&gt;&lt;/simple-custom&gt;
    &lt;p&gt;Standard paragraph example text&lt;/p&gt;
  </code></pre>

  <pre><code class="javascript">
    customElements.define('simple-custom',
      class extends HTMLElement {
        constructor() {
          super();
          const divElem = document.createElement('div');
          divElem.textContent = this.getAttribute('text');
          const shadowRoot = this.attachShadow({mode: 'open'});
          shadowRoot.appendChild(divElem);
    }});
  </code></pre>

  <h3>editable word</h3>

  <div class="example">
    <template id="person-template">
      <div>
        <h2>Personal ID Card</h2>
        <slot name="person-name">NAME MISSING</slot>
        <ul>
          <li><slot name="person-age">AGE MISSING</slot></li>
          <li><slot name="person-occupation">OCCUPATION MISSING</slot></li>
        </ul>
      </div>
    </template>
    <person-details>
      <p slot="person-name"><edit-word>Morgan</edit-word> Stanley</p>
      <span slot="person-age">36</span>
      <span slot="person-occupation">Accountant</span>
    </person-details>
    <p>My name is <edit-word>Chris</edit-word>, the man said.</p>
  </div>

  <script>
    customElements.define('person-details',
      class extends HTMLElement {
        constructor() {
          super();
          const template = document.getElementById('person-template');
          const templateContent = template.content;
          const shadowRoot = this.attachShadow({mode: 'open'});
          const style = document.createElement('style');
          style.textContent = `
            div { padding: 10px; border: 1px solid gray; width: 200px; margin: 10px; }
            h2 { margin: 0 0 10px; }
            ul { margin: 0; }
            p { margin: 10px 0; }
          `;
          shadowRoot.appendChild(style);
          shadowRoot.appendChild(templateContent.cloneNode(true));
    }});
    customElements.define('edit-word',
      class extends HTMLElement {
        constructor() {
          super();
          const shadowRoot = this.attachShadow({mode: 'open'});
          const form = document.createElement('form');
          const input = document.createElement('input');
          const span = document.createElement('span');
          const style = document.createElement('style');
          style.textContent = 'span { background-color: #eef; padding: 0 2px }';
          shadowRoot.appendChild(style);
          shadowRoot.appendChild(form);
          shadowRoot.appendChild(span);
          span.textContent = this.textContent;
          input.value = this.textContent;
          form.appendChild(input);
          form.style.display = 'none';
          span.style.display = 'inline-block';
          input.style.width = span.clientWidth + 'px';
          this.setAttribute('tabindex', '0');
          input.setAttribute('required', 'required');
          this.style.display = 'inline-block';
          this.addEventListener('click', () => {
            span.style.display = 'none';
            form.style.display = 'inline-block';
            input.focus();
            input.setSelectionRange(0, input.value.length)
          });
          form.addEventListener('submit', e => {
            updateDisplay();
            e.preventDefault();
          });
          input.addEventListener('blur', updateDisplay);
          function updateDisplay() {
            span.style.display = 'inline-block';
            form.style.display = 'none';
            span.textContent = input.value;
            input.style.width = span.clientWidth + 'px';
    }}});
  </script>

  <pre><code class="html">
    &lt;template id="person-template"&gt;
      &lt;div&gt;
        &lt;h2&gt;Personal ID Card&lt;/h2&gt;
        &lt;slot name="person-name"&gt;NAME MISSING&lt;/slot&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;slot name="person-age"&gt;AGE MISSING&lt;/slot&gt;&lt;/li&gt;
          &lt;li&gt;&lt;slot name="person-occupation"&gt;OCCUPATION MISSING&lt;/slot&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;person-details&gt;
      &lt;p slot="person-name"&gt;&lt;edit-word&gt;Morgan&lt;/edit-word&gt; Stanley&lt;/p&gt;
      &lt;span slot="person-age"&gt;36&lt;/span&gt;
      &lt;span slot="person-occupation"&gt;Accountant&lt;/span&gt;
    &lt;/person-details&gt;
    &lt;p&gt;My name is &lt;edit-word&gt;Chris&lt;/edit-word&gt;, the man said.&lt;/p&gt;
  </code></pre>

  <pre><code class="javascript">
    customElements.define('person-details',
      class extends HTMLElement {
        constructor() {
          super();
          const template = document.getElementById('person-template');
          const templateContent = template.content;
          const shadowRoot = this.attachShadow({mode: 'open'});
          const style = document.createElement('style');
          style.textContent = `
            div { padding: 10px; border: 1px solid gray; width: 200px; margin: 10px; }
            h2 { margin: 0 0 10px; }
            ul { margin: 0; }
            p { margin: 10px 0; }
          `;
          shadowRoot.appendChild(style);
          shadowRoot.appendChild(templateContent.cloneNode(true));
    }});
    customElements.define('edit-word',
      class extends HTMLElement {
        constructor() {
          super();
          const shadowRoot = this.attachShadow({mode: 'open'});
          const form = document.createElement('form');
          const input = document.createElement('input');
          const span = document.createElement('span');
          const style = document.createElement('style');
          style.textContent = 'span { background-color: #eef; padding: 0 2px }';
          shadowRoot.appendChild(style);
          shadowRoot.appendChild(form);
          shadowRoot.appendChild(span);
          span.textContent = this.textContent;
          input.value = this.textContent;
          form.appendChild(input);
          form.style.display = 'none';
          span.style.display = 'inline-block';
          input.style.width = span.clientWidth + 'px';
          this.setAttribute('tabindex', '0');
          input.setAttribute('required', 'required');
          this.style.display = 'inline-block';
          this.addEventListener('click', () => {
            span.style.display = 'none';
            form.style.display = 'inline-block';
            input.focus();
            input.setSelectionRange(0, input.value.length)
          });
          form.addEventListener('submit', e => {
            updateDisplay();
            e.preventDefault();
          });
          input.addEventListener('blur', updateDisplay);
          function updateDisplay() {
            span.style.display = 'inline-block';
            form.style.display = 'none';
            span.textContent = input.value;
            input.style.width = span.clientWidth + 'px';
    }}});
  </code></pre>

  <h3>editable list</h3>

  <div class="example">
    <editable-list
      title="TODO"
      list-item-0="First item on the list"
      list-item-1="Second item on the list"
      list-item-2="Third item on the list"
      list-item-3="Fourth item on the list"
      list-item-4="Fifth item on the list"
      listItem="This will not appear"
      add-item-text="Add new list item:"
    >
    </editable-list>
  </div>
  <script>
    (function() {
      class EditableList extends HTMLElement {
        constructor() {
          // establish prototype chain
          super();
          // attaches shadow tree and returns shadow root reference
          // https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow
          const shadow = this.attachShadow({ mode: 'open' });
          // creating a container for the editable-list component
          const editableListContainer = document.createElement('div');
          // get attribute values from getters
          const title = this.title;
          const addItemText = this.addItemText;
          const listItems = this.items;
          // adding a class to our container for the sake of clarity
          editableListContainer.classList.add('editable-list');
          // creating the inner HTML of the editable list element
          editableListContainer.innerHTML = `
            <style>
              li, div > div {
                display: flex;
                align-items: center;
                justify-content: space-between;
              }
              .icon {
                background-color: #fff;
                border: none;
                cursor: pointer;
                float: right;
                font-size: 1.8rem;
              }
            </style>
            <h3>${title}</h3>
            <ul class="item-list">
              ${listItems.map(item => `
                <li>${item}
                  <button class="editable-list-remove-item icon">&ominus;</button>
                </li>
              `).join('')}
            </ul>
            <div>
              <label>${addItemText}</label>
              <input class="add-new-list-item-input" type="text"></input>
              <button class="editable-list-add-item icon">&oplus;</button>
            </div>
          `;
          // binding methods
          this.addListItem = this.addListItem.bind(this);
          this.handleRemoveItemListeners = this.handleRemoveItemListeners.bind(this);
          this.removeListItem = this.removeListItem.bind(this);
          // appending the container to the shadow DOM
          shadow.appendChild(editableListContainer);
        }
        // add items to the list
        addListItem(e) {
          const textInput = this.shadowRoot.querySelector('.add-new-list-item-input');
          if (textInput.value) {
            const li = document.createElement('li');
            const button = document.createElement('button');
            const childrenLength = this.itemList.children.length;
            li.textContent = textInput.value;
            button.classList.add('editable-list-remove-item', 'icon');
            button.innerHTML = '&ominus;';
            this.itemList.appendChild(li);
            this.itemList.children[childrenLength].appendChild(button);
            this.handleRemoveItemListeners([...this.itemList.children]);
            textInput.value = '';
          }
        }
        // fires after the element has been attached to the DOM
        connectedCallback() {
          const removeElementButtons = [...this.shadowRoot.querySelectorAll('.editable-list-remove-item')];
          const addElementButton = this.shadowRoot.querySelector('.editable-list-add-item');

          this.itemList = this.shadowRoot.querySelector('.item-list');

          this.handleRemoveItemListeners(removeElementButtons);
          addElementButton.addEventListener('click', this.addListItem, false);
        }
        // gathering data from element attributes
        get title() {
          return this.getAttribute('title') || '';
        }
        get items() {
          const items = [];
          [...this.attributes].forEach(attr => {
            if (attr.name.includes('list-item')) {
              items.push(attr.value);
            }
          });
          return items;
        }
        get addItemText() {
          return this.getAttribute('add-item-text') || '';
        }
        handleRemoveItemListeners(arrayOfElements) {
          arrayOfElements.forEach(element => {
            element.addEventListener('click', this.removeListItem, false);
          });
        }
        removeListItem(e) {
          e.target.parentNode.remove();
        }
      }
      // let the browser know about the custom element
      customElements.define('editable-list', EditableList);
    })();
  </script>

  <pre><code class="html">
    &lt;editable-list
      title="TODO"
      list-item-0="First item on the list"
      list-item-1="Second item on the list"
      list-item-2="Third item on the list"
      list-item-3="Fourth item on the list"
      list-item-4="Fifth item on the list"
      listItem="This will not appear"
      add-item-text="Add new list item:"
    &gt;
    &lt;/editable-list&gt;
  </code></pre>

  <pre><code class="javascript">
    (function() {
      class EditableList extends HTMLElement {
        constructor() {
          // establish prototype chain
          super();
          // attaches shadow tree and returns shadow root reference
          // https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow
          const shadow = this.attachShadow({ mode: 'open' });
          // creating a container for the editable-list component
          const editableListContainer = document.createElement('div');
          // get attribute values from getters
          const title = this.title;
          const addItemText = this.addItemText;
          const listItems = this.items;
          // adding a class to our container for the sake of clarity
          editableListContainer.classList.add('editable-list');
          // creating the inner HTML of the editable list element
          editableListContainer.innerHTML = `
            &lt;style&gt;
              li, div &gt; div {
                display: flex;
                align-items: center;
                justify-content: space-between;
              }
              .icon {
                background-color: #fff;
                border: none;
                cursor: pointer;
                float: right;
                font-size: 1.8rem;
              }
            &lt;/style&gt;
            &lt;h3&gt;${title}&lt;/h3&gt;
            &lt;ul class="item-list"&gt;
              ${listItems.map(item =&gt; `
                &lt;li&gt;${item}
                  &lt;button class="editable-list-remove-item icon"&gt;&ominus;&lt;/button&gt;
                &lt;/li&gt;
              `).join('')}
            &lt;/ul&gt;
            &lt;div&gt;
              &lt;label&gt;${addItemText}&lt;/label&gt;
              &lt;input class="add-new-list-item-input" type="text"&gt;&lt;/input&gt;
              &lt;button class="editable-list-add-item icon"&gt;&oplus;&lt;/button&gt;
            &lt;/div&gt;
          `;
          // binding methods
          this.addListItem = this.addListItem.bind(this);
          this.handleRemoveItemListeners = this.handleRemoveItemListeners.bind(this);
          this.removeListItem = this.removeListItem.bind(this);
          // appending the container to the shadow DOM
          shadow.appendChild(editableListContainer);
        }
        // add items to the list
        addListItem(e) {
          const textInput = this.shadowRoot.querySelector('.add-new-list-item-input');
          if (textInput.value) {
            const li = document.createElement('li');
            const button = document.createElement('button');
            const childrenLength = this.itemList.children.length;
            li.textContent = textInput.value;
            button.classList.add('editable-list-remove-item', 'icon');
            button.innerHTML = '&ominus;';
            this.itemList.appendChild(li);
            this.itemList.children[childrenLength].appendChild(button);
            this.handleRemoveItemListeners([...this.itemList.children]);
            textInput.value = '';
          }
        }
        // fires after the element has been attached to the DOM
        connectedCallback() {
          const removeElementButtons = [...this.shadowRoot.querySelectorAll('.editable-list-remove-item')];
          const addElementButton = this.shadowRoot.querySelector('.editable-list-add-item');

          this.itemList = this.shadowRoot.querySelector('.item-list');

          this.handleRemoveItemListeners(removeElementButtons);
          addElementButton.addEventListener('click', this.addListItem, false);
        }
        // gathering data from element attributes
        get title() {
          return this.getAttribute('title') || '';
        }
        get items() {
          const items = [];
          [...this.attributes].forEach(attr =&lt; {
            if (attr.name.includes('list-item')) {
              items.push(attr.value);
            }
          });
          return items;
        }
        get addItemText() {
          return this.getAttribute('add-item-text') || '';
        }
        handleRemoveItemListeners(arrayOfElements) {
          arrayOfElements.forEach(element =&lt; {
            element.addEventListener('click', this.removeListItem, false);
          });
        }
        removeListItem(e) {
          e.target.parentNode.remove();
        }
      }
      // let the browser know about the custom element
      customElements.define('editable-list', EditableList);
    })();
  </code></pre>

  <h3>element-details - web component using template and slot</h3>

  <style>
    #edt dl { margin-left: 6px; }
    #edt dt { font-weight: bold; color: #217ac0; font-size: 110% }
    #edt dt { font-family: Consolas, "Liberation Mono", Courier }
    #edt dd { margin-left: 16px }
  </style>


  <div class="example">
    <div id="edt">
      <template id="element-details-template">
        <style>
        details {font-family: "Open Sans Light",Helvetica,Arial}
        .name {font-weight: bold; color: #217ac0; font-size: 120%}
        h4 { margin: 10px 0 -8px 0; }
        h4 span { background: #217ac0; padding: 2px 6px 2px 6px }
        h4 span { border: 1px solid #cee9f9; border-radius: 4px }
        h4 span { color: white }
        .attributes { margin-left: 22px; font-size: 90% }
        .attributes p { margin-left: 16px; font-style: italic }
        </style>
        <details>
          <summary>
            <span>
              <code class="name">&lt;<slot name="element-name">NEED NAME</slot>&gt;</code>
              <i class="desc"><slot name="description">NEED DESCRIPTION</slot></i>
            </span>
          </summary>
          <div class="attributes">
            <h4><span>Attributes</span></h4>
            <slot name="attributes"><p>None</p></slot>
          </div>
        </details>
        <hr>
      </template>
      <element-details>
        <span slot="element-name">slot</span>
        <span slot="description">A placeholder inside a web
          component that users can fill with their own markup,
          with the effect of composing different DOM trees
          together.</span>
        <dl slot="attributes">
          <dt>name</dt>
          <dd>The name of the slot.</dd>
        </dl>
      </element-details>
      <element-details>
        <span slot="element-name">template</span>
        <span slot="description">A mechanism for holding client-
          side content that is not to be rendered when a page is
          loaded but may subsequently be instantiated during
          runtime using JavaScript.</span>
      </element-details>
    </div>
  </div>

  <script>
    customElements.define('element-details',
      class extends HTMLElement {
        constructor() {
          super();
          const template = document
            .getElementById('element-details-template')
            .content;
          const shadowRoot = this.attachShadow({mode: 'open'})
            .appendChild(template.cloneNode(true));
    }});
  </script>

  <pre><code class="css">
    dl { margin-left: 6px; }
    dt { font-weight: bold; color: #217ac0; font-size: 110% }
    dt { font-family: Consolas, "Liberation Mono", Courier }
    dd { margin-left: 16px }
  </code></pre>

  <pre><code class="html">
    &lt;template id="element-details-template"&gt;
      &lt;style&gt;
      details {font-family: "Open Sans Light",Helvetica,Arial}
      .name {font-weight: bold; color: #217ac0; font-size: 120%}
      h4 { margin: 10px 0 -8px 0; }
      h4 span { background: #217ac0; padding: 2px 6px 2px 6px }
      h4 span { border: 1px solid #cee9f9; border-radius: 4px }
      h4 span { color: white }
      .attributes { margin-left: 22px; font-size: 90% }
      .attributes p { margin-left: 16px; font-style: italic }
      &lt;/style&gt;
      &lt;details&gt;
        &lt;summary&gt;
          &lt;span&gt;
            &lt;code class="name"&gt;&lt;&lt;slot name="element-name"&gt;NEED NAME&lt;/slot&gt;&gt;&lt;/code&gt;
            &lt;i class="desc"&gt;&lt;slot name="description"&gt;NEED DESCRIPTION&lt;/slot&gt;&lt;/i&gt;
          &lt;/span&gt;
        &lt;/summary&gt;
        &lt;div class="attributes"&gt;
          &lt;h4&gt;&lt;span&gt;Attributes&lt;/span&gt;&lt;/h4&gt;
          &lt;slot name="attributes"&gt;&lt;p&gt;None&lt;/p&gt;&lt;/slot&gt;
        &lt;/div&gt;
      &lt;/details&gt;
      &lt;hr&gt;
    &lt;/template&gt;
    &lt;element-details&gt;
      &lt;span slot="element-name"&gt;slot&lt;/span&gt;
      &lt;span slot="description"&gt;A placeholder inside a web
        component that users can fill with their own markup,
        with the effect of composing different DOM trees
        together.&lt;/span&gt;
      &lt;dl slot="attributes"&gt;
        &lt;dt&gt;name&lt;/dt&gt;
        &lt;dd&gt;The name of the slot.&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/element-details&gt;
    &lt;element-details&gt;
      &lt;span slot="element-name"&gt;template&lt;/span&gt;
      &lt;span slot="description"&gt;A mechanism for holding client-
        side content that is not to be rendered when a page is
        loaded but may subsequently be instantiated during
        runtime using JavaScript.&lt;/span&gt;
    &lt;/element-details&gt;
  </code></pre>

  <pre><code class="javascript">
    customElements.define('element-details',
      class extends HTMLElement {
        constructor() {
          super();
          const template = document
            .getElementById('element-details-template')
            .content;
          const shadowRoot = this.attachShadow({mode: 'open'})
            .appendChild(template.cloneNode(true));
    }});
  </code></pre>

  <h3>expanding list (click to open indention)</h3>

  <style>
    #elst ul {
      list-style-type: none;
    }
    #elst li::before {
      display:inline-block;
      width: 1rem;
      height: 1rem;
      margin-right: 0.25rem;
      content:"";
    }
    #elst .open::before,
    #elst .closed::before {
      background-size: 1rem 1rem;
      position: relative;
      top: 0.25rem;
      opacity: 0.3;
    }
    #elst .open::before {
      background-image: url(images/down.png);
    }
    #elst .closed::before {
      background-image: url(images/right.png);
    }
    #elst .closed .closed::before,
    #elst .closed .open::before {
      display: none;
    }
  </style>


  <div class="example">
    <div id="elst">
      <ul is="expanding-list">
        <li>UK
        <ul>
          <li>Yorkshire
          <ul>
            <li>Leeds
            <ul>
              <li>Train station</li>
              <li>Town hall</li>
              <li>Headrow</li>
            </ul>
            </li>
            <li>Bradford</li>
            <li>Hull</li>
          </ul>
          </li>
        </ul>
        </li>
        <li>USA
        <ul>
          <li>California
          <ul>
            <li>Los Angeles</li>
            <li>San Francisco</li>
            <li>Berkeley</li>
          </ul>
          </li>
          <li>Nevada</li>
          <li>Oregon</li>
        </ul>
        </li>
      </ul>
    </div>
  </div>

  <script>// Create a class for the element
    class ExpandingList extends HTMLUListElement {
      constructor() {
        // Always call super first in constructor
        super();
        window.onload = function() {
          const uls = Array.from(document.querySelectorAll(':root #elst ul'));
          const lis = Array.from(document.querySelectorAll(':root #elst li'));
          uls.slice(1).forEach(ul => {
            ul.style.display = 'none';
          });
          lis.forEach(li => {
            const childText = li.childNodes[0];
            const newSpan = document.createElement('span');

            newSpan.textContent = childText.textContent;
            childText.parentNode.insertBefore(newSpan, childText);
            childText.parentNode.removeChild(childText);
          });
          const spans = Array.from(document.querySelectorAll(':root #elst span'));
          spans.forEach(span => {
            if (span.nextElementSibling) {
              span.style.cursor = 'pointer';
              span.parentNode.setAttribute('class', 'closed');
              span.onclick = showul;
            }
          });
          function showul(e) {
            const nextul = e.target.nextElementSibling;

            if (nextul.style.display == 'block') {
              nextul.style.display = 'none';
              nextul.parentNode.setAttribute('class', 'closed');
            } else {
              nextul.style.display = 'block';
              nextul.parentNode.setAttribute('class', 'open');
            }
          }
        };
      }
    }
    // Define the new element
    customElements.define('expanding-list', ExpandingList, { extends: 'ul' });
  </script>

  <pre><code class="css">
    ul {
      list-style-type: none;
    }
    li::before {
      display:inline-block;
      width: 1rem;
      height: 1rem;
      margin-right: 0.25rem;
      content:"";
    }
    .open::before, .closed::before {
      background-size: 1rem 1rem;
      position: relative;
      top: 0.25rem;
      opacity: 0.3;
    }
    .open::before {
      background-image: url(images/down.png);
    }
    .closed::before {
      background-image: url(images/right.png);
    }
    .closed .closed::before, .closed .open::before {
      display: none;
    }
  </code></pre>

  <pre><code class="html">
    &lt;ul is="expanding-list"&gt;
      &lt;li&gt;UK
      &lt;ul&gt;
        &lt;li&gt;Yorkshire
        &lt;ul&gt;
          &lt;li&gt;Leeds
          &lt;ul&gt;
            &lt;li&gt;Train station&lt;/li&gt;
            &lt;li&gt;Town hall&lt;/li&gt;
            &lt;li&gt;Headrow&lt;/li&gt;
          &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Bradford&lt;/li&gt;
          &lt;li&gt;Hull&lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;USA
      &lt;ul&gt;
        &lt;li&gt;California
        &lt;ul&gt;
          &lt;li&gt;Los Angeles&lt;/li&gt;
          &lt;li&gt;San Francisco&lt;/li&gt;
          &lt;li&gt;Berkeley&lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;Nevada&lt;/li&gt;
        &lt;li&gt;Oregon&lt;/li&gt;
      &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  </code></pre>

  <pre><code class="javascript">
    // Create a class for the element
    class ExpandingList extends HTMLUListElement {
      constructor() {
        // Always call super first in constructor
        super();
        window.onload = function() {
          const uls = Array.from(document.querySelectorAll(':root ul'));
          const lis = Array.from(document.querySelectorAll(':root li'));
          uls.slice(1).forEach(ul =&gt; {
            ul.style.display = 'none';
          });
          lis.forEach(li =&gt; {
            const childText = li.childNodes[0];
            const newSpan = document.createElement('span');
            newSpan.textContent = childText.textContent;
            childText.parentNode.insertBefore(newSpan, childText);
            childText.parentNode.removeChild(childText);
          });
          const spans = Array.from(document.querySelectorAll(':root span'));
          spans.forEach(span =&gt; {
            if (span.nextElementSibling) {
              span.style.cursor = 'pointer';
              span.parentNode.setAttribute('class', 'closed');
              span.onclick = showul;
            }
          });
          function showul(e) {
            const nextul = e.target.nextElementSibling;
            if (nextul.style.display == 'block') {
              nextul.style.display = 'none';
              nextul.parentNode.setAttribute('class', 'closed');
            } else {
              nextul.style.display = 'block';
              nextul.parentNode.setAttribute('class', 'open');
            }
          }
        };
      }
    }
    // Define the new element
    customElements.define('expanding-list', ExpandingList, { extends: 'ul' });
  </code></pre>

  <h3>Host selectors</h3>

  <script>
    class ContextSpan extends HTMLElement {
      constructor() {
        super();
        const style = document.createElement('style');
        const span = document.createElement('span');
        span.textContent = this.textContent;
        const shadowRoot = this.attachShadow({mode: 'open'});
        shadowRoot.appendChild(style);
        shadowRoot.appendChild(span);
        style.textContent = `
          span:hover { text-decoration: underline; }
          :host-context(h1) { font-style: italic; }
          :host-context(h1):after { content: " - no links in headers!" }
          :host-context(article, aside) { color: gray; }
          :host(.footer) { color : red; }
          :host { background: rgba(0,0,0,0.1); padding: 2px 5px; }
        `;
      }
    }
    // Define the new element
    customElements.define('context-span', ContextSpan);
  </script>

  <pre><code class="html">
    ...
    &lt;body&gt;
      &lt;header&gt;
        &lt;h1&gt;Host selectors &lt;a href="#"&gt;&lt;context-span&gt;example&lt;/context-span&gt;&lt;/a&gt;&lt;/h1&gt;
      &lt;/header&gt;
      &lt;main&gt;
        &lt;article&gt;
          &lt;h2&gt;This is my first article.&lt;/h2&gt;
          &lt;p&gt;This article is rather lovely and exciting â€” it is all about animals,
          including &lt;a href="#"&gt;&lt;context-span&gt;Beavers&lt;/context-span&gt;&lt;/a&gt;,
          &lt;a href="#"&gt;&lt;context-span&gt;Bears&lt;/context-span&gt;&lt;/a&gt;,
          and &lt;a href="#"&gt;&lt;context-span&gt;Wolves&lt;/context-span&gt;&lt;/a&gt;.
          I love animals and I'm sure you will too;
          please let us know what your favorite animals are. Woo hoo!&lt;/p&gt;
        &lt;/article&gt;
        &lt;article&gt;
          &lt;h2&gt;This is my second article.&lt;/h2&gt;
          &lt;p&gt;This article is also quite exciting â€” it is all about colors,
          including &lt;a href="#"&gt;&lt;context-span&gt;Red&lt;/context-span&gt;&lt;/a&gt;,
          &lt;a href="#"&gt;&lt;context-span&gt;Blue&lt;/context-span&gt;&lt;/a&gt;,
          and &lt;a href="#"&gt;&lt;context-span&gt;Pink&lt;/context-span&gt;&lt;/a&gt;.
          A true joy indeed â€” funky exciting colors make the world go round.
          No more gray days for us.&lt;/p&gt;
        &lt;/article&gt;
        &lt;aside&gt;
          &lt;h2&gt;Some links about web components&lt;/h2&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;a href="#"&gt;&lt;context-span&gt;Custom elements&lt;/context-span&gt;&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href="#"&gt;&lt;context-span&gt;Shadow DOM&lt;/context-span&gt;&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href="#"&gt;&lt;context-span&gt;Templates and slots&lt;/context-span&gt;&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/aside&gt;
      &lt;/main&gt;
      &lt;footer&gt;
        &lt;p&gt;Copyright nobody; example written by
        &lt;a href="#"&gt;&lt;context-span class="footer"&gt;Chris Mills&lt;/context-span&gt;&lt;/a&gt;
        &lt;/p&gt;
      &lt;/footer&gt;
    &lt;/body&gt;
  </code></pre>

  <pre><code class="javascript">
    class ContextSpan extends HTMLElement {
      constructor() {
        super();
        const style = document.createElement('style');
        const span = document.createElement('span');
        span.textContent = this.textContent;
        const shadowRoot = this.attachShadow({mode: 'open'});
        shadowRoot.appendChild(style);
        shadowRoot.appendChild(span);
        style.textContent = `
          span:hover { text-decoration: underline; }
          :host-context(h1) { font-style: italic; }
          :host-context(h1):after { content: " - no links in headers!" }
          :host-context(article, aside) { color: gray; }
          :host(.footer) { color : red; }
          :host { background: rgba(0,0,0,0.1); padding: 2px 5px; }
        `;
      }
    }
    // Define the new element
    customElements.define('context-span', ContextSpan);
  </code></pre>

  <h3>Life cycle callbacks</h3>

  <div class="example">
    <div id="lcc">
      <button class="lcc_add">Add custom-square to DOM</button>
      <button class="lcc_update">Update attributes</button>
      <button class="lcc_remove">Remove custom-square from DOM</button>
    </div>
  </div>

  <script>
    class Square extends HTMLElement {
      // Specify observed attributes so that
      // attributeChangedCallback will work
      static get observedAttributes() {
        return ['c', 'l'];
      }

      constructor() {
        // Always call super first in constructor
        super();

        const shadow = this.attachShadow({mode: 'open'});

        const div = document.createElement('div');
        const style = document.createElement('style');
        shadow.appendChild(style);
        shadow.appendChild(div);
      }

      connectedCallback() {
        // console.log('Custom square element added to page.');
        updateStyle(this);
      }

      disconnectedCallback() {
        // console.log('Custom square element removed from page.');
      }

      adoptedCallback() {
        // console.log('Custom square element moved to new page.');
      }

      attributeChangedCallback(name, oldValue, newValue) {
        // console.log('Custom square element attributes changed.');
        updateStyle(this);
      }
    }

    customElements.define('custom-square', Square);

    function updateStyle(elem) {
      const shadow = elem.shadowRoot;
      const childNodes = Array.from(shadow.childNodes);

      childNodes.forEach(childNode => {
        if (childNode.nodeName === 'STYLE') {
          childNode.textContent = `
            div {
              width: ${elem.getAttribute('l')}px;
              height: ${elem.getAttribute('l')}px;
              background-color: ${elem.getAttribute('c')};
            }
          `;
        }
      });
    }

    const add = document.querySelector('.lcc_add');
    const update = document.querySelector('.lcc_update');
    const remove = document.querySelector('.lcc_remove');
    let square;

    update.disabled = true;
    remove.disabled = true;

    function random(min, max) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    }

    add.onclick = function() {
      // Create a custom square element
      square = document.createElement('custom-square');
      square.setAttribute('l', '100');
      square.setAttribute('c', 'red');
      document.getElementById("lcc").appendChild(square);

      update.disabled = false;
      remove.disabled = false;
      add.disabled = true;
    };

    update.onclick = function() {
      // Randomly update square's attributes
      square.setAttribute('l', random(50, 200));
      square.setAttribute('c', `rgb(${random(0, 255)}, ${random(0, 255)}, ${random(0, 255)})`);
    };

    remove.onclick = function() {
      // Remove the square
      document.getElementById("lcc").removeChild(square);

      update.disabled = true;
      remove.disabled = true;
      add.disabled = false;
    };
  </script>

  <pre><code class="html">
    &lt;div&gt;
      &lt;button class="add"&gt;Add custom-square to DOM&lt;/button&gt;
      &lt;button class="update"&gt;Update attributes&lt;/button&gt;
      &lt;button class="remove"&gt;Remove custom-square from DOM&lt;/button&gt;
    &lt;/div&gt;
  </code></pre>

  <pre><code class="javascript">
    // Create a class for the element
    class Square extends HTMLElement {
      // Specify observed attributes so that
      // attributeChangedCallback will work
      static get observedAttributes() {
        return ['c', 'l'];
      }
      constructor() {
        // Always call super first in constructor
        super();
        const shadow = this.attachShadow({mode: 'open'});
        const div = document.createElement('div');
        const style = document.createElement('style');
        shadow.appendChild(style);
        shadow.appendChild(div);
      }
      connectedCallback() {
        console.log('Custom square element added to page.');
        updateStyle(this);
      }
      disconnectedCallback() {
        console.log('Custom square element removed from page.');
      }
      adoptedCallback() {
        console.log('Custom square element moved to new page.');
      }
      attributeChangedCallback(name, oldValue, newValue) {
        console.log('Custom square element attributes changed.');
        updateStyle(this);
      }
    }
    customElements.define('custom-square', Square);
    function updateStyle(elem) {
      const shadow = elem.shadowRoot;
      const childNodes = Array.from(shadow.childNodes);
      childNodes.forEach(childNode => {
        if (childNode.nodeName === 'STYLE') {
          childNode.textContent = `
            div {
              width: ${elem.getAttribute('l')}px;
              height: ${elem.getAttribute('l')}px;
              background-color: ${elem.getAttribute('c')};
            }
          `;
        }
      });
    }
    const add = document.querySelector('.add');
    const update = document.querySelector('.update');
    const remove = document.querySelector('.remove');
    let square;
    update.disabled = true;
    remove.disabled = true;
    function random(min, max) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    }
    add.onclick = function() {
      // Create a custom square element
      square = document.createElement('custom-square');
      square.setAttribute('l', '100');
      square.setAttribute('c', 'red');
      document.getElementById("lcc").appendChild(square);
      update.disabled = false;
      remove.disabled = false;
      add.disabled = true;
    };
    update.onclick = function() {
      // Randomly update square's attributes
      square.setAttribute('l', random(50, 200));
      square.setAttribute('c', `rgb(${random(0, 255)}, ${random(0, 255)}, ${random(0, 255)})`);
    };
    remove.onclick = function() {
      // Remove the square
      document.getElementById("lcc").removeChild(square);
      update.disabled = true;
      remove.disabled = true;
      add.disabled = false;
    };
  </code></pre>

  <h3>popup info box widget</h3>

  <div class="example">
    <br><br><br><br><br><br>
    <form>
      <div>
        <label for="cvc">Enter your CVC <popup-info img="../images/down.png" data-text="Your card validation code (CVC) is an extra security feature â€” it is the last 3 or 4 numbers on the back of your card."></label>
        <input type="text" id="cvc">
      </div>
    </form>
  </div>

  <script>
    class PopUpInfo extends HTMLElement {
      constructor() {
        // Always call super first in constructor
        super();

        // Create a shadow root
        const shadow = this.attachShadow({mode: 'open'});

        // Create spans
        const wrapper = document.createElement('span');
        wrapper.setAttribute('class', 'wrapper');

        const icon = document.createElement('span');
        icon.setAttribute('class', 'icon');
        icon.setAttribute('tabindex', 0);

        const info = document.createElement('span');
        info.setAttribute('class', 'info');

        // Take attribute content and put it inside the info span
        const text = this.getAttribute('data-text');
        info.textContent = text;

        // Insert icon
        let imgUrl;
        if(this.hasAttribute('img')) {
          imgUrl = this.getAttribute('img');
        } else {
          imgUrl = 'images/right.png';
        }

        const img = document.createElement('img');
        img.src = imgUrl;
        icon.appendChild(img);

        // Create some CSS to apply to the shadow dom
        const style = document.createElement('style');
        // console.log(style.isConnected);

        style.textContent = `
          .wrapper {
            position: relative;
          }
          .info {
            font-size: 0.8rem;
            width: 30em;
            display: inline-block;
            border: 1px solid black;
            padding: 10px;
            background: white;
            border-radius: 10px;
            opacity: 0;
            transition: 0.6s all;
            position: absolute;
            bottom: 20px;
            left: 10px;
            z-index: 3;
          }
          img {
            width: 1.2rem;
          }
          .icon:hover + .info, .icon:focus + .info {
            opacity: 1;
          }
        `;

        // Attach the created elements to the shadow dom
        shadow.appendChild(style);
        // console.log(style.isConnected);
        shadow.appendChild(wrapper);
        wrapper.appendChild(icon);
        wrapper.appendChild(info);
      }
    }
    // Define the new element
    customElements.define('popup-info', PopUpInfo);
  </script>

  <pre><code class="html">
    &lt;form&gt;
      &lt;div&gt;
        &lt;label for="cvc"&gt;
        Enter your CVC
        &lt;popup-info
          img="img/alt.png"
          data-text="Your card..."
        &gt;
        &lt;/label&gt;
        &lt;input type="text" id="cvc"&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  </code></pre>

  <pre><code class="javascript">
    // Create a class for the element
    class PopUpInfo extends HTMLElement {
      constructor() {
        // Always call super first in constructor
        super();

        // Create a shadow root
        const shadow = this.attachShadow({mode: 'open'});

        // Create spans
        const wrapper = document.createElement('span');
        wrapper.setAttribute('class', 'wrapper');

        const icon = document.createElement('span');
        icon.setAttribute('class', 'icon');
        icon.setAttribute('tabindex', 0);

        const info = document.createElement('span');
        info.setAttribute('class', 'info');

        // Take attribute content and put it inside the info span
        const text = this.getAttribute('data-text');
        info.textContent = text;

        // Insert icon
        let imgUrl;
        if(this.hasAttribute('img')) {
          imgUrl = this.getAttribute('img');
        } else {
          imgUrl = 'img/default.png';
        }

        const img = document.createElement('img');
        img.src = imgUrl;
        icon.appendChild(img);

        // Create some CSS to apply to the shadow dom
        const style = document.createElement('style');
        console.log(style.isConnected);

        style.textContent = `
          .wrapper {
            position: relative;
          }
          .info {
            font-size: 0.8rem;
            width: 200px;
            display: inline-block;
            border: 1px solid black;
            padding: 10px;
            background: white;
            border-radius: 10px;
            opacity: 0;
            transition: 0.6s all;
            position: absolute;
            bottom: 20px;
            left: 10px;
            z-index: 3;
          }
          img {
            width: 1.2rem;
          }
          .icon:hover + .info, .icon:focus + .info {
            opacity: 1;
          }
        `;
        // Attach the created elements to the shadow dom
        shadow.appendChild(style);
        console.log(style.isConnected);
        shadow.appendChild(wrapper);
        wrapper.appendChild(icon);
        wrapper.appendChild(info);
      }
    }
    // Define the new element
    customElements.define('popup-info', PopUpInfo);
  </code></pre>

  <h3>simple template</h3>


  <div class="example">
    <template id="my-paragraph">
      <style>
        p {
          color: white;
          background-color: #666;
          padding: 5px;
        }
      </style>
      <p><slot name="my-text">My default text</slot></p>
    </template>
    <my-paragraph>
      <span slot="my-text">Let's have some different text!</span>
    </my-paragraph>
    <my-paragraph>
      <ul slot="my-text">
        <li>Let's have some different text!</li>
        <li>In a list!</li>
      </ul>
    </my-paragraph>
  </div>

  <script>
    customElements.define('my-paragraph',
      class extends HTMLElement {
        constructor() {
          super();
          const template = document.getElementById('my-paragraph');
          const templateContent = template.content;
          this.attachShadow({mode: 'open'}).appendChild(
            templateContent.cloneNode(true)
          );
        }
      }
    );
    const slottedSpan = document.querySelector('my-paragraph span');
    // console.log(slottedSpan.assignedSlot);
    // console.log(slottedSpan.slot);
  </script>

  <pre><code class="html">
    &lt;template id="my-paragraph"&gt;
      &lt;style&gt;
        p {
          color: white;
          background-color: #666;
          padding: 5px;
        }
      &lt;/style&gt;
      &lt;p&gt;&lt;slot name="my-text"&gt;My default text&lt;/slot&gt;&lt;/p&gt;
    &lt;/template&gt;
    &lt;my-paragraph&gt;
      &lt;span slot="my-text"&gt;Let's have some different text!&lt;/span&gt;
    &lt;/my-paragraph&gt;
    &lt;my-paragraph&gt;
      &lt;ul slot="my-text"&gt;
        &lt;li&gt;Let's have some different text!&lt;/li&gt;
        &lt;li&gt;In a list!&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/my-paragraph&gt;
  </code></pre>

  <pre><code class="javascript">
    customElements.define('my-paragraph',
      class extends HTMLElement {
        constructor() {
          super();
          const template = document.getElementById('my-paragraph');
          const templateContent = template.content;
          this.attachShadow({mode: 'open'}).appendChild(
            templateContent.cloneNode(true)
          );
        }
      }
    );
    const slottedSpan = document.querySelector('my-paragraph span');
    console.log(slottedSpan.assignedSlot);
    console.log(slottedSpan.slot);
  </code></pre>

  <h3>slotchange event</h3>

  <div class="example">
    <summary-display>
      <ul slot="master-list">
        <li>Apples</li>
        <li>Pears</li>
        <li>Bananas</li>
        <li>Oranges</li>
        <li>Peaches</li>
        <li>Strawberries</li>
        <li>Blueberries</li>
      </ul>
      <p data-name="Apples">A common, sweet, crun... or yellow in color.</p>
      <p data-name="Pears">A fairly common, sweet, u...it, usually softer than Apples.</p>
      <p data-name="Bananas">A long, curved, yellow f... fairly gentle flavor.</p>
      <p data-name="Oranges">Orange in color, usually s... sharp, often contains pips.</p>
      <p data-name="Peaches">An orange fruit with big...le, and sweet, juicy flesh.</p>
      <p data-name="Strawberries">A red fruit with yell... sweet flavor and a pretty shape.</p>
      <p data-name="Blueberries">They are berries and they are blue; swee...und.</p>
    </summary-display>
    <template id="summary-display-template">
      <article>
        <div>
          <slot name="master-list"></slot>
        </div>
        <div>
          <slot name="choice"></slot>
        </div>
      </article>
    </template>
  </div>

  <script>
    customElements.define('summary-display',
      class extends HTMLElement {
        constructor() {
          super();

          const template = document.getElementById('summary-display-template');
          const templateContent = template.content;

          const shadowRoot = this.attachShadow({mode: 'open'});
          shadowRoot.appendChild(templateContent.cloneNode(true));

          const items = Array.from(this.querySelectorAll('li'));
          const descriptions = Array.from(this.querySelectorAll('p'));

          items.forEach(item => {
            handleClick(item);
          });

          function handleClick(item) {
            item.addEventListener('click', function() {
              items.forEach(item => {
                item.style.backgroundColor = 'white';
              });

              descriptions.forEach(description => {
                updateDisplay(description, item);
              });
            });
          }

          function updateDisplay(description, item) {
            description.removeAttribute('slot');

            if(description.getAttribute('data-name') === item.textContent) {
              description.setAttribute('slot', 'choice');
              item.style.backgroundColor = '#bad0e4';
            }
          }

          const slots = this.shadowRoot.querySelectorAll('slot');
          slots[1].addEventListener('slotchange', function(e) {
            const nodes = slots[1].assignedNodes();
            // console.log(`Element in Slot "${slots[1].name}" changed to "${nodes[0].outerHTML}".`);
          });
        }
      }
    );
  </script>

  <pre><code class="html">
    &lt;summary-display&gt;
      &lt;ul slot="master-list"&gt;
        &lt;li&gt;Apples&lt;/li&gt;
        &lt;li&gt;Pears&lt;/li&gt;
        &lt;li&gt;Bananas&lt;/li&gt;
        &lt;li&gt;Oranges&lt;/li&gt;
        &lt;li&gt;Peaches&lt;/li&gt;
        &lt;li&gt;Strawberries&lt;/li&gt;
        &lt;li&gt;Blueberries&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p data-name="Apples"&gt;A common, sweet, crunchy fruit, usually green or yellow in color.&lt;/p&gt;
      &lt;p data-name="Pears"&gt;A fairly common, sweet, usually green fruit, usually softer than Apples.&lt;/p&gt;
      &lt;p data-name="Bananas"&gt;A long, curved, yellow fruit, with a fairly gentle flavor.&lt;/p&gt;
      &lt;p data-name="Oranges"&gt;Orange in color, usually sweet but can be sharp, often contains pips.&lt;/p&gt;
      &lt;p data-name="Peaches"&gt;An orange fruit with big stone in the middle, and sweet, juicy flesh.&lt;/p&gt;
      &lt;p data-name="Strawberries"&gt;A red fruit with yellow seeds on the outside; has a sweet flavor and a pretty shape.&lt;/p&gt;
      &lt;p data-name="Blueberries"&gt;They are berries and they are blue; sweet in flavor, small in size, round.&lt;/p&gt;
    &lt;/summary-display&gt;
    &lt;template id="summary-display-template"&gt;
      &lt;article&gt;
        &lt;div&gt;
          &lt;slot name="master-list"&gt;&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div&gt;
          &lt;slot name="choice"&gt;&lt;/slot&gt;
        &lt;/div&gt;
      &lt;/article&gt;
    &lt;/template&gt;
  </code></pre>

  <pre><code class="javascript">
    customElements.define('summary-display',
      class extends HTMLElement {
        constructor() {
          super();
          const template = document.getElementById('summary-display-template');
          const templateContent = template.content;
          const shadowRoot = this.attachShadow({mode: 'open'});
          shadowRoot.appendChild(templateContent.cloneNode(true));
          const items = Array.from(this.querySelectorAll('li'));
          const descriptions = Array.from(this.querySelectorAll('p'));
          items.forEach(item =&gt; {
            handleClick(item);
          });
          function handleClick(item) {
            item.addEventListener('click', function() {
              items.forEach(item =&gt; {
                item.style.backgroundColor = 'white';
              });
              descriptions.forEach(description =&gt; {
                updateDisplay(description, item);
              });
            });
          }
          function updateDisplay(description, item) {
            description.removeAttribute('slot');
            if(description.getAttribute('data-name') === item.textContent) {
              description.setAttribute('slot', 'choice');
              item.style.backgroundColor = '#bad0e4';
            }
          }
          const slots = this.shadowRoot.querySelectorAll('slot');
          slots[1].addEventListener('slotchange', function(e) {
            const nodes = slots[1].assignedNodes();
            console.log(`Element in Slot "${slots[1].name}" changed to "${nodes[0].outerHTML}".`);
          });
        }
      }
    );
  </code></pre>

  <h3>slotted pseudo-class</h3>


  <div class="example">
    <template id="person-template">
      <div>
        <h2>Personal ID Card</h2>
        <slot name="person-name">NAME MISSING</slot>
        <ul>
          <li><slot name="person-age">AGE MISSING</slot></li>
          <li><slot name="person-occupation">OCCUPATION MISSING</slot></li>
        </ul>
      </div>
    </template>
  </div>

  <div class="example">
    <person-details>
      <p slot="person-name">Morgan Stanley</p>
      <span slot="person-age">36</span>
      <span slot="person-occupation">Accountant</span>
    </person-details>
    <person-details>
      <p slot="person-name">Dr. Shazaam</p>
      <span slot="person-age">Immortal</span>
      <span slot="person-occupation">Superhero</span>
    </person-details>
    <person-details>
      <p slot="person-name">Boris</p>
      <span slot="age">27</span>
      <span slot="i-am-awesome">Time traveller</span>
    </person-details>
  </div>

  <script>
    customElements.define('person-details',
      class extends HTMLElement {
        constructor() {
          super();

          const template = document.getElementById('person-template');
          const templateContent = template.content;

          const shadowRoot = this.attachShadow({mode: 'open'});

          const style = document.createElement('style');
          style.textContent = `
            div { padding: 10px; border: 1px solid gray; width: 200px; margin: 10px; }
            h2 { margin: 0 0 10px; }
            ul { margin: 0; }
            p { margin: 10px 0; }
            ::slotted(*) { color: gray; font-family: sans-serif; }
          `;

          shadowRoot.appendChild(style);
          shadowRoot.appendChild(templateContent.cloneNode(true));
      }
    });
  </script>

  <pre><code class="html">
    &lt;template id="person-template"&gt;
      &lt;div&gt;
        &lt;h2&gt;Personal ID Card&lt;/h2&gt;
        &lt;slot name="person-name"&gt;NAME MISSING&lt;/slot&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;slot name="person-age"&gt;AGE MISSING&lt;/slot&gt;&lt;/li&gt;
          &lt;li&gt;&lt;slot name="person-occupation"&gt;OCCUPATION MISSING&lt;/slot&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;person-details&gt;
      &lt;p slot="person-name"&gt;Morgan Stanley&lt;/p&gt;
      &lt;span slot="person-age"&gt;36&lt;/span&gt;
      &lt;span slot="person-occupation"&gt;Accountant&lt;/span&gt;
    &lt;/person-details&gt;
    &lt;person-details&gt;
      &lt;p slot="person-name"&gt;Dr. Shazaam&lt;/p&gt;
      &lt;span slot="person-age"&gt;Immortal&lt;/span&gt;
      &lt;span slot="person-occupation"&gt;Superhero&lt;/span&gt;
    &lt;/person-details&gt;
    &lt;person-details&gt;
      &lt;p slot="person-name"&gt;Boris&lt;/p&gt;
      &lt;span slot="age"&gt;27&lt;/span&gt;
      &lt;span slot="i-am-awesome"&gt;Time traveller&lt;/span&gt;
    &lt;/person-details&gt;
  </code></pre>

  <pre><code class="javascript">
    customElements.define('person-details',
      class extends HTMLElement {
        constructor() {
          super();
          const template = document.getElementById('person-template');
          const templateContent = template.content;
          const shadowRoot = this.attachShadow({mode: 'open'});
          const style = document.createElement('style');
          style.textContent = `
            div { padding: 10px; border: 1px solid gray; width: 200px; margin: 10px; }
            h2 { margin: 0 0 10px; }
            ul { margin: 0; }
            p { margin: 10px 0; }
            ::slotted(*) { color: gray; font-family: sans-serif; }
          `;
          shadowRoot.appendChild(style);
          shadowRoot.appendChild(templateContent.cloneNode(true));
      }
    });
  </code></pre>

  <h3>word count</h3>


  <div class="example">
    <article contenteditable="">
      <h2>Sample heading</h2>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc pulvinar sed justo sed viverra. Aliquam ac scelerisque tellus. Vivamus porttitor nunc vel nibh rutrum hendrerit. Donec viverra vestibulum pretium. Mauris at eros vitae ante pellentesque bibendum. Etiam et blandit purus, nec aliquam libero. Etiam leo felis, pulvinar et diam id, sagittis pulvinar diam. Nunc pellentesque rutrum sapien, sed faucibus urna sodales in. Sed tortor nisl, egestas nec egestas luctus, faucibus vitae purus. Ut elit nunc, pretium eget fermentum id, accumsan et velit. Sed mattis velit diam, a elementum nunc facilisis sit amet.</p>
      <p>Pellentesque ornare tellus sit amet massa tincidunt congue. Morbi cursus, tellus vitae pulvinar dictum, dui turpis faucibus ipsum, nec hendrerit augue nisi et enim. Curabitur felis metus, euismod et augue et, luctus dignissim metus. Mauris placerat tellus id efficitur ornare. Cras enim urna, vestibulum vel molestie vitae, mollis vitae eros. Sed lacinia scelerisque diam, a varius urna iaculis ut. Nam lacinia, velit consequat venenatis pellentesque, leo tortor porttitor est, sit amet accumsan ex lectus eget ipsum. Quisque luctus, ex ac fringilla tincidunt, risus mauris sagittis mauris, at iaculis mauris purus eget neque. Donec viverra in ex sed ullamcorper. In ac nisi vel enim accumsan feugiat et sed augue. Donec nisl metus, sollicitudin eu tempus a, scelerisque sed diam.</p>
      <p is="word-count"></p>
    </article>
  </div>

  <script>// Create a class for the element
    class WordCount extends HTMLParagraphElement {
      constructor() {
        // Always call super first in constructor
        super();

        // count words in element's parent element
        const wcParent = this.parentNode;

        function countWords(node){
          const text = node.innerText || node.textContent;
          return text.split(/\s+/g).length;
        }

        const count = `Words: ${countWords(wcParent)}`;

        // Create a shadow root
        const shadow = this.attachShadow({mode: 'open'});

        // Create text node and add word count to it
        const text = document.createElement('span');
        text.textContent = count;

        // Append it to the shadow root
        shadow.appendChild(text);

        // Update count when element content changes
        setInterval(function() {
          const count = `Words: ${countWords(wcParent)}`;
          text.textContent = count;
        }, 200);
      }
    }

    // Define the new element
    customElements.define('word-count', WordCount, { extends: 'p' });
  </script>

  <pre><code class="html">
    &lt;article contenteditable=""&gt;
      &lt;h2&gt;Sample heading&lt;/h2&gt;
      &lt;p&gt;Lorem ipsum dolor sit amet, ...erisque sed diam.&lt;/p&gt;
      &lt;p is="word-count"&gt;&lt;/p&gt;
    &lt;/article&gt;
  </code></pre>

  <pre><code class="javascript">
    class WordCount extends HTMLParagraphElement {
      constructor() {
        // Always call super first in constructor
        super();
        // count words in element's parent element
        const wcParent = this.parentNode;
        function countWords(node){
          const text = node.innerText || node.textContent;
          return text.split(/\s+/g).length;
        }
        const count = `Words: ${countWords(wcParent)}`;
        // Create a shadow root
        const shadow = this.attachShadow({mode: 'open'});
        // Create text node and add word count to it
        const text = document.createElement('span');
        text.textContent = count;
        // Append it to the shadow root
        shadow.appendChild(text);
        // Update count when element content changes
        setInterval(function() {
          const count = `Words: ${countWords(wcParent)}`;
          text.textContent = count;
        }, 200);
      }
    }
    // Define the new element
    customElements.define('word-count', WordCount, { extends: 'p' });
  </code></pre>

  <ul>

    <li><strong>CUSTOM ELEMENTS</strong></li>

    <li>CustomElementRegistry - methods for registering custom elements and querying registered elements, window.customElements - instance of it
    <ul>
      <li>methods</li>
      <li>define(el_name, constructor[,{extends:built_in_el}]) - defines a new custom element, el_name should containt dash ( - , they can't be single words)</li>
      <li>get(name) - returns constuctor for the named custom element OR undefined if the custom element is not defined</li>
      <li>whenDefined(name) - returns an empty promise that resolves when a custom element becomes defined with the given name, if such a custom element is already defined, the returned promise is immediately fulfilled</li>
    </ul></li>

    <li>life cycle callbacks - special callback functions defined inside the custom elements class definition, which affect its behavior
    <ul>
      <li>connectedCallback - first connected to the documents DOM</li>
      <li>disconnectedCallback - disconnected from the documents DOM</li>
      <li>adoptedCallback - moved to a new document</li>
      <li>attributeChangedCallback - ne of the custom elements attributes is added, removed, or changed</li>
    </ul></li>

    <li>extensions for creating custom built-in elements
    <ul>
      <li>is - <u>global HTML attribute</u>, allows you to specify that a standard HTML element should behave like a registered custom built-in element</li>
      <li>is - <u>option</u> of the Document.createElement() method, allows you to create an instance of a standard HTML element that behaves like a given registered custom built-in element</li>
    </ul></li>

    <li>CSS pseudo-classes
    <ul>
      <li>properties</li>
      <li>:defined - matches any element that is defined, including built in elements and custom elements defined with CustomElementRegistry.define()</li>
      <li>:host - selects the shadow host of the shadow DOM containing the CSS it is used inside</li>
      <li>:host(compound_selector) - selects the shadow host of the shadow DOM containing the CSS it is used inside (so you can select a custom element from inside its shadow DOM) - but only if the selector given as the functions parameter matches the shadow host</li>
      <li>:host-context(compound_selector) - selects the shadow host of the shadow DOM containing the CSS it is used inside (so you can select a custom element from inside its shadow DOM) â€” but only if the selector given as the function's parameter matches the shadow host's ancestor(s) in the place it sits inside the DOM hierarchy</li>
    </ul></li>

    <li><strong>SHADOW DOM</strong></li>

    <li>ShadowRoot - root node of a DOM subtree that is rendered separately from a documents main DOM tree, you can retrieve a reference to an elements shadow root using its Element.shadowRoot property, provided it was created using Element.attachShadow() with the mode option set to open
    <ul>
      <li>properties</li>
      <li>mode - mode of the ShadowRoot â€” either open or closed, defines whether or not the shadow root internal features are accessible from JavaScript</li>
      <li>host - reference to the DOM element the ShadowRoot is attached to</li>
      <li>innerHTML - sets or returns a reference to the DOM tree inside the ShadowRoot</li>
      <li>activeElement - Element within the shadow tree that has focus</li>
      <li>styleSheets - StyleSheetList of CSSStyleSheet objects for stylesheets explicitly linked into, or embedded in a document</li>
      <li>methods</li>
      <li>getSelection() - Selection object representing the range of text selected by the user, or the current position of the caret</li>
      <li>elementFromPoint() - topmost element at the specified coordinates</li>
      <li>elementsFromPoint() - array of all elements at the specified coordinates</li>
      <li>caretPositionFromPoint() - CaretPosition object containing the DOM node containing the caret, and caret's character offset within that node</li>
    </ul></li>

    <li>DocumentOrShadowRoot - a mixin defining features that are available across document and shadow roots</li>

    <li>Element extensions
    <ul>
      <li>attachShadow({mode:open|closed}) - attaches a shadow DOM tree to the specified element</li>
      <li>shadowRoot - shadow root attached to the specified element OR null if there is no shadow root attached</li>
    </ul></li>

    <li>Node extensions
    <ul>
      <li>getRootNode([{composed:false|true}]) - context objects root, which optionally includes the shadow root if it is availabl</li>
      <li>isConnected - boolean indicating whether or not the Node is connected (directly or indirectly) to the context object, e.g. the Document object in the case of the normal DOM, or the ShadowRoot in the case of a shadow DOM</li>
    </ul></li>

    <li>Event extensions
    <ul>
      <li>composed - whether the event will propagate across the shadow DOM boundary into the standard DOM (true), or not  (false)</li>
      <li>composedPath - event path (objects on which listeners will be invoked), does not include nodes in shadow trees if the shadow root was created with ShadowRoot.mode closed</li>
    </ul></li>

    <li><strong>HTML TEMPLATES</strong></li>

    <li>&lt;template&gt; - contains an HTML fragment that is not rendered when a containing document is initially loaded, but can be displayed at runtime using JavaScript, mainly used as the basis of custom element structures, associated DOM interface is HTMLTemplateElement
      <ul>
        <li>properties</li>
        <li>content - contains template contents</li>
      </ul>
    </li>

    <li>&lt;slot&gt; - a placeholder inside a web component that you can fill with your own markup, which lets you create separate DOM trees and present them together, associated DOM interface is HTMLSlotElement
      <ul>
        <li>name - get and set the slots name</li>
        <li>assignedNodes() - sequence of elements assigned to this slot, or alternatively the slot's fallback content</li>
      </ul>
    </li>

    <li>slot - global HTML attribute, assigns a slot in a shadow DOM shadow tree to an element</li>

    <li>slotchange  - event, fired on an HTMLSlotElement instance (slot element) when the node(s) contained in that slot change</li>

    <li>Slotable - mixin, implemented by both Element and Text nodes, defining features that allow them to become the contents of an slot element
    <ul>
      <li>assignedSlot - the slot the node is inserted in</li>
    </ul></li>

    <li>Element extensions
    <ul>
      <li>slot - name of the shadow DOM slot attached to the element</li>
    </ul></li>

    <li>CSS pseudo-elements
    <ul>
      <li>::slotted(compound_selector) - matches any content that is inserted into a slot</li>
    </ul></li>

  </ul>

  <img src="../images/shadow-dom.png" style="width:80%;margin-left:10%;"/>

  <ul>
    <li><strong>HTMLElement interface extensions:</strong></li>
    <li>HTMLAnchorElement</li>
    <li>HTMLAreaElement</li>
    <li>HTMLAudioElement</li>
    <li>HTMLBRElement</li>
    <li>HTMLBaseElement</li>
    <li>HTMLBaseFontElement</li>
    <li>HTMLBodyElement</li>
    <li>HTMLButtonElement</li>
    <li>HTMLCanvasElement</li>
    <li>HTMLContentElement</li>
    <li>HTMLDListElement</li>
    <li>HTMLDataElement</li>
    <li>HTMLDataListElement</li>
    <li>HTMLDialogElement</li>
    <li>HTMLDivElement</li>
    <li>HTMLDocument</li>
    <li>HTMLEmbedElement</li>
    <li>HTMLFieldSetElement</li>
    <li>HTMLFormControlsCollection</li>
    <li>HTMLFormElement</li>
    <li>HTMLFrameSetElement</li>
    <li>HTMLHRElement</li>
    <li>HTMLHeadElement</li>
    <li>HTMLHeadingElement</li>
    <li>HTMLHtmlElement</li>
    <li>HTMLIFrameElement</li>
    <li>HTMLImageElement</li>
    <li>HTMLInputElement</li>
    <li>HTMLIsIndexElement</li>
    <li>HTMLKeygenElement</li>
    <li>HTMLLIElement</li>
    <li>HTMLLabelElement</li>
    <li>HTMLLegendElement</li>
    <li>HTMLLinkElement</li>
    <li>HTMLMapElement</li>
    <li>HTMLMediaElement</li>
    <li>HTMLMetaElement</li>
    <li>HTMLMeterElement</li>
    <li>HTMLModElement</li>
    <li>HTMLOListElement</li>
    <li>HTMLObjectElement</li>
    <li>HTMLOptGroupElement</li>
    <li>HTMLOptionElement</li>
    <li>HTMLOptionsCollection</li>
    <li>HTMLOutputElement</li>
    <li>HTMLParagraphElement</li>
    <li>HTMLParamElement</li>
    <li>HTMLPictureElement</li>
    <li>HTMLPreElement</li>
    <li>HTMLProgressElement</li>
    <li>HTMLQuoteElement</li>
    <li>HTMLScriptElement</li>
    <li>HTMLSelectElement</li>
    <li>HTMLShadowElement</li>
    <li>HTMLSourceElement</li>
    <li>HTMLSpanElement</li>
    <li>HTMLStyleElement</li>
    <li>HTMLTableCaptionElement</li>
    <li>HTMLTableCellElement</li>
    <li>HTMLTableColElement</li>
    <li>HTMLTableDataCellElement</li>
    <li>HTMLTableElement</li>
    <li>HTMLTableHeaderCellElement</li>
    <li>HTMLTableRowElement</li>
    <li>HTMLTableSectionElement</li>
    <li>HTMLTemplateElement</li>
    <li>HTMLTextAreaElement</li>
    <li>HTMLTimeElement</li>
    <li>HTMLTitleElement</li>
    <li>HTMLTrackElement</li>
    <li>HTMLUListElement</li>
    <li>HTMLUnknownElement</li>
    <li>HTMLVideoElement</li>
  </ul>



<br/>
<a href="../index.html" id="main_page_link">Back to Main Page</a>
<br/>
<br/>
<br/>

</body>
</html>
