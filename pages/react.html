<!DOCTYPE html>
<html lang="en-US">
<head>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="React tutorials and examples, Web Engineer Book">
  <meta name="keywords" content="react, 16.8, 17, 18, js, hooks, usestate, useeffect, useref, usereducer, usecallback, usememo, memo, custom hook, use, jsx, component, render, state, props, forms, reactive, context, hoc, tutorials, examples, cheat sheet, help, documentation, web, engineer, book">
  <meta name="author" content="Andrei, andreivinyl@gmail.com">

  <link rel="manifest" href="../manifest.webmanifest">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">

  <link rel="stylesheet" href="../js/highlight/styles/default.css">
  <link rel="stylesheet" href="../css/css.css">

  <script src="../js/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script src="../js/utils.js"></script>
  <!-- Load React. -->
  <!-- Note: when deploying, replace "development.js" with "production.min.js". -->
  <script src="../js/react.development.js" crossorigin></script>
  <script src="../js/react-dom.development.js" crossorigin></script>
  <script src="../js/prop-types.js" crossorigin></script>
  <script src="../js/babel.min.js" crossorigin></script>

  <title>React tutorials and examples - Web Engineer Book</title>

</head>

<body>

<h2 id="intro">Intro</h2>

  <ul>
    <li>React|ReactDOM is the entry point to the React library
      <ul>
        <li>directly available if React is loaded using tag</li>
        <li>import React|ReactDOM  from 'react|react-dom' - if you use ES6 with npm</li>
        <li>var React|ReactDOM = require('react|react-dom') - if you use ES5 with npm</li>
      </ul>
    </li>
    <li>for older browsers support, React needs collection types Map and Set, include polyfills
      <ul>
        <li>core-js or babel-polyfill
          <ul>
            <li>import 'core-js/es6/map';</li>
            <li>import 'core-js/es6/set';</li>
          </ul>
        </li>
        <li>and requestAnimationFrame, <a href="https://www.npmjs.com/package/raf">npmjs.com/package/raf</a>: import 'raf/polyfill' | var raf = require('raf')</li>
        <li><strong>React depends on modern browsers features including Promise, Symbol, and Object.assign, if you support older browsers and devices such as Internet Explorer which do not provide modern browser features natively or have non-compliant implementations, consider including a global polyfill in bundled application</strong></li>
      </ul>
    </li>
    <li><a href="https://github.com/facebook/react/tree/master/packages/react-devtools">react-devtools</a></li>
    <li>recommended toolchains:
      <ul>
        <li>Create React App - creates a frontend build pipeline</li>
          <ul>
            <li><code>npx create-react-app my-app</code></li>
            <li><code>cd my-app</code></li>
            <li><code>npm start</code></li>
            <li><code>npm run build</code> - create an optimized build of app in the "build" folder</li>
          </ul>
        <li>Next.js - lightweight framework for static and server-rendered applications built with React, includes styling and routing solutions</li>
        <li>Gatsby - to create static websites with React, lets you use React components, but outputs pre-rendered HTML and CSS to guarantee the fastest load time</li>
        <li>Neutrino - combines the power of webpack with the simplicity of presets, and includes a preset for React apps and React components</li>
        <li>nwb - for publishing React components for npm, can be used for creating React apps, too</li>
        <li>Parcel - fast, zero configuration web application bundler that works with React</li>
        <li>Razzle - server-rendering framework that doesnt require any configuration, but offers more flexibility than Next.js</li>
      </ul>
    </li>
    <li>JS build toolchain typically consists of:
      <ul>
        <li>package manager - Yarn or npm, take advantage of a vast ecosystem of third-party packages, and easily install or update them</li>
        <li>bundler - webpack or Parcel, write modular code and bundle it together into small packages to optimize load time</li>
        <li>compiler - Babel, write modern JavaScript code that still works in older browsers</li>
      </ul>
    </li>
    <li><strong>replace react.development.js with react.production.min.js</strong></li>
    <li>CDN:
      <ul>
        <li>https://unpkg.com/react@18/umd/react.production.min.js</li>
        <li>https://unpkg.com/react-dom@18/umd/react-dom.production.min.js</li>
        <li>keep crossorigin attribute: &lt;script crossorigin src="..."&gt;</li>
        <li>verify that the CDN you are using sets the Access-Control-Allow-Origin: * HTTP header</li>
      </ul>
    </li>
  </ul>

  <pre><code class="html">
    &lt;!-- Load React as script from CDN--&gt;
    &lt;!-- NOTE: when deploying, replace "development.js" with "production.min.js" --&gt;
    &lt;script
      src="https://unpkg.com/react@18/umd/react.development.js"
      crossorigin
    &gt;&lt;/script&gt;
    &lt;script
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
      crossorigin
    &gt;&lt;/script&gt;
    &lt;!-- Load React component --&gt;
    &lt;script src="like_button.js"&gt;&lt;/script&gt;
  </code></pre>

  <pre><code class="">
    // import
    import * as ReactDOM from 'react-dom/client';
    // if you use ES5 with npm, you can write:
    var ReactDOM = require('react-dom/client');
  </code></pre>



<h2 id="jsx">JSX</h2>

  <ul>
    <li><strong>syntactic sugar for the React.createElement(component, props, ...children)</strong></li>
    <li>use JSX
      <ul>
        <li>Development method:</li>
        <li>&lt;script src="../js/babel.min.js" crossorigin&gt;&lt;/script&gt;</li>
        <li>use JSX in any script-tag by adding <strong>type="text/babel"</strong> attribute</li>
        <li>Adding to project:</li>
        <li>go to project folder</li>
        <li><code>npm init -y</code></li>
        <li><code>npm install babel-cli@6 babel-preset-react-app@3</code></li>
        <li>create "src" folder</li>
        <li>start an automated watcher for JSX:<br>
          <code>npx babel --watch src --out-dir . --presets react-app/prod</code></li>
        <li>work inside "src" folder and preprocessor will re-run automatically</li>
      </ul>
    </li>
    <li>React DOM uses camelCase property naming convention instead of HTML attribute names: class becomes className in JSX, and tabindex becomes tabIndex, exception is aria-* and data-* attributes, which should be lowercased</li>
    <li>Babel compiles JSX down to React.createElement() calls</li>
    <li>React DOM escapes any values embedded in JSX before rendering them</li>
    <li><strong>{/* Comment goes here */}</strong> - comments in JSX</li>
  </ul>

  <pre><code class="">
    &lt;MyButton color="blue" shadowSize={2}&gt;
      Click Me
    &lt;/MyButton&gt;
    // compiles into:
    React.createElement(
      MyButton,
      {color: 'blue', shadowSize: 2},
      'Click Me'
    )

    class Hello extends React.Component {
      render() {
        return &lt;div&gt;Hello {this.props.toWhat}&lt;/div&gt;;
      }
    }
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(&lt;Hello toWhat="World" /&gt;);
    // can be compiled to this code that does not use JSX:
    class Hello extends React.Component {
      render() {
        return React.createElement('div', null, `Hello ${this.props.toWhat}`);
      }
    }
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(Hello, {toWhat: 'World'}, null));

    // --- self-closing form of the tag if there are no children
    &lt;div className="sidebar" /&gt;
    // compiles into:
    React.createElement(
      'div',
      {className: 'sidebar'},
      null
    )

    // --- React library must also always be in scope from JSX code
    // NOT required if using via script tag
    import React from 'react';
    import CustomButton from './CustomButton';
    function WarningButton() {
      // return React.createElement(CustomButton, {color: 'red'}, null);
      // --- if you use the JSX &lt;Foo /&gt; expression, Foo must be in scope
      return &lt;CustomButton color="red" /&gt;;
    }

    // --- using dot notation for jsx type
    const MyComponents = {
      DatePicker: function DatePicker(props) {
        return &lt;div&gt;Imagine a {props.color} datepicker here.&lt;/div&gt;;
      }
    }
    function BlueDatePicker() {
      return &lt;MyComponents.DatePicker color="blue" /&gt;;
    }

    // --- user-defined components must be capitalized
    // to not mess with standard tags
    function Hello(props) {
      return &lt;div&gt;Hello {props.toWhat}&lt;/div&gt;;
    }
    function HelloWorld() {
      return &lt;Hello toWhat="World" /&gt;;
    }

    // --- if you do want to use a general expression to indicate the type of the element,
    // just assign it to a capitalized variable first
    import React from 'react';
    import { PhotoStory, VideoStory } from './stories';
    const components = {
      photo: PhotoStory,
      video: VideoStory
    };
    function Story(props) {
      // Wrong! JSX type can't be an expression.
      // return &lt;components[props.storyType] story={props.story} /&gt;;
      // Correct! JSX type can be a capitalized variable.
      const SpecificStory = components[props.storyType];
      return &lt;SpecificStory story={props.story} /&gt;;
    }
  </code></pre>

  <h3>Props</h3>
  <pre><code class="">
    // --- pass any JS expression as a prop, by surrounding it with {}
    &lt;MyComponent foo={1 + 2 + 3 + 4} /&gt; // props.foo will be 10

    // --- put if/for in the surrounding code
    // check "conditional" and "list/key" section
    function NumberDescriber(props) {
      let description;
      if (props.number % 2 == 0) {
        description = &lt;strong&gt;even&lt;/strong&gt;;
      } else {
        description = &lt;i&gt;odd&lt;/i&gt;;
      }
      return &lt;div&gt;{props.number} is an {description} number&lt;/div&gt;;
    }

    // --- string literals, following are equivalent
    &lt;MyComponent message="hello world" /&gt;
    &lt;MyComponent message={'hello world'} /&gt;
    &lt;MyComponent message="&lt;3" /&gt;
    &lt;MyComponent message={'&lt;3'} /&gt;

    // --- props default to "true", following are equivalent
    &lt;MyTextBox autocomplete /&gt;
    &lt;MyTextBox autocomplete={true} /&gt;

    // --- Spread Attributes
    // use "..." as a spread operator to pass the whole props object, following are equivalent
    function App1() {
      return &lt;Greeting firstName="Ben" lastName="Hector" /&gt;;
    }
    function App2() {
      const props = {firstName: 'Ben', lastName: 'Hector'};
      return &lt;Greeting {...props} /&gt;;
    }
    // pick specific props that component will consume
    // while passing all other props using the spread operator
    const Button = props =&gt; {
      const { kind, ...other } = props;
      const className = kind === "primary" ? "PrimaryButton" : "SecondaryButton";
      return &lt;button className={className} {...other} /&gt;;
    };
    const App = () =&gt; {
      return (
        &lt;div&gt;
          &lt;Button kind="primary" onClick={() =&gt; console.log("clicked!")}&gt;
            Hello World!
          &lt;/Button&gt;
        &lt;/div&gt;
      );
    };
  </code></pre>

  <h3>Children</h3>
  <pre><code class="">
    // JSX expressions that contain both an opening tag and a closing tag,
    // the content between those tags is passed as a special prop: props.children

    // --- string literals
    &lt;MyComponent&gt;Hello world!&lt;/MyComponent&gt;
    // props.children in MyComponent will simply be the string "Hello world!"
    // HTML is unescaped, multiple spaces/tab/newline are removed

    // --- more JSX elements as the children
    &lt;MyContainer&gt;
      &lt;MyFirstComponent /&gt;
      &lt;MySecondComponent /&gt;
    &lt;/MyContainer&gt;
    // mix together different types of children
    &lt;div&gt;
      Here is a list:
      &lt;ul&gt;
        &lt;li&gt;Item 1&lt;/li&gt;
        &lt;li&gt;Item 2&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
    // return an array of elements
    render() {
      // No need to wrap list items in an extra element!
      return [
        // Don't forget the keys :)
        &lt;li key="A"&gt;First item&lt;/li&gt;,
        &lt;li key="B"&gt;Second item&lt;/li&gt;,
        &lt;li key="C"&gt;Third item&lt;/li&gt;,
      ];
    }

    // --- JS expressions as children
    // following are equivalent
    &lt;MyComponent&gt;foo&lt;/MyComponent&gt;
    &lt;MyComponent&gt;{'foo'}&lt;/MyComponent&gt;
    // render an HTML list
    function Item(props) {
      return &lt;li&gt;{props.message}&lt;/li&gt;;
    }
    function TodoList() {
      const todos = ['finish doc', 'submit pr', 'nag dan to review'];
      return (
        &lt;ul&gt;
          {todos.map((message) =&gt; &lt;Item key={message} message={message} /&gt;)}
        &lt;/ul&gt;
      );
    }
    // mixed with other types of children
    function Hello(props) {
      return &lt;div&gt;Hello {props.addressee}!&lt;/div&gt;;
    }

    // --- functions as children
    // take a callback as props.children
    // call the children callback numTimes to produce a repeated component
    function Repeat(props) {
      let items = [];
      for (let i = 0; i &lt; props.numTimes; i++) {
        items.push(props.children(i));
      }
      return &lt;div&gt;{items}&lt;/div&gt;;
    }
    function ListOfTenThings() {
      return (
        &lt;Repeat numTimes={10}&gt;
          {(index) =&gt; &lt;div key={index}&gt;This is item {index} in the list&lt;/div&gt;}
        &lt;/Repeat&gt;
      );
    }

    // --- booleans, null, and undefined are ignored
    // same thing:
    &lt;div /&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;{false}&lt;/div&gt;
    &lt;div&gt;{null}&lt;/div&gt;
    &lt;div&gt;{undefined}&lt;/div&gt;
    &lt;div&gt;{true}&lt;/div&gt;
    // can be useful to conditionally render React elements
    &lt;div&gt;
      {showHeader && &lt;Header /&gt;}
      &lt;Content /&gt;
    &lt;/div&gt;
    // "falsy" values, such as the 0 number, are still rendered by React
    // make sure that the expression before && is always boolean
    &lt;div&gt;
      {props.messages.length &gt; 0 &&
        &lt;MessageList messages={props.messages} /&gt;
      }
    &lt;/div&gt;
    // convert to a string if you want
    //a value like false, true, null, or undefined to appear in the output
    &lt;div&gt;
      My JavaScript variable is {String(myVariable)}.
    &lt;/div&gt;
  </code></pre>

  <h3>Example</h3>
  <div class="example">

    <div class="like_button_container"></div>
    <div class="like_button_container" data-commentid="1"></div>
    <div class="like_button_container" data-commentid="2"></div>

  </div>

  <script type="text/babel">
    'use strict';
    const e = React.createElement;
    class LikeButton extends React.Component {
      constructor(props) {
        super(props);
        this.state = { liked: false };
      }
      render() {
        if (this.state.liked) {
          return 'You liked comment' +
            ( this.props.commentID ? ' number '+ this.props.commentID : '' );
        }
        // return e(
        //   'button',
        //   { onClick: () => this.setState({ liked: true }) },
        //   'Like'
        //     + ( this.props.commentID ? ' number '+ this.props.commentID : '' )
        // );
        // // --- JSX version
        return (
          <button onClick={() => this.setState({ liked: true })}>
            Like
          </button>
        );
      }
    }
    // Find all DOM containers, and render Like buttons into them.
    document.querySelectorAll('.like_button_container')
      .forEach(domContainer => {
        // Read the comment ID from a data-* attribute.
        const commentID = parseInt(domContainer.dataset.commentid, 10);
        const root = ReactDOM.createRoot(domContainer);
        root.render(e(LikeButton, { commentID: commentID }));
    });
  </script>

  <pre><code class="html">
    &lt;!-- put React component inside DIV --&gt;
    &lt;!-- ONCE --&gt;
    &lt;div id="like_button_container"&gt;&lt;/div&gt;
    &lt;!-- MULTIPLE --&gt;
    &lt;div class="like_button_container" data-commentid="1"&gt;&lt;/div&gt;
    &lt;div class="like_button_container" data-commentid="2"&gt;&lt;/div&gt;
  </code></pre>

  <pre><code class="html">
    &lt;script type="text/babel"&gt;
      'use strict';
      const e = React.createElement;
      class LikeButton extends React.Component {
        constructor(props) {
          super(props);
          this.state = { liked: false };
        }
        render() {
          if (this.state.liked) {
            return 'You liked comment number ' + this.props.commentID;
          }
          // return e(
          //   'button',
          //   { onClick: () =&gt; this.setState({ liked: true }) },
          //   'Like'
          //     + ( this.props.commentID ? ' number '+ this.props.commentID : '' )
          // );
          // // --- JSX version
          return (
            &lt;button onClick={() =&gt; this.setState({ liked: true })}&gt;
              Like
            &lt;/button&gt;
          );
        }
      }
      // Find all DOM containers, and render Like buttons into them
      document.querySelectorAll('.like_button_container') // or #like_button_container
        .forEach(domContainer =&gt; {
          // Read the comment ID from a data-* attribute.
          const commentID = parseInt(domContainer.dataset.commentid, 10);
          const root = ReactDOM.createRoot(domContainer);
          root.render(e(LikeButton, { commentID: commentID }));
      });
    &lt;/script&gt;
  </code></pre>



<h2 id="elements">Elements</h2>

  <ul>
    <li>React elements are immutable, once created, you cant change its children or attributes, represents the UI at a certain point in time</li>
  </ul>

  <div class="example"  id="elements_root"></div>
  <script type="text/babel">
    const elements_root = ReactDOM.createRoot(document.getElementById('elements_root'));
    function tick() {
      const element = (
        <div>
          <h3>It is {new Date().toLocaleTimeString()}</h3>
        </div>
      );
      elements_root.render(element);
    }
    setInterval(tick, 1000);
  </script>

  <pre><code class="javascript">
    // --- rendering into a root DOM node
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(&lt;h1&gt;Hello, world&lt;/h1&gt;);

    // --- updating
    const elements_root = ReactDOM.createRoot(document.getElementById('elements_root'));
    function tick() {
      const element = (
        &lt;div&gt;
          &lt;h3&gt;It is {new Date().toLocaleTimeString()}&lt;/h3&gt;
        &lt;/div&gt;
      );
      elements_root.render(element);
    }
    setInterval(tick, 1000);
  </code></pre>

  <h3>API</h3>
  <pre><code class="">
    // --- createElement()
    React.createElement(
      type, // tag name string, React component type (class|function), React fragment type
      [props],
      [...children]
    )

    // --- cloneElement()
    // clone and return a new React element using element as the starting point
    // resulting element will have the original element props with the new props merged in shallowly
    // new children will replace existing children
    // key and ref from the original element will be preserved
    React.cloneElement(
      element,
      [props],
      [...children]
    )
    // almost equivalent to:
    // &lt;element.type {...element.props} {...props}&gt;{children}&lt;/element.type&gt;
    // introduced as a replacement of the deprecated React.addons.cloneWithProps()

    // --- isValidElement()
    // verifies the object is a React element, returns true or false
    React.isValidElement(object)

    // --- React.Children
    // utilities for dealing with the this.props.children opaque data structure
    React.Children.map(children, fn[(thisArg)]) // returns array
    React.Children.forEach(children, fn[(thisArg)]) // does not return an array
    // number of times that a callback passed to map or forEach would be invoked
    React.Children.count(children)
    // verifies that children has only one child (a React element) and returns it
    // otherwise throws an error
    // does not accept the return value of React.Children.map() because it is an array
    React.Children.only(children)
    // children opaque data structure as a flat array with keys assigned to each child
    React.Children.toArray(children)
  </code></pre>



<h2 id="comprops">Component / Props / State</h2>

  <ul>
    <li>split the UI into independent, reusable pieces, and think about each piece in isolation</li>
    <li>like JS functions, accept arbitrary inputs (called <strong>props</strong>) and return React elements describing what should appear on the screen</li>
    <li>element representing a user-defined component passes JSX attributes to this component as a single object called "props"</li>
    <li>all React components must act like pure functions, <strong>never modify props, treat as read-only</strong></li>
    <li>convert a <strong>function to a class</strong>
      <ul>
        <li>create an ES6 class, with the same name, that extends React.Component</li>
        <li>add a single empty method to it called render()</li>
        <li>move the body of the function into the render() method</li>
        <li>replace props with this.props in the render() body</li>
        <li>delete the remaining empty function declaration</li>
        <li><strong>render() method is the only required method in a class component</strong></li>
      </ul>
    </li>
    <li><strong>state</strong> is similar to props, but it is private and fully controlled by the component, often called local or encapsulated, not accessible to any component other than the one that owns and sets it, component may choose to pass its state down as props to its child components, <u>assign this.state only in the constructor</u> and use setState() in other cases</li>
    <li>move <strong>props to state</strong>
      <ul>
        <li>replace this.props.* with this.state.* in the render() method</li>
        <li>add a class constructor that assigns the initial this.state</li>
        <li>remove prop from component call</li>
      </ul>
    </li>
    <li><strong>setState( stateChange [,callback] )</strong> - merges the object you provide into the current state, primary method to update the user interface,<strong>re-render a component, in response to event handlers</strong> and server responses
      <ul>
        <li>pass <strong>object as stateChange</strong> argument - shallow merge into the new state</li>
        <li>pass <strong>function as stateChange</strong> argument - mutate state</li>
        <li><u>request</u> rather than an immediate command to update the component, asynchronous inside event handlers</li>
        <li>subsequent calls will override values from previous calls in the same cycle, so the state will only be updated once, use the updater function form</li>
        <li><strong>use componentDidUpdate or a setState callback (setState(updater, callback)) to read this.state right after calling setState()</strong></li>
        <li>React <strong>may batch multiple setState() calls</strong> into a single update for performance before starting to re-render</li>
        <li>this.props and this.state may be updated asynchronously, <u>dont rely on their values for calculating the next state</u>, use a second form of <u>setState((state, props) => stateChange)</u> that accepts a function with state and prop rather than an object</li>
        <li>update several independent variables independently with separate setState()</li>
        <li>optional callback function - executed once setState is completed and the component is re-rendered, use componentDidUpdate() for such logic instead</li>
      </ul>
    </li>
    <li>since React 18 updates inside of timeouts, promises, native event handlers or any other event will batch the same way as updates inside of React events and avoid double re-rendering wrap state change into <code>flushSync(() => {...})</code> (<code>import { flushSync } from 'react-dom'</code>) if code may depend on reading something from the DOM immediately after a state change</li>
    <li><strong>forceUpdate(callback)</strong> - tell React that the component needs re-rendering
      <ul>
        <li>cause render() to be called on the component, skipping shouldComponentUpdate(), trigger the normal lifecycle methods for child components, including the shouldComponentUpdate() method of each child, only update the DOM if the markup changes</li>
        <li>avoid all uses of forceUpdate() and only read from this.props and this.state in render()</li>
      </ul>
    </li>
    <li>you are free to add additional fields to the class manually if you need to store something that does not participate in the data flow (like a timer ID)</li>
  </ul>

  <div class="example" id="comprops_root"></div>
  <script type="text/babel">
    class Welcome extends React.Component {
      render() {
        return <h3>Hello, {this.props.name}</h3>;
      }
    }
    function App() {
      return (
        <div>
          <Welcome name="Andrei" />
          <Welcome name="John" />
          <Welcome name="Leon" />
        </div>
      );
    }
    const comprops_root = ReactDOM.createRoot(document.getElementById('comprops_root'));
    comprops_root.render(<App />);
  </script>
  <pre><code class="">
    // JS function - simplest way to define a component
    function Welcome(props) {
      return &lt;h3&gt;Hello, {props.name}&lt;/h3&gt;;
    }
    const Example = (props) => {
      // You can use Hooks here!
      return &lt;div /&gt;;
    }
    // using ES6 class, equivalent from Reacts point of view
    class Welcome extends React.Component {
      render() {
        return &lt;h3&gt;Hello, {this.props.name}&lt;/h3&gt;;
      }
    }

    const element = &lt;Welcome name="Andrei" /&gt;; // represent user-defined components
    const comprops_root = ReactDOM.createRoot(document.getElementById('comprops_root'));
    comprops_root.render(element);

    // render many times
    function App() {
      return (
        &lt;div&gt;
          &lt;Welcome name="Andrei" /&gt;
          &lt;Welcome name="John" /&gt;
          &lt;Welcome name="Leon" /&gt;
        &lt;/div&gt;
      );
    }
    const comprops_root = ReactDOM.createRoot(document.getElementById('comprops_root'));
    comprops_root.render(&lt;App /&gt;);
  </code></pre>

  <h3>Control props & State reducers</h3>
  <pre><code class="">
    // Control props - allow complete control over state from outside the component
    // require that the consumer completely manage state themselves
    // means must have a class component with state and change handlers to update that state
    class Example extends React.Component {
      state = {on: false, inputValue: 'off'};
      handleToggle = on =&gt; {
        this.setState({on, inputValue: on ? 'on' : 'off'});
      }
      handleChange = ({target: {value}}) =&gt; {
        if (value === 'on') {
          this.setState({on: true});
        } else if (value === 'off') {
          this.setState({on: false});
        }
        this.setState({inputValue: value});
      }
      render() {
        const {on} = this.state;
        return (
          &lt;div&gt;
            {/* using the "value" control prop exposed by the input */}
            &lt;input value={this.state.inputValue} onChange={this.handleChange} /&gt;
            {/* using the "on" control prop exposed by the Toggle component */}
            &lt;Toggle on={on} onToggle={this.handleToggle} /&gt;
          &lt;/div&gt;
        );
      }
    }

    // State reducers - do not have to manage the component state themselves
    // they can manage some of their own state as needed
    class Example extends React.Component {
      initialState = {timesClicked: 0};
      state = this.initialState;
      handleToggle = (...args) =&gt; {
        this.setState(({timesClicked}) =&gt; ({
          timesClicked: timesClicked + 1,
        }));
      }
      handleReset = (...args) =&gt; {
        this.setState(this.initialState);
      }
      toggleStateReducer = (state, changes) =&gt; {
        if (this.state.timesClicked &gt;= 4) {
          return {...changes, on: false};
        }
        return changes;
      }
      render() {
        const {timesClicked} = this.state;
        return (
          &lt;div&gt;
            &lt;Toggle
              stateReducer={this.toggleStateReducer}
              onToggle={this.handleToggle}
              onReset={this.handleReset}
            /&gt;
            {timesClicked &gt; 4 ? (
              &lt;div&gt;Whoa, you clicked too much!&lt;/div&gt;
            ) : (
              &lt;div&gt;Click count: {timesClicked}&lt;/div&gt;
            )}
          &lt;/div&gt;
        )
      }
    }
  </code></pre>

  <details><summary>De/Compose Component</summary>
  <div class="example" id="comprops_2_root"></div>
  <script type="text/babel">
    function Avatar(props) {
      return (
        <img className="Avatar"
          src={props.user.avatarUrl}
          alt={props.user.name}
        />
      );
    }
    function UserInfo(props) {
      return (
        <div className="UserInfo">
          <Avatar user={props.user} />
          <div className="UserInfo-name">
            {props.user.name}
          </div>
        </div>
      );
    }
    function Comment(props) {
      return (
        <div className="Comment">
          <UserInfo user={props.author} />
          <div className="Comment-text">
            {props.text}
          </div>
          <div className="Comment-date">
            {formatDate(props.date)}
          </div>
        </div>
      );
    }

    const comment = {
      date: new Date(),
      text: 'Lets React!',
      author: {
        name: 'Hello Andrei',
        avatarUrl: '../images/colorpicker.gif',
      },
    };
    const comprops_2_root = ReactDOM.createRoot(document.getElementById('comprops_2_root'));
    comprops_2_root.render(<Comment
        date={comment.date}
        text={comment.text}
        author={comment.author}
      />
    );
    function formatDate(date) {
      return date.toLocaleDateString();
    }
  </script>
  <pre><code class="">
    function Avatar(props) {
      return (
        &lt;img className="Avatar"
          src={props.user.avatarUrl}
          alt={props.user.name}
        /&gt;
      );
    }
    function UserInfo(props) {
      return (
        &lt;div className="UserInfo"&gt;
          &lt;Avatar user={props.user} /&gt;
          &lt;div className="UserInfo-name"&gt;
            {props.user.name}
          &lt;/div&gt;
        &lt;/div&gt;
      );
    }
    function Comment(props) {
      return (
        &lt;div className="Comment"&gt;
          &lt;UserInfo user={props.author} /&gt;
          &lt;div className="Comment-text"&gt;
            {props.text}
          &lt;/div&gt;
          &lt;div className="Comment-date"&gt;
            {formatDate(props.date)}
          &lt;/div&gt;
        &lt;/div&gt;
      );
    }
    const comment = {
      date: new Date(),
      text: 'Lets React!',
      author: {
        name: 'Hello Andrei',
        avatarUrl: '../images/colorpicker.gif',
      },
    };
    const comprops_2_root = ReactDOM.createRoot(document.getElementById('comprops_2_root'));
    comprops_2_root.render(
      &lt;Comment
        date={comment.date}
        text={comment.text}
        author={comment.author}
      /&gt;
    );

    // --- instead of
    function Comment(props) {
      return (
        &lt;div className="Comment"&gt;
          &lt;div className="UserInfo"&gt;
            &lt;img className="Avatar"
              src={props.author.avatarUrl}`
              alt={props.author.name}
            /&gt;
            &lt;div className="UserInfo-name"&gt;
              {props.author.name}
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div className="Comment-text"&gt;
            {props.text}
          &lt;/div&gt;
          &lt;div className="Comment-date"&gt;
            {formatDate(props.date)}
          &lt;/div&gt;
        &lt;/div&gt;
      );
    }

    function formatDate(date) {
      return date.toLocaleDateString();
    }
  </code></pre>
  </details>

  <details><summary>Function to Class , Props to State</summary>
  <pre><code class="">
    function Clock(props) {
      return (
        &lt;div&gt;
          &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;
        &lt;/div&gt;
      );
    }

    class Clock extends React.Component {
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt;
          &lt;/div&gt;
        );
      }
    }

    class Clock extends React.Component {
      constructor(props) {
        super(props);
        this.state = {date: new Date()};
      }
      render() {
        return (
          &lt;div&gt;
            &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
          &lt;/div&gt;
        );
      }
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(&lt;Clock /&gt;);

    // --- pass local state down as props
    &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}&lt;/h2&gt;
    ...
    &lt;FormattedDate date={this.state.date} /&gt;
  </code></pre></details>

  <details><summary>setState(updater [,callback])</summary>
  <div class="example" id="comprops_3_root"></div>
  <script type="text/babel">
    class Clock extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          date: new Date(),
          counter: 0
        };
      }
      componentDidMount() {
        this.timerID = setInterval(
          () => this.tick(),
          1000
        );
      }
      componentWillUnmount() {
        clearInterval(this.timerID);
      }
      tick() {
        // --- simple setState
        // this.setState({
        //   date: new Date()
        // });
        // --- second form to use state and props together
        this.setState(
          // previous state (first argument)
          // props at the time the update is applied (second argument)
          (state, props) => ({
          // function(state, props) {
            date: new Date(),
            // counter: state.counter + 1
            counter: state.counter + props.increment
        }));
      }
      render() {
        return (
          <div>
            <h3>It is {this.state.date.toLocaleTimeString()}</h3>
            <h3>Counter is {this.state.counter}</h3>
          </div>
        );
      }
    }
    const comprops_3_root = ReactDOM.createRoot(document.getElementById('comprops_3_root'));
    comprops_3_root.render(<Clock increment={7}/>);
  </script>
  <pre><code class="">
    class Clock extends React.Component {
      constructor(props) {
        super(props);
        this.state = {date: new Date(), counter: 0};
      }
      componentDidMount() {
        this.timerID = setInterval(
          () => this.tick(),
          1000
        );
      }
      componentWillUnmount() {
        clearInterval(this.timerID);
      }
      tick() {
        // --- simple setState
        // this.setState({
        //   date: new Date()
        // });
        // --- second form, to use state and props together
        this.setState(
          // previous state (first argument)
          // props at the time the update is applied (second argument)
          (state, props) => ({
          // function(state, props) {
            date: new Date(),
            // counter: state.counter + 1
            counter: state.counter + props.increment
          // }
        }));
      }
      render() {
        return (
          &lt;div&gt;
            &lt;h3&gt;It is {this.state.date.toLocaleTimeString()}&lt;/h3&gt;
            &lt;h3&gt;Counter is {this.state.counter}&lt;/h3&gt;
          &lt;/div&gt;
        );
      }
    }
    const comprops_3_root = ReactDOM.createRoot(document.getElementById('comprops_3_root'));
    comprops_3_root.render(&lt;Clock increment={7}/&gt;);

    // --- update with separate setState() calls
    // ...
      constructor(props) {
        super(props);
        this.state = {
          posts: [],
          comments: []
        };
      }
      componentDidMount() {
        fetchPosts().then(response => {
          this.setState({
            posts: response.posts
          });
        });
        fetchComments().then(response => {
          this.setState({
            comments: response.comments
          });
        });
      }
    // ...
  </code></pre></details>

  <h3>API</h3>
  <pre><code class="">
    // --- React.Component
    class Greeting extends React.Component {
      render() {
        return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
      }
    }

    // --- React.PureComponent
    // implements shouldComponentUpdate() which shallowly compares the objects
    // and skips prop updates for the whole component subtree,
    // make sure all the children components are also "pure".
    // only extend PureComponent when you expect to have simple props and state,
    // or use forceUpdate() when you know deep data structures have changed
    // or consider using immutable objects to facilitate fast comparisons of nested data

    // --- React.memo - HOC, similar to React.PureComponent
    // but for function components instead of classes
    // which renders the same result given the same props
    // only shallowly compare complex objects in the props object
    const MyComponent = React.memo(function MyComponent(props) {
      /* render using props */
    });
    // provide a custom comparison function as the second argument
    function MyComponent(props) {
      /* render using props */
    }
    function areEqual(prevProps, nextProps) {
      /*
      return true if passing nextProps to render would return
      the same result as passing prevProps to render,
      otherwise return false
      */
    }
    export default React.memo(MyComponent, areEqual);
  </code></pre>



<h2 id="lifecycle">Lifecycle</h2>

  <ul>
    <li><strong>lifecycle methods</strong> - mount or unmount of a component and its specific scenarios such as first rendering and timers, override to run code at particular times in the process
      <ul>
        <li><strong>mounting</strong> - instance of a component is being created and inserted into the DOM
          <ul>
            <li>constructor()</li>
            <li>static getDerivedStateFromProps()</li>
            <li>render()</li>
            <li>componentDidMount()</li>
          </ul>
        </li>
        <li><strong>updating</strong> - caused by changes to props or state, component is being re-rendered
          <ul>
            <li>static getDerivedStateFromProps()</li>
            <li>shouldComponentUpdate()</li>
            <li>render()</li>
            <li>getSnapshotBeforeUpdate()</li>
            <li>componentDidUpdate()</li>
          </ul>
        </li>
        <li><strong>unmounting</strong> - component is being removed from the DOM
          <ul>
            <li>componentWillUnmount()</li>
          </ul>
        </li>
        <li><strong>error handling</strong> - there is an error during rendering
          <ul>
            <li>static getDerivedStateFromError(error) - invoked after an error has been thrown by a descendant component, receives the error that was thrown as a parameter and should return a value to update state, handle fallback rendering, called during the "render" phase, so side-effects are not permitted (use componentDidCatch() instead)</li>
            <li>componentDidCatch(error, info) - invoked after an error has been thrown by a descendant component, called during the "commit" phase, so side-effects are permitted, should be used for things like logging errors</li>
          </ul>
        </li>
      </ul>
    </li>
    <li><strong>componentWillMount, componentWillReceiveProps, componentWillUpdate - are considered unsafe</strong>, used with UNSAFE_* prefix</li>
  </ul>

  <img src="../images/react-lifecycle.jpg"
  style="position:relative;width:80%;margin-left:10%;">

  <ul>
    <li><strong>constructor(props)</strong> - called before component is mounted, typicall only used for two purposes: initializing local state by assigning an object to this.state and binding event handler methods to an instance
      <ul>
        <li>if you dont initialize state and you dont bind methods, you dont need to implement a constructor for React component</li>
        <li><strong>dont call setState() in the constructor()</strong>, if component needs to use local state, <u>assign the initial state to this.state directly</u> in the constructor, and use setState() in all other methods</li>
        <li>when implementing the constructor <strong>for a React.Component subclass, you should call super(props)</strong> before any other statement, otherwise, this.props will be undefined in the constructor, which can lead to bugs</li>
        <li><strong>dont copy here props into state</strong></li>
      </ul>
    </li>
  </ul>

  <pre><code class="">
    constructor(props) {
      super(props);
      this.handleClick = this.handleClick.bind(this);
      // dont call this.setState() here ! assign the initial state
      this.state = { counter: 0 };
      // dont do this !!!
      this.state = { color: props.color };
    }
  </code></pre>

  <ul>
    <li><strong>static getDerivedStateFromProps(props, state)</strong> - invoked before calling the render method, both on the initial mount and on subsequent updates, should return an object to update the state, or null to update nothing
      <ul>
        <li>for rare use cases, where the state depends on changes in props over time</li>
        <li>leads to verbose code and makes components difficult to think about</li>
      </ul>
    </li>
    <li><strong>shouldComponentUpdate(nextProps, nextState)</strong> - let React know if a component output is not affected by the current change in state or props, invoked before rendering when new props or state are being received, default behavior is to re-render on every state change
      <ul>
        <li>compare this.props with nextProps and this.state with nextState and return false to tell React the update can be skipped</li>
        <li><strong>rely on the default behavior in majority of cases</strong></li>
        <li>consider using the built-in PureComponent instead of writing shouldComponentUpdate() by hand</li>
        <li>returning false does not prevent child components from re-rendering when their state changes</li>
        <li>if returns false, then render() and componentDidUpdate() will not be invoked, in the future React may treat shouldComponentUpdate() as a hint rather than a strict directive, and returning false may still result in a re-rendering of the component</li>
      </ul>
    </li>
    <li><strong>render()</strong> - should be pure (does not modify component state, returns the same result each time its invoked, and it does not directly interact with the browser), will not be invoked if shouldComponentUpdate() returns false, should examine this.props and this.state and return one of the following types:
      <ul>
        <li>React elements</li>
        <li>arrays and fragments</li>
        <li>portals</li>
        <li>string and numbers - rendered as text nodes in the DOM</li>
        <li>booleans or null - render nothing, mostly exists to support <u>return test && &lt;Child /&gt;</u> pattern, where test is boolean</li>
      </ul>
    </li>
    <li><strong>getSnapshotBeforeUpdate(prevProps, prevState)</strong> - invoked before the most recently rendered output is committed (to e.g. the DOM), snapshot value (or null) should be returned
      <ul>
        <li>any value returned by this lifecycle will be passed as a parameter to componentDidUpdate()</li>
        <li>enables component to capture some information from the DOM (e.g. scroll position) before it is potentially changed</li>
        <li>use case is not common, but it may occur in UIs like a chat thread that need to handle scroll position in a special way</li>
      </ul>
    </li>
  </ul>

  <pre><code class="">
    class ScrollingList extends React.Component {
      constructor(props) {
        super(props);
        this.listRef = React.createRef();
      }
      getSnapshotBeforeUpdate(prevProps, prevState) {
        // are we adding new items to the list?
        // capture the scroll position so we can adjust scroll later
        if (prevProps.list.length < this.props.list.length) {
          const list = this.listRef.current;
          return list.scrollHeight - list.scrollTop;
        }
        return null;
      }
      componentDidUpdate(prevProps, prevState, snapshot) {
        // if we have a snapshot value, we just added new items
        // adjust scroll so these new items dont push the old ones out of view
        // (snapshot here is the value returned from getSnapshotBeforeUpdate)
        if (snapshot !== null) {
          const list = this.listRef.current;
          list.scrollTop = list.scrollHeight - snapshot;
        }
      }
      render() {
        return (
          &lt;div ref={this.listRef}&gt;{ /* ...contents... */ }&lt;/div&gt;
        );
      }
    }
  </code></pre>

  <ul>
    <li><strong>componentDidMount()</strong> - invoked immediately after a component is mounted (inserted into the tree)
      <ul>
        <li>initialization that requires DOM nodes should go here</li>
        <li><strong>instantiate here the network request</strong> if you need to load data from a remote endpoint</li>
        <li><strong>set up any subscriptions and dont forget to unsubscribe in componentWillUnmount()</strong></li>
        <li>call setState() immediately in componentDidMount(), it will trigger an extra rendering, but it will happen before the browser updates the screen, use this pattern with caution because it often causes performance issues, in most cases, <u>can be necessary for cases like modals and tooltips</u> when you need to measure a DOM node before rendering something that depends on its size or position, you should be able to assign the initial state in the constructor() instead</li>
      </ul>
    </li>
    <li><strong>componentDidUpdate(prevProps, prevState, snapshot)</strong> - invoked immediately after updating occurs, not called for the initial render
      <ul>
        <li>operate on the DOM when the component has been updated</li>
        <li><strong>place to do network requests</strong> as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed)</li>
        <li><strong>call setState() immediately in componentDidUpdate()</strong>, must be wrapped in a condition to avoid infinite loop</li>
        <li>"snapshot" parameter is undefined or a snapshot if component implements the getSnapshotBeforeUpdate() lifecycle (which is rare)</li>
        <li>componentDidUpdate() will not be invoked if shouldComponentUpdate() returns false</li>
        <li>forgetting to handle componentDidUpdate properly is a common source of bugs in React applications</li>
      </ul>
    </li>
  </ul>

  <pre><code class="">
    componentDidUpdate(prevProps) {
      // typical usage (dont forget to compare props):
      if (this.props.userID !== prevProps.userID) {
        this.fetchData(this.props.userID);
      }
    }
  </code></pre>

  <ul>
    <li><strong>componentWillUnmount()</strong> - invoked immediately before a component is unmounted and destroyed
      <ul>
        <li>perform any necessary cleanup in this method: invalidating timers, canceling network requests, or cleaning up any subscriptions that were created in componentDidMount()</li>
        <li>dont call setState() here because the component will never be re-rendered, once a component instance is unmounted, it will never be mounted again</li>
      </ul>
    </li>
    <li><strong>componentDidCatch(error, info)</strong> - invoked after an error has been thrown by a descendant component</li>
  </ul>

  <pre><code class="">
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false };
      }
      static getDerivedStateFromError(error) {
        // update state so the next render will show the fallback UI
        return { hasError: true };
      }
      componentDidCatch(error, info) {
        // Example "componentStack":
        //   in ComponentThatThrows (created by App)
        //   in ErrorBoundary (created by App)
        //   in div (created by App)
        //   in App
        logComponentStackToMyService(info.componentStack);
      }
      render() {
        if (this.state.hasError) {
          // you can render any custom fallback UI
          return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;
        }
        return this.props.children;
      }
    }
  </code></pre>



<h2 id="events">Events , this</h2>

  <ul>
    <li>React events are named using camelCase, rather than lowercase - onClick</li>
    <li>with JSX you pass a function as the event handler, rather than a string</li>
    <li><strong>you cannot return false to prevent default behavior</strong>, call preventDefault explicitly</li>
    <li>dont call addEventListener to add listeners to a DOM element after it is created, just provide a listener when the element is initially rendered</li>
    <li>with ES6 class a common pattern is for an <strong>event handler to be a method on the class</strong></li>
    <li>pass the function itself, as a reference, dont add parenthesis (when without arguments) : ...<strong>onClick={this.handleClick}</strong>..., avoid following, created a new function each render
      <ul>
        <li>onClick={this.handleClick.bind(this)}</li>
        <li>onClick={() => this.handleClick()</li>
      </ul>
    </li>
    <li>pass an extra parameter to an event handler (in a loop etc.):
      <ul>
        <li><strong>onClick={(e) =&gt; this.deleteRow(id, e)}</strong></li>
        <li><strong>onClick={this.deleteRow.bind(this, id)}</strong> same as <strong>onClick={() => this.handleClick(id)}</strong></li>
        <li>in both cases, the "e" argument representing the React event will be passed as a second argument after the ID, with an arrow function, we have to pass it explicitly, but with "bind", any further arguments are automatically forwarded</li>
      </ul>
    </li>
    <li>event handlers will be passed instances of <strong>SyntheticEvent</strong>, a cross-browser wrapper around the browser native event, it has the same interface as the browser native event, including stopPropagation() and preventDefault()
      <ul>
        <li>use the nativeEvent attribute to get underlying browser event</li>
        <li>event cannot be accessed in an asynchronous way, just its attributes: event.type,...</li>
        <li>event handlers are triggered by an event in the bubbling phase, to register an event handler for the capture phase, append Capture to the event name; for example, instead of using onClick, you would use onClickCapture to handle the click event in the capture phase</li>
      </ul>
    </li>
    <li>prevent a function from being called too quickly or too many times in a row
      <ul>
        <li>throttling - sample changes based on a time based frequency (eg _.throttle)</li>
        <li>debouncing - publish changes after a period of inactivity (eg _.debounce)</li>
        <li>requestAnimationFrame throttling - sample changes based on requestAnimationFrame (eg raf-schd)</li>
        <li>see HTML-DOM-JS/Debounce</li>
      </ul>
    </li>
  </ul>

  <div class="example" id="e_root"></div>
  <script type="text/babel">
    class Toggle extends React.Component {
      constructor(props) {
        super(props);
        this.state = {isToggleOn: true};
        // necessary, to make "this" work in the callback
        this.handleClick = this.handleClick.bind(this);
      }
      handleClick() {
        this.setState(state => ({
          isToggleOn: !state.isToggleOn
        }));
      }

      render() {
        return (
          <button onClick={this.handleClick}>
            {this.state.isToggleOn ? 'ON' : 'OFF'}
          </button>
        );
      }
    }

    const e_root = ReactDOM.createRoot(document.getElementById('e_root'));
    e_root.render(<Toggle />);

    const A = 65; // ASCII character code
    class Alphabet extends React.Component {
      constructor(props) {
        super(props);
        this.handleClick = this.handleClick.bind(this);
        this.state = {
          justClicked: null,
          letters: Array.from(
            {length: 7},
            (_, i) => String.fromCharCode(A + i)
          )
        };
      }
      handleClick(letter) {
        this.setState({ justClicked: letter });
      }
      // or with data-.
      handleClick(e) {
        this.setState({
          justClicked: e.target.dataset.letter
        });
      }
      render() {
        return (
          <div>
            Click on letter in list, last clicked: {this.state.justClicked}
            <br />
            <ul>
              {this.state.letters.map(letter =>
                <li key={letter}
                  onClick={() => this.handleClick(letter)}
                  /* OR with data-. */
                  // data-letter={letter} onClick={this.handleClick}
                >
                  {letter}
                </li>
              )}
            </ul>
          </div>
        )
      }
    }

    const e_root2 = ReactDOM.createRoot(document.getElementById('e_root2'));
    e_root2.render(<Alphabet />);
  </script>
  <pre><code class="">
    function ActionLink() {
      function handleClick(e) {
        e.preventDefault();
        console.log('The link was clicked.');
      }
      return ( &lt;a href="#" onClick={handleClick}&gt;Click me&lt;/a&gt; );
    }
    class Toggle extends React.Component {
      constructor(props) {
        super(props);
        this.state = {isToggleOn: true};
        // necessary, to make "this" work in the callback
        this.handleClick = this.handleClick.bind(this);
      }
      handleClick() {
        this.setState(state =&gt; ({ isToggleOn: !state.isToggleOn }));
      }

      // experimental syntax
      // bound "this" within handleClick without help of construtor
      // enabled by default in Create React App
      handleClick = () =&gt; { console.log('this is:', this); }

      render() {
        return (
          &lt;button onClick={this.handleClick}&gt;
            {this.state.isToggleOn ? 'ON' : 'OFF'}
          &lt;/button&gt;
        );
      }
    }
    const e_root = ReactDOM.createRoot(document.getElementById('e_root'));
    e_root.render(&lt;Toggle /&gt;);
  </code></pre>

  <div class="example" id="e_root2"></div>

  <pre><code class="">
    // --- passing params
    const A = 65; // ASCII character code
    class Alphabet extends React.Component {
      constructor(props) {
        super(props);
        this.handleClick = this.handleClick.bind(this);
        this.state = {
          justClicked: null,
          letters: Array.from(
            {length: 26},
            (_, i) =&gt; String.fromCharCode(A + i)
          )
        };
      }
      handleClick(letter) { this.setState({ justClicked: letter }); }
      // or with data-.
      handleClick(e) {
        this.setState({ justClicked: e.target.dataset.letter });
      }
      render() {
        return (
          &lt;div&gt;
            Click on letter in list, last clicked: {this.state.justClicked}
            &lt;br /&gt;
            &lt;ul&gt;
              {this.state.letters.map(letter =&gt;
                &lt;li key={letter}
                  onClick={() =&gt; this.handleClick(letter)}
                  /* OR with data-. */
                  data-letter={letter} onClick={this.handleClick}
                &gt;
                  {letter}
                &lt;/li&gt;
              )}
            &lt;/ul&gt;
          &lt;/div&gt;
        )
      }
    }
  </code></pre>

  <details><summary>SyntheticEvent properties</summary>
  <pre><code class="javascript">
    bubbles
    cancelable
    currentTarget
    defaultPrevented
    eventPhase
    isTrusted
    DOMEvent nativeEvent
    preventDefault()
    isDefaultPrevented()
    stopPropagation()
    isPropagationStopped()
    target
    timeStamp
    type

    // --- CLIPBOARD
    onCopy onCut onPaste
    DOMDataTransfer clipboardData
    // --- COMPOSITION
    onCompositionEnd onCompositionStart onCompositionUpdate
    data
    // --- KEYBOARD
    onKeyDown onKeyPress onKeyUp
    // properties
    altKey ctrlKey shiftKey metaKey
    charCode
    getModifierState(key)
    key
    keyCode
    locale
    location
    repeat
    which
    // --- FOCUS
    onFocus onBlur
    relatedTarget
    // --- FORM
    onChange onInput onInvalid onSubmit
    // --- MOUSE
    onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit
    onDragLeave onDragOver onDragStart onDrop
    onMouseDown onMouseEnter onMouseLeave
    onMouseMove onMouseOut onMouseOver onMouseUp
    // properties
    altKey ctrlKey shiftKey metaKey
    button
    buttons
    clientX clientY
    getModifierState(key)
    pageX pageY
    relatedTarget
    screenX screenY
    // --- POINTER
    onPointerDown onPointerMove onPointerUp onPointerCancel
    onGotPointerCapture onLostPointerCapture onPointerEnter
    onPointerLeave onPointerOver onPointerOut
    // properties
    pointerId
    width height
    pressure
    tangentialPressure
    tiltX tiltY twist
    pointerType
    isPrimary
    // --- SELECTION
    onSelect
    // --- TOUCH
    onTouchCancel onTouchEnd onTouchMove onTouchStart
    // properties
    altKey ctrlKey shiftKey metaKey
    changedTouches
    getModifierState(key)
    targetTouches
    touches
    // --- UI
    onScroll
    // properties
    detail
    view
    // --- WHEEL
    onWheel
    // properties
    deltaMode
    deltaX deltaY deltaZ
    // --- MEDIA
    onAbort onCanPlay onCanPlayThrough onDurationChange
    onEmptied onEncrypted onEnded onError onLoadedData
    onLoadedMetadata onLoadStart onPause onPlay onPlaying
    onProgress onRateChange onSeeked onSeeking onStalled
    onSuspend onTimeUpdate onVolumeChange onWaiting
    // --- IMAGE
    onLoad onError
    // --- ANIMATION
    onAnimationStart onAnimationEnd onAnimationIteration
    // properties
    animationName
    pseudoElement
    elapsedTime
    // --- TRANSITION
    onTransitionEnd
    // properties
    propertyName
    pseudoElement
    elapsedTime
    // --- OTHER, DETAILS ELEMENT
    onToggle
  </code></pre></details>

  <details><summary>prevent frequent function calls</summary>
  <pre><code class="">
    // --- throttle
    import throttle from 'lodash.throttle';
    class LoadMoreButton extends React.Component {
      constructor(props) {
        super(props);
        this.handleClick = this.handleClick.bind(this);
        this.handleClickThrottled = throttle(this.handleClick, 1000);
      }
      componentWillUnmount() {
        this.handleClickThrottled.cancel();
      }
      render() {
        return &lt;button onClick={this.handleClickThrottled}&gt;Load More&lt;/button&gt;;
      }
      handleClick() {
        this.props.loadMore();
      }
    }

    // --- debounce
    import debounce from 'lodash.debounce';
    class Searchbox extends React.Component {
      constructor(props) {
        super(props);
        this.handleChange = this.handleChange.bind(this);
        this.emitChangeDebounced = debounce(this.emitChange, 250);
      }
      componentWillUnmount() {
        this.emitChangeDebounced.cancel();
      }
      render() {
        return (
          &lt;input
            type="text"
            onChange={this.handleChange}
            placeholder="Search..."
            defaultValue={this.props.value}
          /&gt;
        );
      }
      handleChange(e) {
        // React pools events, so we read the value before debounce.
        // Alternately we could call `event.persist()` and pass the entire event.
        // For more info see reactjs.org/docs/events.html#event-pooling
        this.emitChangeDebounced(e.target.value);
      }
      emitChange(value) {
        this.props.onChange(value);
      }
    }

    // --- requestAnimationFrame
    import rafSchedule from 'raf-schd';
    class ScrollListener extends React.Component {
      constructor(props) {
        super(props);
        this.handleScroll = this.handleScroll.bind(this);
        // Create a new function to schedule updates.
        this.scheduleUpdate = rafSchedule(
          point =&gt; this.props.onScroll(point)
        );
      }
      handleScroll(e) {
        // When we receive a scroll event, schedule an update.
        // If we receive many updates within a frame, we'll only publish the latest value.
        this.scheduleUpdate({ x: e.clientX, y: e.clientY });
      }
      componentWillUnmount() {
        // Cancel any pending updates since we're unmounting.
        this.scheduleUpdate.cancel();
      }
      render() {
        return (
          &lt;div
            style={{ overflow: 'scroll' }}
            onScroll={this.handleScroll}
          &gt;
            &lt;img src="/my-huge-image.jpg" /&gt;
          &lt;/div&gt;
        );
      }
    }
  </code></pre></details>



<h2 id="cond">Conditional Rendering</h2>

  <ul>
    <li>create distinct components that encapsulate behavior you need, then render only some of them, depending on the state of application</li>
    <li>works the same way conditions work in JS, use operators like "if" or the conditional (ternary) operator to create elements representing the current state, and let React update the UI to match them</li>
    <li><strong>use variables to store elements</strong>, helps you conditionally render a part of the component while the rest of the output doesnt change</li>
    <li>embed any expressions in JSX by wrapping them in curly braces, this includes the JS logical "&&" operator, can be handy for conditionally including an element, "true && expression" always evaluates to expression, and "false && expression" always evaluates to false</li>
    <li>whenever conditions become too complex, it might be a good time to extract a component</li>
    <li><strong>return "null" instead of its render output</strong> to hide component even though it was rendered by another component, doing so does not affect the firing of the components lifecycle methods, for instance componentDidUpdate will still be called</li>
  </ul>

  <div class="example" id="cond_1"></div>
  <script type="text/babel">
    function UserGreeting(props) {
      return <h1>Welcome back!</h1>;
    }
    function GuestGreeting(props) {
      return <h1>Please sign up.</h1>;
    }
    function Greeting(props) {
      const isLoggedIn = props.isLoggedIn;
      if (isLoggedIn) {
        return <UserGreeting />;
      }
      return <GuestGreeting />;
    }
    function LoginButton(props) {
      return (
        <button onClick={props.onClick}>
          Login
        </button>
      );
    }
    function LogoutButton(props) {
      return (
        <button onClick={props.onClick}>
          Logout
        </button>
      );
    }
    class LoginControl extends React.Component {
      constructor(props) {
        super(props);
        this.handleLoginClick = this.handleLoginClick.bind(this);
        this.handleLogoutClick = this.handleLogoutClick.bind(this);
        this.state = {isLoggedIn: false};
      }
      handleLoginClick() {
        this.setState({isLoggedIn: true});
      }
      handleLogoutClick() {
        this.setState({isLoggedIn: false});
      }
      render() {
        const isLoggedIn = this.state.isLoggedIn;
        let button;
        if (isLoggedIn) {
          button = <LogoutButton onClick={this.handleLogoutClick} />;
        } else {
          button = <LoginButton onClick={this.handleLoginClick} />;
        }
        return (
          <div>
            <Greeting isLoggedIn={isLoggedIn} />
            {button}
          </div>
        );
      }
    }
    const cond_1 = ReactDOM.createRoot(document.getElementById('cond_1'));
    cond_1.render(<LoginControl />);
  </script>
  <pre><code class="">
    function UserGreeting(props) { return &lt;h1&gt;Welcome back!&lt;/h1&gt;; }
    function GuestGreeting(props) { return &lt;h1&gt;Please sign up.&lt;/h1&gt;; }
    function Greeting(props) {
      const isLoggedIn = props.isLoggedIn;
      if (isLoggedIn) { return &lt;UserGreeting /&gt;; }
      return &lt;GuestGreeting /&gt;;
    }
    function LoginButton(props) {
      return (
        &lt;button onClick={props.onClick}&gt;
          Login
        &lt;/button&gt;
      );
    }
    function LogoutButton(props) {
      return (
        &lt;button onClick={props.onClick}&gt;
          Logout
        &lt;/button&gt;
      );
    }
    class LoginControl extends React.Component {
      constructor(props) {
        super(props);
        this.handleLoginClick = this.handleLoginClick.bind(this);
        this.handleLogoutClick = this.handleLogoutClick.bind(this);
        this.state = {isLoggedIn: false};
      }
      handleLoginClick() { this.setState({isLoggedIn: true}); }
      handleLogoutClick() { this.setState({isLoggedIn: false}); }
      render() {
        const isLoggedIn = this.state.isLoggedIn;
        let button;
        if (isLoggedIn) {
          button = &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;;
        } else {
          button = &lt;LoginButton onClick={this.handleLoginClick} /&gt;;
        }
        return (
          &lt;div&gt;
            &lt;Greeting isLoggedIn={isLoggedIn} /&gt;
            {button}
          &lt;/div&gt;
        );
      }
    }
    const cond_1 = ReactDOM.createRoot(document.getElementById('cond_1'));
    cond_1.render(&lt;LoginControl /&gt;);
  </code></pre>

  <details><summary>inline "IF" with logical "&&" and ternary operators</summary>
  <div class="example" id="cond_2"></div>
  <script type="text/babel">
    function Mailbox(props) {
      const unreadMessages = props.unreadMessages;
      return (
        <div>
          {unreadMessages.length > 0 &&
            <h2>
              You have {unreadMessages.length} unread messages.
            </h2>
          }
        </div>
      );
    }

    const messages = ['React', 'Re: React', 'Re:Re: React'];
    const cond_2 = ReactDOM.createRoot(document.getElementById('cond_2'));
    cond_2.render(<Mailbox unreadMessages={messages} />);
  </script>
  <pre><code class="">
    function Mailbox(props) {
      const unreadMessages = props.unreadMessages;
      return (
        &lt;div&gt;
          {unreadMessages.length &gt; 0 &&
            &lt;h2&gt;
              You have {unreadMessages.length} unread messages.
            &lt;/h2&gt;
          }
        &lt;/div&gt;
      );
    }
    const messages = ['React', 'Re: React', 'Re:Re: React'];
    const cond_2 = ReactDOM.createRoot(document.getElementById('cond_2'));
    cond_2.render(&lt;Mailbox unreadMessages={messages} /&gt;);

    // ...
    render() {
      const isLoggedIn = this.state.isLoggedIn;
      return (
        &lt;div&gt;
          The user is &lt;b&gt;{isLoggedIn ? 'currently' : 'not'}&lt;/b&gt; logged in.
        &lt;/div&gt;
      );
    }
    // ...
    render() {
      const isLoggedIn = this.state.isLoggedIn;
      return (
        &lt;div&gt;
          {isLoggedIn ? (
            &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;
          ) : (
            &lt;LoginButton onClick={this.handleLoginClick} /&gt;
          )}
        &lt;/div&gt;
      );
    }
    // ...
  </code></pre></details>

  <details><summary>preventing component from rendering (return "null")</summary>
  <div class="example" id="cond_3"></div>
  <script type="text/babel">
    function WarningBanner(props) {
      if (!props.warn) {
        return null;
      }
      return (
        <div className="warning">
          Warning!
        </div>
      );
    }
    class Page extends React.Component {
      constructor(props) {
        super(props);
        this.state = {showWarning: true};
        this.handleToggleClick = this.handleToggleClick.bind(this);
      }
      handleToggleClick() {
        this.setState(state => ({
          showWarning: !state.showWarning
        }));
      }
      render() {
        return (
          <div>
            <button onClick={this.handleToggleClick}>
              {this.state.showWarning ? 'Hide' : 'Show'}
            </button>
            <WarningBanner warn={this.state.showWarning} />
          </div>
        );
      }
    }
    const cond_3 = ReactDOM.createRoot(document.getElementById('cond_3'));
    cond_3.render(<Page />);
  </script>
  <pre><code class="">
    function WarningBanner(props) {
      if (!props.warn) { return null; }
      return (
        &lt;div className="warning"&gt;
          Warning!
        &lt;/div&gt;
      );
    }
    class Page extends React.Component {
      constructor(props) {
        super(props);
        this.state = {showWarning: true};
        this.handleToggleClick = this.handleToggleClick.bind(this);
      }
      handleToggleClick() {
        this.setState(state =&gt; ({
          showWarning: !state.showWarning
        }));
      }
      render() {
        return (
          &lt;div&gt;
            &lt;button onClick={this.handleToggleClick}&gt;
              {this.state.showWarning ? 'Hide' : 'Show'}
            &lt;/button&gt;
            &lt;WarningBanner warn={this.state.showWarning} /&gt;
          &lt;/div&gt;
        );
      }
    }
    const cond_3 = ReactDOM.createRoot(document.getElementById('cond_3'));
    cond_3.render(&lt;Page /&gt;);
  </code></pre></details>



<h2 id="lk">Lists/Keys</h2>

  <ul>
    <li>in React, transforming arrays into lists of elements is nearly identical to using map function</li>
    <li>key is a special string attribute you need to include when creating lists of elements, help identify which items have changed/added/removed, should be given to the elements inside the array to give the elements a stable identity, use id or other unique string</li>
    <li>if you choose not to assign an explicit key to list items then React will default to using indexes as keys, dont use indexes for keys if the order of items may change</li>
    <li><strong>specify key in list components not in items</strong> when iterating, and dont send it to item, <strong>elements inside the map() call need keys</strong></li>
    <li>keys must only be unique among siblings, however they dont need to be globally unique, we can use the same keys when we produce two different arrays</li>
    <li>if you need the same as key value in component, pass it explicitly as a prop with a different name</li>
  </ul>

  <div class="example" id="lk_root"></div>
  <script type="text/babel">
    function NumberList(props) {
      const numbers = props.numbers;
      const listItems = numbers.map((number) =>
        <li key={number.toString()}>
          {number}
        </li>
      );
      return (
        <ul>{listItems}</ul>
      );
    }
    const numbers = [1, 2, 3, 4, 5];
    const lk_root = ReactDOM.createRoot(document.getElementById('lk_root'));
    lk_root.render(<NumberList numbers={numbers} />);
  </script>
  <pre><code class="">
    const numbers = [1, 2, 3, 4, 5];
    const listItems = numbers.map((number) =&gt;
      &lt;li&gt;{number}&lt;/li&gt;
    );
    const lk_root = ReactDOM.createRoot(document.getElementById('lk_root'));
    lk_root.render(&lt;ul&gt;{listItems}&lt;/ul&gt;);
    // --- OR
    function NumberList(props) {
      const numbers = props.numbers;
      const listItems = numbers.map((number) =&gt;
        &lt;li key={number.toString()}&gt;
          {number}
        &lt;/li&gt;
      );
      return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
      );
      // --- OR
      return (
        &lt;ul&gt;
          {numbers.map((number) =&gt;
            &lt;ListItem key={number.toString()}
                      value={number} /&gt;
          )}
        &lt;/ul&gt;
      );
    }
    const lk_root = ReactDOM.createRoot(document.getElementById('lk_root'));
    lk_root.render(&lt;NumberList numbers={numbers} /&gt;);

    // ...
    const todoItems = todos.map((todo) =&gt;
      &lt;li key={todo.id}&gt;
        {todo.text}
      &lt;/li&gt;
    );
    // ...
    // only do this if items have no stable IDs !!!
    const todoItems = todos.map((todo, index) =&gt;
      &lt;li key={index}&gt;
        {todo.text}
      &lt;/li&gt;
    );
    // ...

    // --- keys must only be unique among siblings
    function Blog(props) {
      const sidebar = (
        &lt;ul&gt;
          {props.posts.map((post) =&gt;
            &lt;li key={post.id}&gt;
              {post.title}
            &lt;/li&gt;
          )}
        &lt;/ul&gt;
      );
      const content = props.posts.map((post) =&gt;
        &lt;div key={post.id}&gt;
          &lt;h3&gt;{post.title}&lt;/h3&gt;
          &lt;p&gt;{post.content}&lt;/p&gt;
        &lt;/div&gt;
      );
      return (
        &lt;div&gt;
          {sidebar}
          &lt;hr /&gt;
          {content}
        &lt;/div&gt;
      );
    }
    const posts = [
      {id: 1, title: 'Hello World', content: 'Welcome to learning React!'},
      {id: 2, title: 'Installation', content: 'You can install React from npm.'}
    ];
    const lk_root = ReactDOM.createRoot(document.getElementById('lk_root'));
    lk_root.render(&lt;Blog posts={posts} /&gt;);

    // ...
    // can read props.id, but not props.key
    const content = posts.map((post) =&gt;
      &lt;Post
        key={post.id}
        id={post.id}
        title={post.title} /&gt;
    );
    // ...
  </code></pre>

  <details><summary>Example</summary>
  <div class="example" id="list_example_root"></div>
  <script type="text/babel">
    const ToDo = props => (
      <tr>
        <td>
          <label>{props.id}</label>
        </td>
        <td>
          <input />
        </td>
        <td>
          <label>{props.createdAt.toTimeString()}</label>
        </td>
      </tr>
    );
    class ToDoList extends React.Component {
      constructor() {
        super();
        const date = new Date();
        const toDoCounter = 1;
        this.state = {
          list: [
            {
              id: toDoCounter,
              createdAt: date,
            },
          ],
          toDoCounter: toDoCounter,
        };
      }
      sortByEarliest() {
        const sortedList = this.state.list.sort((a, b) => {
          return a.createdAt - b.createdAt;
        });
        this.setState({
          list: [...sortedList],
        });
      }
      sortByLatest() {
        const sortedList = this.state.list.sort((a, b) => {
          return b.createdAt - a.createdAt;
        });
        this.setState({
          list: [...sortedList],
        });
      }
      addToEnd() {
        const date = new Date();
        const nextId = this.state.toDoCounter + 1;
        const newList = [
          ...this.state.list,
          {id: nextId, createdAt: date},
        ];
        this.setState({
          list: newList,
          toDoCounter: nextId,
        });
      }
      addToStart() {
        const date = new Date();
        const nextId = this.state.toDoCounter + 1;
        const newList = [
          {id: nextId, createdAt: date},
          ...this.state.list,
        ];
        this.setState({
          list: newList,
          toDoCounter: nextId,
        });
      }
      render() {
        return (
          <div>
            <code>key=id</code>
            <br />
            <button onClick={this.addToStart.bind(this)}>
              Add New to Start
            </button>
            <button onClick={this.addToEnd.bind(this)}>
              Add New to End
            </button>
            <button onClick={this.sortByEarliest.bind(this)}>
              Sort by Earliest
            </button>
            <button onClick={this.sortByLatest.bind(this)}>
              Sort by Latest
            </button>
            <table>
            <tbody>
              <tr>
                <th>ID</th>
                <th />
                <th>created at</th>
              </tr>
              {this.state.list.map((todo, index) => (
                <ToDo key={todo.id} {...todo} />
              ))}
            </tbody>
            </table>
          </div>
        );
      }
    }
    const list_example_root = ReactDOM.createRoot(document.getElementById('list_example_root'));
    list_example_root.render(<ToDoList />);
  </script>
  <pre><code class="">
    const ToDo = props => (
      &lt;tr&gt;
        &lt;td&gt;
          &lt;label&gt;{props.id}&lt;/label&gt;
        &lt;/td&gt;
        &lt;td&gt;
          &lt;input /&gt;
        &lt;/td&gt;
        &lt;td&gt;
          &lt;label&gt;{props.createdAt.toTimeString()}&lt;/label&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
    );
    class ToDoList extends React.Component {
      constructor() {
        super();
        const date = new Date();
        const toDoCounter = 1;
        this.state = {
          list: [
            {
              id: toDoCounter,
              createdAt: date,
            },
          ],
          toDoCounter: toDoCounter,
        };
      }
      sortByEarliest() {
        const sortedList = this.state.list.sort((a, b) =&gt; {
          return a.createdAt - b.createdAt;
        });
        this.setState({
          list: [...sortedList],
        });
      }
      sortByLatest() {
        const sortedList = this.state.list.sort((a, b) =&gt; {
          return b.createdAt - a.createdAt;
        });
        this.setState({
          list: [...sortedList],
        });
      }
      addToEnd() {
        const date = new Date();
        const nextId = this.state.toDoCounter + 1;
        const newList = [
          ...this.state.list,
          {id: nextId, createdAt: date},
        ];
        this.setState({
          list: newList,
          toDoCounter: nextId,
        });
      }
      addToStart() {
        const date = new Date();
        const nextId = this.state.toDoCounter + 1;
        const newList = [
          {id: nextId, createdAt: date},
          ...this.state.list,
        ];
        this.setState({
          list: newList,
          toDoCounter: nextId,
        });
      }
      render() {
        return (
          &lt;div&gt;
            &lt;code&gt;key=id&lt;/code&gt;
            &lt;br /&gt;
            &lt;button onClick={this.addToStart.bind(this)}&gt;
              Add New to Start
            &lt;/button&gt;
            &lt;button onClick={this.addToEnd.bind(this)}&gt;
              Add New to End
            &lt;/button&gt;
            &lt;button onClick={this.sortByEarliest.bind(this)}&gt;
              Sort by Earliest
            &lt;/button&gt;
            &lt;button onClick={this.sortByLatest.bind(this)}&gt;
              Sort by Latest
            &lt;/button&gt;
            &lt;table&gt;
              &lt;tr&gt;
                &lt;th&gt;ID&lt;/th&gt;
                &lt;th /&gt;
                &lt;th&gt;created at&lt;/th&gt;
              &lt;/tr&gt;
              {this.state.list.map((todo, index) =&gt; (
                &lt;ToDo key={todo.id} {...todo} /&gt;
              ))}
            &lt;/table&gt;
          &lt;/div&gt;
        );
      }
    }
    const list_example_root = ReactDOM.createRoot(document.getElementById('list_example_root'));
    list_example_root.render(&lt;ToDoList /&gt;);
  </code></pre></details>

  <details><summary>Pagination</summary>
  <div class="example" id="list_pagination_root"></div>
  <script type="text/babel">
    class TodoApp extends React.Component {
      constructor() {
        super();
        this.state = {
          todos: ['a','b','c','d','e','f','g','h','i','j','k'],
          currentPage: 1,
          todosPerPage: 3
        };
        this.handleClick = this.handleClick.bind(this);
      }
      handleClick(event) {
        this.setState({
          currentPage: Number(event.target.id)
        });
      }
      render() {
        const { todos, currentPage, todosPerPage } = this.state;
        // Logic for displaying todos
        const indexOfLastTodo = currentPage * todosPerPage;
        const indexOfFirstTodo = indexOfLastTodo - todosPerPage;
        const currentTodos = todos.slice(indexOfFirstTodo, indexOfLastTodo);
        const renderTodos = currentTodos.map((todo, index) => {
          return <li key={index}>{todo}</li>;
        });
        // Logic for displaying page numbers
        const pageNumbers = [];
        for (let i = 1; i <= Math.ceil(todos.length / todosPerPage); i++) {
          pageNumbers.push(i);
        }
        const renderPageNumbers = pageNumbers.map(number => {
          return (
            <span
              key={number}
              id={number}
              onClick={this.handleClick}
            >
              ({number})
            </span>
          );
        });
        return (
          <div>
            <div>Click on numbers</div>
            <div>{renderPageNumbers}</div>
            <ul>
              {renderTodos}
            </ul>
          </div>
        );
      }
    }
    const list_pagination_root = ReactDOM.createRoot(document.getElementById('list_pagination_root'));
    list_pagination_root.render(<TodoApp />);
  </script>
  <pre><code class="">
    class TodoApp extends React.Component {
      constructor() {
        super();
        this.state = {
          todos: ['a','b','c','d','e','f','g','h','i','j','k'],
          currentPage: 1,
          todosPerPage: 3
        };
        this.handleClick = this.handleClick.bind(this);
      }
      handleClick(event) {
        this.setState({
          currentPage: Number(event.target.id)
        });
      }
      render() {
        const { todos, currentPage, todosPerPage } = this.state;
        // Logic for displaying todos
        const indexOfLastTodo = currentPage * todosPerPage;
        const indexOfFirstTodo = indexOfLastTodo - todosPerPage;
        const currentTodos = todos.slice(indexOfFirstTodo, indexOfLastTodo);
        const renderTodos = currentTodos.map((todo, index) =&gt; {
          return &lt;li key={index}&gt;{todo}&lt;/li&gt;;
        });
        // Logic for displaying page numbers
        const pageNumbers = [];
        for (let i = 1; i &lt;= Math.ceil(todos.length / todosPerPage); i++) {
          pageNumbers.push(i);
        }
        const renderPageNumbers = pageNumbers.map(number =&gt; {
          return (
            &lt;span
              key={number}
              id={number}
              onClick={this.handleClick}
            &gt;
              ({number})
            &lt;/span&gt;
          );
        });
        return (
          &lt;div&gt;
            &lt;div&gt;Click on numbers&lt;/div&gt;
            &lt;div&gt;{renderPageNumbers}&lt;/div&gt;
            &lt;ul&gt;
              {renderTodos}
            &lt;/ul&gt;
          &lt;/div&gt;
        );
      }
    }
    const list_pagination_root = ReactDOM.createRoot(document.getElementById('list_pagination_root'));
    list_pagination_root.render(&lt;TodoApp /&gt;);
  </code></pre></details>



<h2 id="forms">Forms</h2>

  <ul>
    <li><strong>controlled component</strong> - input form element whose value is controlled by React</li>
    <li>&lt;input type="text"&gt;, &lt;textarea&gt;, and &lt;select&gt; all work very similarly - they all accept a value attribute</li>
    <li>use <a href="https://jaredpalmer.com/formik">Formik</a> for a complete solution including validation, keeping track of the visited fields, and handling form submission</li>
    <li><strong>uncontrolled components</strong> - where form data is handled by the DOM itself, instead of writing an event handler for every state update, you can use a "ref" to get form values from the DOM</li>
    <li>specify a "defaultValue" attribute instead of "value" with an uncontrolled component, to specify the initial value, but leave subsequent updates uncontrolled
      <ul>
        <li>"checkbox" and "radio" supports "defaultChecked"</li>
        <li>"select" and "textarea" supports "defaultValue</li>
      </ul>
    </li>
    <li>&lt;input type="file" /&gt; is always an uncontrolled component because its value can only be set by a user, and not programmatically, use the File API to interact with the files</li>
    <li>attributes
      <ul>
        <li>checked - supported by input components of type checkbox or radio, use it to set whether the component is checked, useful for building controlled components, defaultChecked is the uncontrolled equivalent, which sets whether the component is checked when it is first mounted</li>
        <li>selected - supported by option components, use it to set whether the component is selected, useful for building controlled components</li>
        <li>value - supported by input and textarea components, use it to set the value of the component, useful for building controlled components, defaultValue is the uncontrolled equivalent, which sets the value of the component when it is first mounted</li>
        <li>dangerouslySetInnerHTML - React replacement for using innerHTML</li>
        <li>suppressContentEditableWarning - remove warning when an element with children is also marked as contentEditable</li>
      </ul>
    </li>
  </ul>

  <div class="example">
    <div id="forms_root"></div>
  </div>
  <script type="text/babel">
    class NameForm extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          working: false,
          gender: 'male',
          input_text: 'Andrei',
          input_textarea: 'Some text here ...',
          select_age: 35,
          select_hobby: ['sport','tech'] // create selection scenario...
        };
        this.handleChange = this.handleChange.bind(this);
        this.handleSubmit = this.handleSubmit.bind(this);
      }

      handleChange(event) {
        // this.setState({value: event.target.value.toUpperCase()});
        // or, for multiple inputs:
        const target = event.target;
        const value = (target.type === 'checkbox') ? target.checked : target.value;
        const name = target.name;
        this.setState({
          [name]: value
        });
        // equivalent to this ES5 code:
        // var partialState = {};
        // partialState[name] = value;
        // this.setState(partialState);
      }

      handleSubmit(event) {
        event.preventDefault();
        const output =
          "working: " + this.state.working.toString() + "\n" +
          "gender: " + this.state.gender.toString() + "\n" +
          "input_text: " + this.state.input_text.toString() + "\n" +
          "input_textarea: " + this.state.input_textarea.toString() + "\n" +
          "select_hobby: " + this.state.select_hobby.toString() + "\n" +
          "select_age: " + this.state.select_age.toString();
        alert('Values:\n' + output);
      }

      render() {
        return (
          <form onSubmit={this.handleSubmit}>

            Working
            <input
              name="working"
              type="checkbox"
              checked={this.state.working}
              onChange={this.handleChange}
            /><br/>

            Gender:
            <input
              type="radio"
              name="gender"
              value="male"
              checked={this.state.gender === "male"}
              onChange={this.handleChange}
              id="forms_root_male"
            />
            <label htmlFor="forms_root_male">Male</label>
            <input
              type="radio"
              name="gender"
              value="female"
              checked={this.state.gender === "female"}
              onChange={this.handleChange}
              id="forms_root_female"
            />
            <label htmlFor="forms_root_female">Female</label>
            <br/>

            Name:
            <input
              type="text"
              name="input_text"
              value={this.state.input_text}
              onChange={this.handleChange}
            /><br/>

            Info:
            <br/>
            <textarea
              name="input_textarea"
              value={this.state.input_textarea}
              onChange={this.handleChange}
            /><br/>

            Hobby:
            <br/>
            <select
              multiple={true}
              name="select_hobby"
              value={this.state.select_hobby}
              onChange={this.handleChange}
            >
              <option value="sport">Sport</option>
              <option value="tech">Tech</option>
              <option value="books">Books</option>
              <option value="travel">Travel</option>
            </select><br/>

            Age Range:
            <br/>
            <select
              name="select_age"
              value={this.state.select_age}
              onChange={this.handleChange}
            >
              <option value="18">up to 18</option>
              <option value="25">19-25</option>
              <option value="35">26-35</option>
              <option value="100">36-...</option>
            </select><br/>

          <input type="submit" value="Submit" />

        </form>
        );
      }
    }
    const forms_root = ReactDOM.createRoot(document.getElementById('forms_root'));
    forms_root.render(<NameForm />);
  </script>
  <pre><code class="">
    class NameForm extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          working: false,
          gender: 'male',
          input_text: 'Andrei',
          input_textarea: 'Some text here ...',
          select_age: 35,
          select_hobby: ['sport','tech'] // create selection scenario...
        };
        this.handleChange = this.handleChange.bind(this);
        this.handleSubmit = this.handleSubmit.bind(this);
      }

      handleChange(event) {
        // this.setState({value: event.target.value.toUpperCase()});
        // or, for multiple inputs:
        const target = event.target;
        const value = (target.type === 'checkbox') ? target.checked : target.value;
        const name = target.name;
        this.setState({
          [name]: value
        });
        // equivalent to this ES5 code:
        // var partialState = {};
        // partialState[name] = value;
        // this.setState(partialState);
      }

      handleSubmit(event) {
        event.preventDefault();
        const output =
          "working: " + this.state.working.toString() + "\n" +
          "gender: " + this.state.gender.toString() + "\n" +
          "input_text: " + this.state.input_text.toString() + "\n" +
          "input_textarea: " + this.state.input_textarea.toString() + "\n" +
          "select_hobby: " + this.state.select_hobby.toString() + "\n" +
          "select_age: " + this.state.select_age.toString();
        alert('Values:\n' + output);
      }

      render() {
        return (
          &lt;form onSubmit={this.handleSubmit}&gt;

            Working:
            &lt;input
              name="working"
              type="checkbox"
              checked={this.state.working}
              onChange={this.handleChange}
            /&gt;

            Gender:
            &lt;input
              type="radio"
              name="gender"
              value="male"
              checked={this.state.gender === "male"}
              onChange={this.handleChange}
              id="forms_root_male"
            /&gt;
            &lt;label htmlFor="forms_root_male"&gt;Male&lt;/label&gt;
            &lt;input
              type="radio"
              name="gender"
              value="female"
              checked={this.state.gender === "female"}
              onChange={this.handleChange}
              id="forms_root_female"
            /&gt;
            &lt;label htmlFor="forms_root_female"&gt;Female&lt;/label&gt;

            Name:
            &lt;input
              type="text"
              name="input_text"
              value={this.state.input_text}
              onChange={this.handleChange}
            /&gt;

            Info:
            &lt;textarea
              name="input_textarea"
              value={this.state.input_textarea}
              onChange={this.handleChange}
            /&gt;

            Hobby:
            &lt;select
              multiple={true}
              name="select_hobby"
              value={this.state.select_hobby}
              onChange={this.handleChange}
            &gt;
              &lt;option value="sport"&gt;Sport&lt;/option&gt;
              &lt;option value="tech"&gt;Tech&lt;/option&gt;
              &lt;option value="books"&gt;Books&lt;/option&gt;
              &lt;option value="travel"&gt;Travel&lt;/option&gt;
            &lt;/select&gt;

            Age Range:
            &lt;select
              name="select_age"
              value={this.state.select_age}
              onChange={this.handleChange}
            &gt;
              &lt;option value="18"&gt;up to 18&lt;/option&gt;
              &lt;option value="25"&gt;19-25&lt;/option&gt;
              &lt;option value="35"&gt;26-35&lt;/option&gt;
              &lt;option value="100"&gt;36-...&lt;/option&gt;
            &lt;/select&gt;

          &lt;input type="submit" value="Submit" /&gt;

        &lt;/form&gt;
        );
      }
    }
    const forms_root = ReactDOM.createRoot(document.getElementById('forms_root'));
    forms_root.render(&lt;NameForm /&gt;);

    // --- dangerouslySetInnerHTML
    function createMarkup() {
      return {__html: 'First &middot; Second'};
    }
    function MyComponent() {
      return &lt;div dangerouslySetInnerHTML={createMarkup()} /&gt;;
    }
  </code></pre>

  <h3>uncontrolled component form</h3>
  <div class="example">
    <div id="uc_root"></div>
  </div>
  <script type="text/babel">
    class UncontrolledComponentForm extends React.Component {
      constructor(props) {
        super(props);
        this.handleSubmit = this.handleSubmit.bind(this);
        this.inputName = React.createRef();
        this.inputHobby = React.createRef();
        this.inputFile = React.createRef();
      }
      handleSubmit(event) {
        event.preventDefault();
        const inputFile = (
          this.inputFile.current.files[0] ?
          this.inputFile.current.files[0].name : "[ No File ]"
        );
        alert(
          'submitted: '
          + this.inputName.current.value + ', '
          + this.inputHobby.current.value + ', '
          + inputFile
        );
      }
      render() {
        return (
          <form onSubmit={this.handleSubmit}>
            <label>
              Name:
              <input type="text" ref={this.inputName} />
            </label><br/>
            <label>
              Hobby:
              <input
                defaultValue="Sport"
                type="text"
                ref={this.inputHobby} />
            </label><br/>
            <label>
              Avatar:
              <input type="file" ref={this.inputFile} />
            </label><br/>
            <input type="submit" value="Submit" />
          </form>
        );
      }
    }
    const uc_root = ReactDOM.createRoot(document.getElementById('uc_root'));
    uc_root.render(<UncontrolledComponentForm />);
  </script>
  <pre><code class="">
    class UncontrolledComponentForm extends React.Component {
      constructor(props) {
        super(props);
        this.handleSubmit = this.handleSubmit.bind(this);
        this.inputName = React.createRef();
        this.inputHobby = React.createRef();
        this.inputFile = React.createRef();
      }
      handleSubmit(event) {
        event.preventDefault();
        const inputFile = (
          this.inputFile.current.files[0] ?
          this.inputFile.current.files[0].name : "[ No File ]"
        );
        alert(
          'submitted: '
          + this.inputName.current.value + ', '
          + this.inputHobby.current.value + ', '
          + inputFile
        );
      }
      render() {
        return (
          &lt;form onSubmit={this.handleSubmit}&gt;
            &lt;label&gt;
              Name:
              &lt;input type="text" ref={this.inputName} /&gt;
            &lt;/label&gt;&lt;br/&gt;
            &lt;label&gt;
              Hobby:
              &lt;input
                defaultValue="Sport"
                type="text"
                ref={this.inputHobby} /&gt;
            &lt;/label&gt;&lt;br/&gt;
            &lt;label&gt;
              Avatar:
              &lt;input type="file" ref={this.inputFile} /&gt;
            &lt;/label&gt;&lt;br/&gt;
            &lt;input type="submit" value="Submit" /&gt;
          &lt;/form&gt;
        );
      }
    }
    const uc_root = ReactDOM.createRoot(document.getElementById('uc_root'));
    uc_root.render(&lt;UncontrolledComponentForm /&gt;);
  </code></pre>



<h2 id="ls">Lifting State</h2>

  <ul>
    <li>reflect the same changing data in several components, lift the shared state up to their closest common ancestor</li>
  </ul>

  <div class="example" id="ls_root"></div>
  <script type="text/babel">
    const scaleNames = {
      c: 'Celsius',
      f: 'Fahrenheit'
    };
    function toCelsius(fahrenheit) {
      return (fahrenheit - 32) * 5 / 9;
    }
    function toFahrenheit(celsius) {
      return (celsius * 9 / 5) + 32;
    }
    function tryConvert(temperature, convert) {
      const input = parseFloat(temperature);
      if (Number.isNaN(input)) {
        return '';
      }
      const output = convert(input);
      const rounded = Math.round(output * 1000) / 1000;
      return rounded.toString();
    }
    function BoilingVerdict(props) {
      if (props.celsius >= 100) {
        return <p>The water would boil</p>;
      }
      return <p>The water would not boil</p>;
    }
    class TemperatureInput extends React.Component {
      constructor(props) {
        super(props);
        this.handleChange = this.handleChange.bind(this);
      }
      handleChange(e) {
        // send local value to Calculator handler
        this.props.onTemperatureChange(e.target.value);
      }
      render() {
        const temperature = this.props.temperature;
        const scale = this.props.scale;
        return (
          <fieldset>
            <legend>Enter temperature in {scaleNames[scale]}:</legend>
            <input value={temperature}
                  onChange={this.handleChange} />
          </fieldset>
        );
      }
    }
    class Calculator extends React.Component {
      constructor(props) {
        super(props);
        this.handleCelsiusChange = this.handleCelsiusChange.bind(this);
        this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);
        this.state = {temperature: '', scale: 'c'};
      }
      handleCelsiusChange(temperature) {
        this.setState({scale: 'c', temperature});
      }
      handleFahrenheitChange(temperature) {
        this.setState({scale: 'f', temperature});
      }
      render() {
        const scale = this.state.scale;
        const temperature = this.state.temperature;
        const celsius =
          scale === 'f' ?
            tryConvert(temperature, toCelsius) : temperature;
        const fahrenheit =
          scale === 'c' ?
            tryConvert(temperature, toFahrenheit) : temperature;
        return (
          <div>
            <TemperatureInput
              scale="c"
              temperature={celsius}
              onTemperatureChange={this.handleCelsiusChange} />
            <TemperatureInput
              scale="f"
              temperature={fahrenheit}
              onTemperatureChange={this.handleFahrenheitChange} />
            <BoilingVerdict
              celsius={parseFloat(celsius)} />
          </div>
        );
      }
    }
    const ls_root = ReactDOM.createRoot(document.getElementById('ls_root'));
    ls_root.render(<Calculator />);
  </script>
  <pre><code class="">
    const scaleNames = {
      c: 'Celsius',
      f: 'Fahrenheit'
    };
    function toCelsius(fahrenheit) {
      return (fahrenheit - 32) * 5 / 9;
    }
    function toFahrenheit(celsius) {
      return (celsius * 9 / 5) + 32;
    }
    function tryConvert(temperature, convert) {
      const input = parseFloat(temperature);
      if (Number.isNaN(input)) {
        return '';
      }
      const output = convert(input);
      const rounded = Math.round(output * 1000) / 1000;
      return rounded.toString();
    }
    function BoilingVerdict(props) {
      if (props.celsius &gt;= 100) {
        return &lt;p&gt;The water would boil&lt;/p&gt;;
      }
      return &lt;p&gt;The water would not boil&lt;/p&gt;;
    }
    class TemperatureInput extends React.Component {
      constructor(props) {
        super(props);
        this.handleChange = this.handleChange.bind(this);
      }
      handleChange(e) {
        // send local value to Calculator handler
        this.props.onTemperatureChange(e.target.value);
      }
      render() {
        const temperature = this.props.temperature;
        const scale = this.props.scale;
        return (
          &lt;fieldset&gt;
            &lt;legend&gt;Enter temperature in {scaleNames[scale]}:&lt;/legend&gt;
            &lt;input
              value={temperature}
              onChange={this.handleChange} /&gt;
          &lt;/fieldset&gt;
        );
      }
    }
    class Calculator extends React.Component {
      constructor(props) {
        super(props);
        this.handleCelsiusChange = this.handleCelsiusChange.bind(this);
        this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);
        // single source of truth for any data that changes
        this.state = {
          temperature: '',
          scale: 'c'
        };
      }
      // will re-render both TemperatureInput when calling their handlers
      handleCelsiusChange(temperature) {
        this.setState({scale: 'c', temperature});
      }
      handleFahrenheitChange(temperature) {
        this.setState({scale: 'f', temperature});
      }
      render() {
        const scale = this.state.scale;
        const temperature = this.state.temperature;
        const celsius =
          scale === 'f' ?
            tryConvert(temperature, toCelsius) : temperature;
        const fahrenheit =
          scale === 'c' ?
            tryConvert(temperature, toFahrenheit) : temperature;
        return (
          &lt;div&gt;
            &lt;TemperatureInput
              scale="c"
              temperature={celsius}
              onTemperatureChange={this.handleCelsiusChange} /&gt;
            &lt;TemperatureInput
              scale="f"
              temperature={fahrenheit}
              onTemperatureChange={this.handleFahrenheitChange} /&gt;
            &lt;BoilingVerdict
              celsius={parseFloat(celsius)} /&gt;
          &lt;/div&gt;
        );
      }
    }
    const ls_root = ReactDOM.createRoot(document.getElementById('ls_root'));
    ls_root.render(&lt;Calculator /&gt;);
  </code></pre>



<h2 id="comp">Composition</h2>

  <ul>
    <li>use composition instead of inheritance to reuse code between components</li>
    <li>if you want to reuse non-UI functionality between components, extract it into a separate JS module</li>
  </ul>

  <details><summary>props.children - contains anything between component tags</summary>
  <pre><code class="">
    function FancyBorder(props) {
      return (
        &lt;div className={'FancyBorder FancyBorder-' + props.color}&gt;
          {props.children}
        &lt;/div&gt;
      );
    }
    function WelcomeDialog() {
      return (
        &lt;FancyBorder color="blue"&gt;
          &lt;h1 className="Dialog-title"&gt;
            Welcome
          &lt;/h1&gt;
          &lt;p className="Dialog-message"&gt;
            Thank you for visiting our spacecraft!
          &lt;/p&gt;
        &lt;/FancyBorder&gt;
      );
    }
  </code></pre></details>

  <details><summary>pass React elements as props like any other data</summary>
  <pre><code class="">
    function SplitPane(props) {
      return (
        &lt;div className="SplitPane"&gt;
          &lt;div className="SplitPane-left"&gt;
            {props.left}
          &lt;/div&gt;
          &lt;div className="SplitPane-right"&gt;
            {props.right}
          &lt;/div&gt;
        &lt;/div&gt;
      );
    }
    function App() {
      return (
        &lt;SplitPane
          left={
            &lt;Contacts /&gt;
          }
          right={
            &lt;Chat /&gt;
          } /&gt;
      );
    }
  </code></pre></details>

  <details><summary>more specific component renders a more generic</summary>
  <pre><code class="">
    function Dialog(props) {
      return (
        &lt;FancyBorder color="blue"&gt;
          &lt;h1 className="Dialog-title"&gt;
            {props.title}
          &lt;/h1&gt;
          &lt;p className="Dialog-message"&gt;
            {props.message}
          &lt;/p&gt;
        &lt;/FancyBorder&gt;
      );
    }
    function WelcomeDialog() {
      return (
        &lt;Dialog
          title="Welcome"
          message="Thank you for visiting our spacecraft!" /&gt;
      );
    }
    // --- OR
    function Dialog(props) {
      return (
        &lt;FancyBorder color="blue"&gt;
          &lt;h1 className="Dialog-title"&gt;
            {props.title}
          &lt;/h1&gt;
          &lt;p className="Dialog-message"&gt;
            {props.message}
          &lt;/p&gt;
          {props.children}
        &lt;/FancyBorder&gt;
      );
    }
    class SignUpDialog extends React.Component {
      constructor(props) {
        super(props);
        this.handleChange = this.handleChange.bind(this);
        this.handleSignUp = this.handleSignUp.bind(this);
        this.state = {login: ''};
      }
      render() {
        return (
          &lt;Dialog
            title="Mars Exploration Program"
            message="How should we refer to you?"&gt;
            &lt;input
              value={this.state.login}
              onChange={this.handleChange} /&gt;
            &lt;button onClick={this.handleSignUp}&gt;
              Sign Me Up!
            &lt;/button&gt;
          &lt;/Dialog&gt;
        );
      }
      handleChange(e) {
        this.setState({login: e.target.value});
      }
      handleSignUp() {
        alert(`Welcome aboard, ${this.state.login}!`);
      }
    }
  </code></pre></details>

  <details><summary>composition alternatives</summary>
  <pre><code class="">
    // pass down the Avatar component itself
    // so that the intermediate components dont need to know
    // about the user or avatarSize props
    function Page(props) {
      const user = props.user;
      const userLink = (
        &lt;Link href={user.permalink}&gt;
          &lt;Avatar user={user} size={props.avatarSize} /&gt;
        &lt;/Link&gt;
      );
      return &lt;PageLayout userLink={userLink} /&gt;;
    }

    // Now, we have:
    &lt;Page user={user} avatarSize={avatarSize} /&gt;
    // ... which renders ...
    &lt;PageLayout userLink={...} /&gt;
    // ... which renders ...
    &lt;NavigationBar userLink={...} /&gt;
    // ... which renders ...
    {props.userLink}

    // pass multiple children,
    // or even have multiple separate "slots" for children
    function Page(props) {
      const user = props.user;
      const content = &lt;Feed user={user} /&gt;;
      const topBar = (
        &lt;NavigationBar&gt;
          &lt;Link href={user.permalink}&gt;
            &lt;Avatar user={user} size={props.avatarSize} /&gt;
          &lt;/Link&gt;
        &lt;/NavigationBar&gt;
      );
      return (
        &lt;PageLayout
          topBar={topBar}
          content={content}
        /&gt;
      );
    }
  </code></pre></details>


<h2 id="context">Context</h2>

  <ul>
    <li>pass data through the component tree without having to pass props down manually at every level</li>
    <li>designed to share data that can be considered "global" for a tree of React components, such as the current authenticated user, theme, or preferred language</li>
    <li>if you only want to avoid passing some props through many levels, component composition is often a simpler solution than context</li>
    <li>API
      <ul>
        <li><strong>const MyContext = React.createContext(defaultValue)</strong> , React.createContext - creates a Context object, when React renders a component that subscribes to this Context object it will read the current context value from the closest matching <u>Provider</u> above it in the tree, defaultValue argument is <u>only</u> used when a component does not have a matching Provider above it in the tree, this can be helpful for testing components in isolation without wrapping them, passing <u>undefined</u> as a Provider value does not cause consuming components to use defaultValue</li>
        <li><strong>&lt;MyContext.Provider value={/* some value */}&gt;</strong> , Context.Provider - allows consuming components to subscribe to context changes, accepts a value prop to be passed to consuming components that are descendants of this Provider, one Provider can be connected to many consumers, providers can be nested to override values deeper within the tree, all consumers that are descendants of a Provider will re-render whenever the Provider value prop changes</li>
        <li><strong>MyClass.contextType = MyContext</strong> , Class.contextType - lets you consume the nearest current value of that Context type using this.context, reference this in any of the lifecycle methods including the render function, can only subscribe to a single context, see Consuming Multiple Contexts, use a static class field to initialize contextType with experimental public class fields syntax</li>
        <li><strong>&lt;MyContext.Consumer&gt;{value => /* render with value */}&lt;/MyContext.Consumer&gt;</strong> , Context.Consumer - React component that subscribes to context changes, lets you subscribe to a context within a function component, requires a function as a child which receives the current context value and returns a React node, value argument passed to the function will be equal to the value prop of the closest Provider for this context above in the tree, if there is no Provider for this context above, the value argument will be equal to the defaultValue that was passed to createContext()</li>
      </ul>
    </li>
    <li>pass a function down through the context to allow consumers to update the context from a component that is nested somewhere deeply in the component tree</li>
    <li>make each context consumer a separate node in the tree to keep context re-rendering fast</li>
    <li>lift the value into the parents state to avoid re-rendering all consumers every time the Provider re-renders</li>
  </ul>

  <details><summary>Dynamic Context</summary>
  <div class="example" id="context_root_1"></div>
  <script type="text/babel">
    // --- theme-context.js
    // export
    const themes = {
      light: {
        foreground: '#000000',
        background: '#eeeeee',
      },
      dark: {
        foreground: '#ffffff',
        background: '#222222',
      },
    };
    // export
    const ThemeContextOne = React.createContext(
      themes.dark // default value
    );
    // --- themed-button.js
    // import {ThemeContext} from './theme-context';
    class ThemedButtonOne extends React.Component {
      render() {
        let props = this.props;
        let theme = this.context;
        return (
          <button
            {...props}
            style={{
              backgroundColor: theme.background,
              color: theme.foreground
            }}
          />
        );
      }
    }
    ThemedButtonOne.contextType = ThemeContextOne;
    // export default ThemedButton;
    // --- app.js
    // import {ThemeContextOne, themes} from './theme-context';
    // import ThemedButtonOne from './themed-button';
    // An intermediate component that uses the ThemedButtonOne
    function Toolbar(props) {
      return (
        <ThemedButtonOne onClick={props.changeTheme}>
          Change Theme
        </ThemedButtonOne>
      );
    }
    class ContextAppOne extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          theme: themes.light,
        };
        this.toggleTheme = () => {
          this.setState(state => ({
            theme:
              state.theme === themes.dark
                ? themes.light
                : themes.dark,
          }));
        };
      }
      render() {
        // The ThemedButtonOne button inside the ThemeProvider
        // uses the theme from state while the one outside uses
        // the default dark theme
        return (
          <div>
            <ThemeContextOne.Provider value={this.state.theme}>
              <Toolbar changeTheme={this.toggleTheme} />
            </ThemeContextOne.Provider>
            <div>
            <ThemedButtonOne>
              Default Theme
            </ThemedButtonOne>
            </div>
          </div>
        );
      }
    }
    const context_root_1 = ReactDOM.createRoot(document.getElementById('context_root_1'));
    context_root_1.render(<ContextAppOne />);
  </script>
  <pre><code class="">
    // --- theme-context.js
    // export
    const themes = {
      light: {
        foreground: '#000000',
        background: '#eeeeee',
      },
      dark: {
        foreground: '#ffffff',
        background: '#222222',
      },
    };
    // export
    const ThemeContextOne = React.createContext(
      themes.dark // default value
    );
    // --- themed-button.js
    // import {ThemeContext} from './theme-context';
    class ThemedButtonOne extends React.Component {
      render() {
        let props = this.props;
        let theme = this.context;
        return (
          &lt;button
            {...props}
            style={{
              backgroundColor: theme.background,
              color: theme.foreground
            }}
          /&gt;
        );
      }
    }
    ThemedButtonOne.contextType = ThemeContextOne;
    // export default ThemedButton;
    // --- app.js
    // import {ThemeContextOne, themes} from './theme-context';
    // import ThemedButtonOne from './themed-button';
    // An intermediate component that uses the ThemedButtonOne
    function Toolbar(props) {
      return (
        &lt;ThemedButtonOne onClick={props.changeTheme}&gt;
          Change Theme
        &lt;/ThemedButtonOne&gt;
      );
    }
    class ContextAppOne extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          theme: themes.light,
        };
        this.toggleTheme = () =&gt; {
          this.setState(state =&gt; ({
            theme:
              state.theme === themes.dark
                ? themes.light
                : themes.dark,
          }));
        };
      }
      render() {
        // The ThemedButtonOne button inside the ThemeProvider
        // uses the theme from state while the one outside uses
        // the default dark theme
        return (
          &lt;div&gt;
            &lt;ThemeContextOne.Provider value={this.state.theme}&gt;
              &lt;Toolbar changeTheme={this.toggleTheme} /&gt;
            &lt;/ThemeContextOne.Provider&gt;
            &lt;div&gt;
            &lt;ThemedButtonOne&gt;
              Default Theme
            &lt;/ThemedButtonOne&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        );
      }
    }
    const context_root_1 = ReactDOM.createRoot(document.getElementById('context_root_1'));
    context_root_1.render(&lt;ContextAppOne /&gt;);
  </code></pre></details>

  <details><summary>Updating Context from a Nested Component</summary>
  <div class="example" id="context_root_2"></div>
  <script type="text/babel">
    // --- theme-context.js
    // Make sure the shape of the default value passed to
    // createContext matches the shape that the consumers expect!
    // export
    const ThemeContextTwo = React.createContext({
      theme: themes.dark,
      toggleTheme: () => {},
    });
    // --- theme-toggler-button.js
    // import {ThemeContextTwo} from './theme-context';
    function ThemeTogglerButton() {
      // The Theme Toggler Button receives not only the theme
      // but also a toggleTheme function from the context
      return (
        <ThemeContextTwo.Consumer>
          {({theme, toggleTheme}) => (
            <button
              onClick={toggleTheme}
              style={{
                backgroundColor: theme.background,
                color: theme.foreground
              }}>
              Toggle Theme
            </button>
          )}
        </ThemeContextTwo.Consumer>
      );
    }
    // export default ThemeTogglerButton;
    // --- app.js
    // import {ThemeContextTwo, themes} from './theme-context';
    // import ThemeTogglerButton from './theme-toggler-button';
    class ContextAppTwo extends React.Component {
      constructor(props) {
        super(props);
        this.toggleTheme = () => {
          this.setState(state => ({
            theme:
              state.theme === themes.dark
                ? themes.light
                : themes.dark,
          }));
        };
        // State also contains the updater function so it will
        // be passed down into the context provider
        this.state = {
          theme: themes.light,
          toggleTheme: this.toggleTheme,
        };
      }
      render() {
        // The entire state is passed to the provider
        return (
          <ThemeContextTwo.Provider value={this.state}>
            <Content />
          </ThemeContextTwo.Provider>
        );
      }
    }
    function Content() {
      return (
        <div>
          <ThemeTogglerButton />
        </div>
      );
    }
    const context_root_2 = ReactDOM.createRoot(document.getElementById('context_root_2'));
    context_root_2.render(<ContextAppTwo />);
  </script>
  <pre><code class="">
    // --- theme-context.js
    // Make sure the shape of the default value passed to
    // createContext matches the shape that the consumers expect!
    // export
    const ThemeContextTwo = React.createContext({
      theme: themes.dark,
      toggleTheme: () => {},
    });
    // --- theme-toggler-button.js
    // import {ThemeContextTwo} from './theme-context';
    function ThemeTogglerButton() {
      // The Theme Toggler Button receives not only the theme
      // but also a toggleTheme function from the context
      return (
        &lt;ThemeContextTwo.Consumer&gt;
          {({theme, toggleTheme}) =&gt; (
            &lt;button
              onClick={toggleTheme}
              style={{
                backgroundColor: theme.background,
                color: theme.foreground
              }}&gt;
              Toggle Theme
            &lt;/button&gt;
          )}
        &lt;/ThemeContextTwo.Consumer&gt;
      );
    }
    // export default ThemeTogglerButton;
    // --- app.js
    // import {ThemeContextTwo, themes} from './theme-context';
    // import ThemeTogglerButton from './theme-toggler-button';
    class ContextAppTwo extends React.Component {
      constructor(props) {
        super(props);
        this.toggleTheme = () =&gt; {
          this.setState(state =&gt; ({
            theme:
              state.theme === themes.dark
                ? themes.light
                : themes.dark,
          }));
        };
        // State also contains the updater function so it will
        // be passed down into the context provider
        this.state = {
          theme: themes.light,
          toggleTheme: this.toggleTheme,
        };
      }
      render() {
        // The entire state is passed to the provider
        return (
          &lt;ThemeContextTwo.Provider value={this.state}&gt;
            &lt;Content /&gt;
          &lt;/ThemeContextTwo.Provider&gt;
        );
      }
    }
    function Content() {
      return (
        &lt;div&gt;
          &lt;ThemeTogglerButton /&gt;
        &lt;/div&gt;
      );
    }
    const context_root_2 = ReactDOM.createRoot(document.getElementById('context_root_2'));
    context_root_2.render(&lt;ContextAppTwo /&gt;);
  </code></pre></details>

  <details><summary>Consuming Multiple Contexts</summary>
  <pre><code class="">
    // Theme context, default to light theme
    const ThemeContextThree = React.createContext('light');
    // Signed-in user context
    const UserContextThree = React.createContext({
      name: 'Guest',
    });
    class ContextAppThree extends React.Component {
      render() {
        const {signedInUser, theme} = this.props;
        // App component that provides initial context values
        return (
          &lt;ThemeContextThree.Provider value={theme}&gt;
            &lt;UserContextThree.Provider value={signedInUser}&gt;
              &lt;Layout /&gt;
            &lt;/UserContextThree.Provider&gt;
          &lt;/ThemeContextThree.Provider&gt;
        );
      }
    }
    function Layout() {
      return (
        &lt;div&gt;
          &lt;Sidebar /&gt;
          &lt;Content /&gt;
        &lt;/div&gt;
      );
    }
    // A component may consume multiple contexts
    function Content() {
      return (
        &lt;ThemeContextThree.Consumer&gt;
          {theme =&gt; (
            &lt;UserContextThree.Consumer&gt;
              {user =&gt; (
                &lt;ProfilePage user={user} theme={theme} /&gt;
              )}
            &lt;/UserContextThree.Consumer&gt;
          )}
        &lt;/ThemeContextThree.Consumer&gt;
      );
    }
  </code></pre></details>



<h2 id="err">Error Boundaries</h2>

  <ul>
    <li>catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed, during rendering, in lifecycle methods, and in constructors of the whole tree below them</li>
    <li>only catches errors in the components below them in the tree</li>
    <li>do not catch errors for
      <ul>
        <li>event handlers (use the regular JS try/catch statement)</li>
        <li>asynchronous code (e.g. setTimeout or requestAnimationFrame callbacks)</li>
        <li>server side rendering</li>
        <li>errors thrown in the error boundary itself (rather than its children)</li>
      </ul>
    </li>
    <li>class component becomes an error boundary if it defines either (or both) of the lifecycle methods
      <ul>
        <li><strong>static getDerivedStateFromError()</strong> to render a fallback UI after an error has been thrown</li>
        <li><strong>componentDidCatch()</strong> to log error information</li>
      </ul>
    </li>
    <li>work like a JS catch{} block, but for components</li>
    <li>youll want to declare an error boundary component once and use it throughout application</li>
    <li>you may <u>wrap top-level route components</u> to display a "Something went wrong" message to the user, just like server-side frameworks often handle crashes OR <u>wrap individual widgets</u> in an error boundary to protect them from crashing the rest of the application</li>
    <li>babel-plugin-transform-react-jsx-source - for line numbers with errors <strong>while developing</strong>, works by default in Create React App projects</li>
  </ul>

  <div class="example" id="err_root"></div>
  <script type="text/babel">
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { error: null, errorInfo: null };
      }
      componentDidCatch(error, errorInfo) {
        // Catch errors in any components below and re-render with error message
        this.setState({
          error: error,
          errorInfo: errorInfo
        })
        // You can also log error messages to an error reporting service here
      }
      render() {
        if (this.state.errorInfo) {
          // Error path
          return (
            <div>
              <h2>Something went wrong.</h2>
              <details style={{ whiteSpace: 'pre-wrap' }}>
                {this.state.error && this.state.error.toString()}
                <br />
                {this.state.errorInfo.componentStack}
              </details>
            </div>
          );
        }
        // Normally, just render children
        return this.props.children;
      }
    }
    class BuggyCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = { counter: 0 };
        this.handleClick = this.handleClick.bind(this);
      }
      handleClick() {
        this.setState(({counter}) => ({
          counter: counter + 1
        }));
        // try {
        //   // Do something that could throw
        // } catch (error) {
        //   this.setState({ error });
        // }
      }
      render() {
        if (this.state.counter === 5) {
          // Simulate a JS error
          throw new Error('I crashed!');
        }
        return <h1 onClick={this.handleClick}>{this.state.counter}</h1>;
        // if (this.state.error) {
        //   return <h1>Caught an error.</h1>
        // }
        // return <div onClick={this.handleClick}>Click Me</div>
      }
    }
    function ErrApp() {
      return (
        <div>
          <p>
            <b>
              example of error boundaries in React<br />
              Click on the numbers to increase the counters<br />
              The counter is programmed to throw when it reaches 5<br />
              This simulates a JavaScript error in a component
            </b>
          </p>
          <hr />
          <ErrorBoundary>
            <p>These two counters are inside the same error boundary<br />
              If one crashes, the error boundary will replace both of them.</p>
            <BuggyCounter />
            <BuggyCounter />
          </ErrorBoundary>
          <hr />
          <p>These two counters are each inside of their own error boundary<br />
            So if one crashes, the other is not affected.</p>
          <ErrorBoundary><BuggyCounter /></ErrorBoundary>
          <ErrorBoundary><BuggyCounter /></ErrorBoundary>
        </div>
      );
    }
    const err_root = ReactDOM.createRoot(document.getElementById('err_root'));
    err_root.render(<ErrApp />);
  </script>
  <pre><code class="">
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false };
      }
      static getDerivedStateFromError(error) {
        // Update state so the next render will show the fallback UI.
        return { hasError: true };
      }
      componentDidCatch(error, info) {
        // You can also log the error to an error reporting service
        logErrorToMyService(error, info);
      }
      render() {
        if (this.state.hasError) {
          // You can render any custom fallback UI
          return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;
        }
        return this.props.children;
      }
    }
    // then you can use it as a regular component:
    &lt;ErrorBoundary&gt;
      &lt;MyWidget /&gt;
    &lt;/ErrorBoundary&gt;

    // --- --- ---

    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { error: null, errorInfo: null };
      }
      componentDidCatch(error, errorInfo) {
        // Catch errors in any components below and re-render with error message
        this.setState({
          error: error,
          errorInfo: errorInfo
        })
        // You can also log error messages to an error reporting service here
      }
      render() {
        if (this.state.errorInfo) {
          // Error path
          return (
            &lt;div&gt;
              &lt;h2&gt;Something went wrong.&lt;/h2&gt;
              &lt;details style={{ whiteSpace: 'pre-wrap' }}&gt;
                {this.state.error && this.state.error.toString()}
                &lt;br /&gt;
                {this.state.errorInfo.componentStack}
              &lt;/details&gt;
            &lt;/div&gt;
          );
        }
        // Normally, just render children
        return this.props.children;
      }
    }
    class BuggyCounter extends React.Component {
      constructor(props) {
        super(props);
        this.state = { counter: 0 };
        this.handleClick = this.handleClick.bind(this);
      }
      handleClick() {
        this.setState(({counter}) =&gt; ({
          counter: counter + 1
        }));
        // try {
        //   // Do something that could throw
        // } catch (error) {
        //   this.setState({ error });
        // }
      }
      render() {
        if (this.state.counter === 5) {
          // Simulate a JS error
          throw new Error('I crashed!');
        }
        return &lt;h1 onClick={this.handleClick}&gt;{this.state.counter}&lt;/h1&gt;;
        // if (this.state.error) {
        //   return &lt;h1&gt;Caught an error.&lt;/h1&gt;
        // }
        // return &lt;div onClick={this.handleClick}&gt;Click Me&lt;/div&gt;
      }
    }
    function ErrApp() {
      return (
        &lt;div&gt;
          &lt;p&gt;
            &lt;b&gt;
              example of error boundaries in React&lt;br /&gt;
              Click on the numbers to increase the counters&lt;br /&gt;
              The counter is programmed to throw when it reaches 5&lt;br /&gt;
              This simulates a JavaScript error in a component
            &lt;/b&gt;
          &lt;/p&gt;
          &lt;hr /&gt;
          &lt;ErrorBoundary&gt;
            &lt;p&gt;These two counters are inside the same error boundary&lt;br /&gt;
            If one crashes, the error boundary will replace both of them.&lt;/p&gt;
            &lt;BuggyCounter /&gt;
            &lt;BuggyCounter /&gt;
          &lt;/ErrorBoundary&gt;
          &lt;hr /&gt;
          &lt;p&gt;These two counters are each inside of their own error boundary&lt;br /&gt;
          So if one crashes, the other is not affected.&lt;/p&gt;
          &lt;ErrorBoundary&gt;&lt;BuggyCounter /&gt;&lt;/ErrorBoundary&gt;
          &lt;ErrorBoundary&gt;&lt;BuggyCounter /&gt;&lt;/ErrorBoundary&gt;
        &lt;/div&gt;
      );
    }
    const err_root = ReactDOM.createRoot(document.getElementById('err_root'));
    err_root.render(&lt;ErrApp /&gt;);
  </code></pre>



<h2 id="ref">Ref</h2>

  <ul>
    <li>access DOM nodes or React elements created in the render method
      <ul>
        <li>managing focus, text selection, or media playback</li>
        <li>triggering imperative animations</li>
        <li>integrating with third-party DOM libraries</li>
      </ul>
    </li>
    <li>avoid using refs for anything that can be done declaratively: instead of exposing open() and close() methods on a Dialog component, pass an isOpen prop to it</li>
    <li>when a ref is passed to an element in render(), a reference to the node becomes accessible at the "current" attribute of the ref, when the "ref" attribute is used:
      <ul>
        <li>on an <strong>HTML element</strong>, the ref created in the constructor with React.createRef() receives the underlying DOM element as its "current" property, React will assign the current property with the DOM element when the component mounts, and assign it back to null when it unmounts, ref updates happen before componentDidMount or componentDidUpdate lifecycle methods</li>
        <li>on a <strong>custom class component</strong>, the ref object receives the mounted instance of the component as its "current</li>
      </ul>
    </li>
    <li><strong>dont use the ref attribute on function components</strong> because they dont have instances, convert the component to a class if you need a ref to it, just like you do when you need lifecycle methods or state, however, <strong>use the ref attribute inside a function component as long as you refer to a DOM element or a class component</strong></li>
    <li>refs are guaranteed to be up-to-date before componentDidMount or componentDidUpdate fires</li>
    <li><strong>ref forwarding</strong> - automatically passing a ref (access DOM nodes or React elements created in the render method) through a component to one of its children, not necessary for most components in the application, can be useful for some kinds of components, especially in reusable component libraries</li>
    <li><strong>callback refs</strong> - more control over when refs are set and unset, instead of passing a ref attribute created by createRef(), you pass a function which receives the React component instance or HTML DOM element as its argument, which can be stored and accessed elsewhere</li>
    <li>if the ref callback is defined as an inline function, it will get <u>called twice during updates</u>, first with null and then again with the DOM element, this is because a new instance of the function is created with each render, so React needs to clear the old ref and set up the new one, avoid this by defining the ref callback as a bound method on the class, but note that it shouldnt matter in most cases</li>
  </ul>

  <pre><code class="">
    // create ref
    class MyComponent extends React.Component {
      constructor(props) {
        super(props);
        this.myRef = React.createRef();
        const node = this.myRef.current; // reference to the node
      }
      render() {
        return &lt;div ref={this.myRef} /&gt;;
      }
    }

    // --- adding a ref to a dom element
    class CustomTextInput extends React.Component {
      constructor(props) {
        super(props);
        // create a ref to store the textInput DOM element
        this.textInput = React.createRef();
        this.focusTextInput = this.focusTextInput.bind(this);
      }
      focusTextInput() {
        // Explicitly focus the text input using the raw DOM API
        // Note: we are accessing "current" to get the DOM node
        this.textInput.current.focus();
      }
      render() {
        // tell React that we want to associate the input ref
        // with the "textInput" that we created in the constructor
        return (
          &lt;div&gt;
            &lt;input
              type="text"
              ref={this.textInput} /&gt;
            &lt;input
              type="button"
              value="Focus the text input"
              onClick={this.focusTextInput}
            /&gt;
          &lt;/div&gt;
        );
      }
    }

    // --- adding a ref to a class component
    // simulate click immediately after mounting
    // only works if CustomTextInput is declared as a class
    class AutoFocusTextInput extends React.Component {
      constructor(props) {
        super(props);
        this.textInput = React.createRef();
      }
      componentDidMount() {
        this.textInput.current.focusTextInput();
      }
      render() {
        return (
          &lt;CustomTextInput ref={this.textInput} /&gt;
        );
      }
    }

    // --- use the ref attribute inside a function component
    function CustomTextInput(props) {
      // textInput must be declared here so the ref can refer to it
      let textInput = React.createRef();
      function handleClick() {
        textInput.current.focus();
      }
      return (
        &lt;div&gt;
          &lt;input
            type="text"
            ref={textInput} /&gt;
          &lt;input
            type="button"
            value="Focus the text input"
            onClick={handleClick}
          /&gt;
        &lt;/div&gt;
      );
    }

    // --- add a wrapper DOM node in component and attach a ref directly to it
    class MyComponent extends React.Component {
      constructor(props) {
        super(props);
        this.wrapper = React.createRef();
      }
      render() {
        return &lt;div ref={this.wrapper}&gt;{this.props.children}&lt;/div&gt;;
      }
    }
  </code></pre>

  <details><summary>forwarding refs</summary>
  <pre><code class="">
    // --- to DOM components
    // 5 - when the ref is attached, ref.current will point to the button DOM node
    const FancyButton = React.forwardRef((props, ref) => (
      // 3 - ref is passed
      // 4 - forward ref down to button by specifying it as a JSX attribute
      &lt;button ref={ref} className="FancyButton"&gt;
        {props.children}
      &lt;/button&gt;
    ));
    // You can now get a ref directly to the DOM button:
    const ref = React.createRef(); // 1 - create a React ref
    // 2 - pass our ref down to FancyButton by specifying it as a JSX attribute
    &lt;FancyButton ref={ref}&gt;Click me!&lt;/FancyButton&gt;;

    // --- in higher-order components
    function logProps(Component) {
      class LogProps extends React.Component {
        componentDidUpdate(prevProps) {
          console.log('old props:', prevProps);
          console.log('new props:', this.props);
        }
        render() {
          const {forwardedRef, ...rest} = this.props;

          // Assign the custom prop "forwardedRef" as a ref
          return &lt;Component ref={forwardedRef} {...rest} /&gt;;
        }
      }
      // Note the second param "ref" provided by React.forwardRef.
      // We can pass it along to LogProps as a regular prop, e.g. "forwardedRef"
      // And it can then be attached to the Component.
      return React.forwardRef((props, ref) =&gt; {
        return &lt;LogProps {...props} forwardedRef={ref} /&gt;;
      });
    }
    // ... log all props that get passed to our "fancy button" component
    class FancyButton extends React.Component {
      focus() {
        // ...
      }
      // ...
    }
    // Rather than exporting FancyButton, we export LogProps
    // It will render a FancyButton though
    export default logProps(FancyButton);

    // --- displaying a custom name in DevTools
    const WrappedComponent = React.forwardRef((props, ref) =&gt; {
      return &lt;LogProps {...props} forwardedRef={ref} /&gt;;
    });
    // include the render function name
    const WrappedComponent = React.forwardRef(
      function myFunction(props, ref) {
        return &lt;LogProps {...props} forwardedRef={ref} /&gt;;
      }
    );
    // set the function displayName property to include the wrapping component
    function logProps(Component) {
      class LogProps extends React.Component {
        // ...
      }
      function forwardRef(props, ref) {
        return &lt;LogProps {...props} forwardedRef={ref} /&gt;;
      }
      // Give this component a more helpful display name in DevTools.
      // e.g. "ForwardRef(logProps(MyComponent))"
      const name = Component.displayName || Component.name;
      forwardRef.displayName = `logProps(${name})`;
      return React.forwardRef(forwardRef);
    }

    // --- ref forwarding alternatives before 16.3
    function CustomTextInput(props) {
      return (
        &lt;div&gt;
          &lt;input ref={props.inputRef} /&gt;
        &lt;/div&gt;
      );
    }
    function Parent(props) {
      return (
        &lt;div&gt;
          My input: &lt;CustomTextInput inputRef={props.inputRef} /&gt;
        &lt;/div&gt;
      );
    }
    class Grandparent extends React.Component {
      constructor(props) {
        super(props);
        this.inputElement = React.createRef();
      }
      render() {
        return (
          &lt;Parent inputRef={this.inputElement} /&gt;
        );
      }
    }
  </code></pre></details>

  <details><summary>callback refs</summary>
  <pre><code class="">
    // using the ref callback to store a reference to a DOM node in an instance property
    class CustomTextInput extends React.Component {
      constructor(props) {
        super(props);
        this.textInput = null;
        this.setTextInputRef = element => {
          this.textInput = element;
        };
        this.focusTextInput = () => {
          // Focus the text input using the raw DOM API
          if (this.textInput) this.textInput.focus();
        };
      }
      componentDidMount() {
        // autofocus the input on mount
        this.focusTextInput();
      }
      render() {
        // Use the "ref" callback to store a reference to the text input DOM
        // element in an instance field (for example, this.textInput).
        return (
          &lt;div&gt;
            &lt;input
              type="text"
              ref={this.setTextInputRef}
            /&gt;
            &lt;input
              type="button"
              value="Focus the text input"
              onClick={this.focusTextInput}
            /&gt;
          &lt;/div&gt;
        );
      }
    }

    // --- pass callback refs between components, like objects ref
    // this.inputElement in Parent will be set
    // to the DOM node corresponding to the input element in the CustomTextInput
    function CustomTextInput(props) {
      // pass same function as a special ref attribute to the input
      return (
        &lt;div&gt;
          &lt;input ref={props.inputRef} /&gt;
        &lt;/div&gt;
      );
    }
    class Parent extends React.Component {
      render() {
        // pass ref callback as an inputRef prop to the CustomTextInput
        return (
          &lt;CustomTextInput
            inputRef={el =&gt; this.inputElement = el}
          /&gt;
        );
      }
    }
  </code></pre></details>



<h2 id="fragments">Fragments</h2>

  <ul>
    <li>group a list of children without adding extra nodes to the DOM</li>
    <li>a common pattern in React is for a component to return multiple elements</li>
    <li>fragments declared with the explicit &lt;React.Fragment&gt; syntax may have keys</li>
  </ul>

  <div class="example" id="fragments_root"></div>
  <script type="text/babel">
    class FragmentsTable extends React.Component {
      render() {
        return (
          <table>
          <tbody>
            <tr>
              <FragmentsColumns />
            </tr>
          </tbody>
          </table>
        );
      }
    }
    class FragmentsColumns extends React.Component {
      render() {
        return (
          <React.Fragment>
            <td>Hello</td>
            <td>World</td>
          </React.Fragment>
        );
      }
    }
    const fragments_root = ReactDOM.createRoot(document.getElementById('fragments_root'));
    fragments_root.render(<FragmentsTable />);
  </script>
  <pre><code class="">
    class FragmentsTable extends React.Component {
      render() {
        return (
          &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;FragmentsColumns /&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
          &lt;/table&gt;
        );
      }
    }
    class FragmentsColumns extends React.Component {
      render() {
        return (
          &lt;React.Fragment&gt;
            &lt;td&gt;Hello&lt;/td&gt;
            &lt;td&gt;World&lt;/td&gt;
          &lt;/React.Fragment&gt;
        );
      }
    }
    const fragments_root = ReactDOM.createRoot(document.getElementById('fragments_root'));
    fragments_root.render(&lt;FragmentsTable /&gt;);

    // --- keyed fragments
    function Glossary(props) {
      return (
        &lt;dl&gt;
          {props.items.map(item =&gt; (
            // Without the `key`, React will fire a key warning
            &lt;React.Fragment key={item.id}&gt;
              &lt;dt&gt;{item.term}&lt;/dt&gt;
              &lt;dd&gt;{item.description}&lt;/dd&gt;
            &lt;/React.Fragment&gt;
          ))}
        &lt;/dl&gt;
      );
    }
  </code></pre>



<h2 id="hoc">HOC</h2>

  <ul>
    <li><strong>const EnhancedComponent = higherOrderComponent(WrappedComponent);</strong></li>
    <li>for reusing component logic, pattern that emerges from React compositional nature</li>
    <li>a function that takes a component and returns a new component, whereas a component transforms props into UI, a higher-order component <strong>transforms a component into another component</strong></li>
    <li>abstraction that allows us to define logic in a single place and share it across many components</li>
    <li>HOC is a pure function with zero side-effects - doesnt modify the input component, nor does it use inheritance to copy its behavior, composes the original component by wrapping it in a container component</li>
    <li>swap one HOC for a different one, as long as they provide the same props to the wrapped component, this may be useful if you change data-fetching libraries, for example</li>
    <li>conventions
      <ul>
        <li>dont mutate the original component (prototype,...), use composition</li>
        <li>pass unrelated props through to the wrapped component</li>
        <li>maximizing composability - config object is used to specify a component data dependencies</li>
        <li>wrap the display name for easy debugging </li>
      </ul>
    </li>
    <li><strong>dont Use HOCs inside the "render" method</strong> - apply HOCs outside the component definition so that the resulting component is created only once, its identity will be consistent across renders, in rare cases where you need to apply a HOC dynamically, you can also do it inside a component lifecycle methods or its constructor</li>
    <li><strong>static methods must be copied over</strong> - when you apply a hoc to a component, though, the original component is wrapped with a container component, that means the new component does not have any of the static methods of the original component, use hoist-non-react-statics to automatically copy all non-React static methods</li>
    <li>use the React.forwardRef - ref is not really a prop - like key, its handled specially by React</li>
  </ul>

  <pre><code class="">
    // This function takes a component...
    function withSubscription(WrappedComponent, selectData) {
      // ...and returns another component...
      return class extends React.Component {
        constructor(props) {
          super(props);
          this.handleChange = this.handleChange.bind(this);
          this.state = {
            data: selectData(DataSource, props)
          };
        }
        componentDidMount() {
          // ... that takes care of the subscription...
          DataSource.addChangeListener(this.handleChange);
        }
        componentWillUnmount() {
          DataSource.removeChangeListener(this.handleChange);
        }
        handleChange() {
          this.setState({
            data: selectData(DataSource, this.props)
          });
        }
        render() {
          // renders the wrapped component with the fresh data
          // pass through any additional props
          return &lt;WrappedComponent data={this.state.data} {...this.props} /&gt;;
        }
      };
    }

    const CommentListWithSubscription = withSubscription(
      CommentList,
      (DataSource) => DataSource.getComments()
    );

    const BlogPostWithSubscription = withSubscription(
      BlogPost,
      (DataSource, props) => DataSource.getBlogPost(props.id)
    );
  </code></pre>

  <h3>Advices</h3>
  <pre><code class="">
    // --- composition instead of prototyping
    function logProps(WrappedComponent) {
      return class extends React.Component {
        componentWillReceiveProps(nextProps) {
          console.log('Current props: ', this.props);
          console.log('Next props: ', nextProps);
        }
        render() {
          // wraps the input component in a container, without mutating it
          return &lt;WrappedComponent {...this.props} /&gt;;
        }
      }
    }

    // --- pass unrelated props through to the wrapped component
    // ...
    render() {
      // filter out extra props that are specific to this HOC
      // and shouldnt be passed through
      const { extraProp, ...passThroughProps } = this.props;
      // inject props into the wrapped component
      // these are usually state values or instance methods
      const injectedProp = someStateOrInstanceMethod;
      // Pass props to wrapped component
      return (
        &lt;WrappedComponent
          injectedProp={injectedProp}
          {...passThroughProps}
        /&gt;
      );
    }
    // ...

    // --- maximizing composability
    const CommentWithRelay = Relay.createContainer(Comment, config);
    // OR, instead of doing this...
    const EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))
    // ... you can use a function composition utility
    // compose(f, g, h) is the same as (...args) =&gt; f(g(h(...args)))
    const enhance = compose(
      // these are both single-argument HOCs
      withRouter,
      connect(commentSelector)
    )
    const EnhancedComponent = enhance(WrappedComponent)

    // --- wrap the display name for easy debugging
    function withSubscription(WrappedComponent) {
      class WithSubscription extends React.Component {/* ... */}
      WithSubscription.displayName =
        `WithSubscription(${getDisplayName(WrappedComponent)})`;
      return WithSubscription;
    }
    function getDisplayName(WrappedComponent) {
      return WrappedComponent.displayName || WrappedComponent.name || 'Component';
    }

    // --- dont use hocs inside the render method
    // ...
    render() {
      // A new version of EnhancedComponent is created on every render
      // EnhancedComponent1 !== EnhancedComponent2
      const EnhancedComponent = enhance(MyComponent);
      // That causes the entire subtree to unmount/remount each time!
      return &lt;EnhancedComponent /&gt;;
    }
    // ...

    // --- static methods must be copied over
    function enhance(WrappedComponent) {
      class Enhance extends React.Component {/*...*/}
      // must know exactly which method(s) to copy :(
      Enhance.staticMethod = WrappedComponent.staticMethod;
      return Enhance;
    }
    // OR, use hoist-non-react-statics to automatically copy all non-React static methods
    import hoistNonReactStatic from 'hoist-non-react-statics';
    function enhance(WrappedComponent) {
      class Enhance extends React.Component {/*...*/}
      hoistNonReactStatic(Enhance, WrappedComponent);
      return Enhance;
    }
    // OR, export the static method separately from the component itself
    // Instead of...
    MyComponent.someFunction = someFunction;
    export default MyComponent;
    // ...export the method separately...
    export { someFunction };
    // ...and in the consuming module, import both
    import MyComponent, { someFunction } from './MyComponent.js';
  </code></pre>



<h2 id="portals">Portals</h2>

  <ul>
    <li><strong>ReactDOM.createPortal(renderable_react_child, el)</strong> - way to render children into a DOM node that exists outside the DOM hierarchy of the parent component</li>
    <li>typical use case for portals is <strong>when a parent component has an overflow:hidden or z-index style</strong>, but you need the child to visually "break out" of its container, for example, dialogs, hovercards, and tooltips</li>
    <li>remember that managing keyboard focus becomes very important</li>
    <li>it behaves like a normal React child in every other way, context work exactly the same regardless of whether the child is a portal, as the portal still exists in the React tree regardless of position in the DOM tree, this includes event bubbling, event fired from inside a portal will propagate to ancestors in the containing React tree, even if those elements are not ancestors in the DOM tree</li>
  </ul>

  <div class="example">
    <div id="portal_root"></div>
    <div id="portal_modal"></div>
  </div>
  <script type="text/babel">
    // These two containers are siblings in the DOM
    const portal_root = document.getElementById('portal_root');
    const portal_modal = document.getElementById('portal_modal');

    class Modal extends React.Component {
      constructor(props) {
        super(props);
        this.el = document.createElement('div');
      }
      componentDidMount() {
        // The portal element is inserted in the DOM tree after
        // the Modal children are mounted, meaning that children
        // will be mounted on a detached DOM node. If a child
        // component requires to be attached to the DOM tree
        // immediately when mounted, for example to measure a
        // DOM node, or uses "autoFocus" in a descendant, add
        // state to Modal and only render the children when Modal
        // is inserted in the DOM tree
        portal_modal.appendChild(this.el);
      }
      componentWillUnmount() {
        portal_modal.removeChild(this.el);
      }
      render() {
        return ReactDOM.createPortal(
          this.props.children,
          this.el,
        );
      }
    }

    class Parent extends React.Component {
      constructor(props) {
        super(props);
        this.state = {clicks: 0};
        this.handleClick = this.handleClick.bind(this);
      }
      handleClick() {
        // This will fire when the button in Child is clicked,
        // updating Parent state, even though button
        // is not direct descendant in the DOM
        this.setState(state => ({
          clicks: state.clicks + 1
        }));
      }
      render() {
        return (
          <div onClick={this.handleClick}>
            <p>Number of clicks: {this.state.clicks}</p>
            <p>button is not a child of the div with the onClick handler</p>
            <Modal>
              <Child />
            </Modal>
          </div>
        );
      }
    }

    function Child() {
      // The click event on this button will bubble up to parent,
      // because there is no 'onClick' attribute defined
      return (
        <div className="modal">
          <button>Click</button>
        </div>
      );
    }

    const portal_root_root = ReactDOM.createRoot(portal_root);
    portal_root_root.render(<Parent />);
  </script>
  <pre><code class="">
    // These two containers are siblings in the DOM
    const portal_root = document.getElementById('portal_root');
    const portal_modal = document.getElementById('portal_modal');

    class Modal extends React.Component {
      constructor(props) {
        super(props);
        this.el = document.createElement('div');
      }
      componentDidMount() {
        // The portal element is inserted in the DOM tree after
        // the Modal children are mounted, meaning that children
        // will be mounted on a detached DOM node. If a child
        // component requires to be attached to the DOM tree
        // immediately when mounted, for example to measure a
        // DOM node, or uses "autoFocus" in a descendant, add
        // state to Modal and only render the children when Modal
        // is inserted in the DOM tree
        portal_modal.appendChild(this.el);
      }
      componentWillUnmount() {
        portal_modal.removeChild(this.el);
      }
      render() {
        return ReactDOM.createPortal(
          this.props.children,
          this.el,
        );
      }
    }

    class Parent extends React.Component {
      constructor(props) {
        super(props);
        this.state = {clicks: 0};
        this.handleClick = this.handleClick.bind(this);
      }
      handleClick() {
        // This will fire when the button in Child is clicked,
        // updating Parent state, even though button
        // is not direct descendant in the DOM
        this.setState(state =&gt; ({
          clicks: state.clicks + 1
        }));
      }
      render() {
        return (
          &lt;div onClick={this.handleClick}&gt;
            &lt;p&gt;Number of clicks: {this.state.clicks}&lt;/p&gt;
            &lt;p&gt;button is not a child of the div with the onClick handler&lt;/p&gt;
            &lt;Modal&gt;
              &lt;Child /&gt;
            &lt;/Modal&gt;
          &lt;/div&gt;
        );
      }
    }

    function Child() {
      // The click event on this button will bubble up to parent,
      // because there is no 'onClick' attribute defined
      return (
        &lt;div className="modal"&gt;
          &lt;button&gt;Click&lt;/button&gt;
        &lt;/div&gt;
      );
    }

    const portal_root_root = ReactDOM.createRoot(portal_root);
    portal_root_root.render(&lt;Parent /&gt;);
  </code></pre>



<h2 id="renderprop">Render Props</h2>

  <ul>
    <li>function prop that a component uses to know what to render</li>
    <li>component with a render prop takes a function that returns a React element and calls it instead of implementing its own render logic</li>
    <li>you dont have to use a prop named render to use this pattern - any prop that is a function that a component uses to know what to render is technically a "render prop", for example "children"</li>
    <li>you can implement most higher-order components (HOC) using a regular component with a render prop</li>
    <li>using a render prop <strong>can negate the advantage that comes from using React.PureComponent</strong> if you create the function inside a render method, because the shallow prop comparison will always return false for new props, and each render in this case will generate a new value for the render prop</li>
  </ul>

  <div class="example" id="render_prop_root"></div>
  <script type="text/babel">
    class Cat extends React.Component {
      render() {
        const mouse = this.props.mouse;
        return (
          <img
            src="../images/cat.jpg"
            style={{ position: 'absolute', left: mouse.x, top: mouse.y }}
          />
        );
      }
    }
    class Mouse extends React.Component {
      constructor(props) {
        super(props);
        this.handleMouseMove = this.handleMouseMove.bind(this);
        this.state = { x: 0, y: 0 };
      }
      handleMouseMove(event) {
        this.setState({
          // allign to scroll offset ...
          x: event.clientX,
          y: event.clientY
        });
      }
      render() {
        // dynamically determine what to render
        // instead of providing a static representation of what Mouse renders
        return (
          <div
            className="h-30 w_100"
            onMouseMove={this.handleMouseMove}
            onTouchMove={this.handleMouseMove}
          >
            {this.props.render(this.state)}
          </div>
        );
      }
    }
    class MouseTracker extends React.Component {
      renderTheCat(mouse) {
        return <Cat mouse={mouse}/>;
      }
      render() {
        return (
          <div>
            <Mouse render={this.renderTheCat}/>
          </div>
        );
      }
    }
    const render_prop_root = ReactDOM.createRoot(document.getElementById('render_prop_root'));
    render_prop_root.render(<MouseTracker />);

    // --- HOC with render prop
    function withMouse(Component) {
      return class extends React.Component {
        render() {
          return (
            <Mouse render={mouse => (
              <Component {...this.props} mouse={mouse} />
            )}/>
          );
        }
      }
    }
    // const CatWithMouse = withMouse(Cat);
    // const render_prop_root = ReactDOM.createRoot(document.getElementById('render_prop_root'));
    // render_prop_root.render(<CatWithMouse/>);
  </script>
  <pre><code class="">
    class Cat extends React.Component {
      render() {
        const mouse = this.props.mouse;
        return (
          &lt;img
            src="../images/cat.jpg"
            style={{ position: 'absolute', left: mouse.x, top: mouse.y }}
          /&gt;
        );
      }
    }
    class Mouse extends React.Component {
      constructor(props) {
        super(props);
        this.handleMouseMove = this.handleMouseMove.bind(this);
        this.state = { x: 0, y: 0 };
      }
      handleMouseMove(event) {
        this.setState({
          // allign to scroll offset ...
          x: event.clientX,
          y: event.clientY
        });
      }
      render() {
        // dynamically determine what to render
        // instead of providing a static representation of what Mouse renders
        return (
          &lt;div
            className="h-30 w_100"
            onMouseMove={this.handleMouseMove}
            onTouchMove={this.handleMouseMove}
          &gt;
            {this.props.render(this.state)}
          &lt;/div&gt;
        );
      }
    }
    class MouseTracker extends React.Component {
      renderTheCat(mouse) {
        return &lt;Cat mouse={mouse}/&gt;;
      }
      render() {
        return (
          &lt;div&gt;
            &lt;Mouse render={this.renderTheCat}/&gt;
          &lt;/div&gt;
        );
      }
    }
    // const render_prop_root = ReactDOM.createRoot(document.getElementById('render_prop_root'));
    // render_prop_root.render(&lt;MouseTracker /&gt;);

    // --- HOC with render prop
    function withMouse(Component) {
      return class extends React.Component {
        render() {
          return (
            &lt;Mouse render={mouse =&gt; (
              &lt;Component {...this.props} mouse={mouse} /&gt;
            )}/&gt;
          );
        }
      }
    }
    const CatWithMouse = withMouse(Cat);
    const render_prop_root = ReactDOM.createRoot(document.getElementById('render_prop_root'));
    render_prop_root.render(&lt;CatWithMouse/&gt;);

    // --- use the children prop, instead of render
    &lt;Mouse children={mouse =&gt; (
      &lt;p&gt;The mouse position is {mouse.x}, {mouse.y}&lt;/p&gt;
    )}/&gt;
    // put it directly inside the element
    &lt;Mouse&gt;
      {mouse =&gt; (
        &lt;p&gt;The mouse position is {mouse.x}, {mouse.y}&lt;/p&gt;
      )}
    &lt;/Mouse&gt;
    // explicitly state that children should be a function
    // in propTypes when designing an API like this:
    // ...
    Mouse.propTypes = {
      children: PropTypes.func.isRequired
    };
    // ...

    // --- with PureComponent
    class Mouse extends React.PureComponent {
      // Same implementation as above...
    }
    class MouseTracker extends React.Component {

      // BAD, value of the "render" prop will be different on each render
      render() {
        return (
          &lt;div&gt;
            &lt;h1&gt;Move the mouse around!&lt;/h1&gt;
            &lt;Mouse render={mouse =&gt; (
              &lt;Cat mouse={mouse} /&gt;
            )}/&gt;
          &lt;/div&gt;
        );
      }

      // OK, defined as an instance method, `this.renderTheCat` always
      // refers to *same* function when we use it in render
      renderTheCat(mouse) {
        return &lt;Cat mouse={mouse} /&gt;;
      }
      render() {
        return (
          &lt;div&gt;
            &lt;h1&gt;Move the mouse around!&lt;/h1&gt;
            &lt;Mouse render={this.renderTheCat} /&gt;
          &lt;/div&gt;
        );
      }
      // in cases where you cannot define the prop statically
      // (e.g. because you need to close over the components props and/or state)
      // Mouse should extend React.Component instead

    }
  </code></pre>




<h2 id="hooks">Hooks</h2>

  <ul>
    <li>more direct way to use the React features (without writing a class) : state, lifecycle, context, and refs</li>
    <li>dont work inside classes, use them instead of converting function to class</li>
    <li>reuse stateful logic without changing component hierarchy</li>
    <li>split one component into smaller functions based on what pieces are related (such as setting up a subscription or fetching data), rather than forcing a split based on lifecycle methods</li>
    <li>React relies on the order in which Hooks are called, breaking this rules leads to bugs
      <ul>
        <li>1 - call Hooks at the top level, <strong>dont call Hooks inside loops, conditions, or nested functions</strong></li>
        <li>2 - call Hooks from React function components or custom Hooks, <strong>dont call Hooks from regular JS functions</strong></li>
      </ul>
    </li>
    <li><code>useState(initialState)</code> - state hook, adds local state, preserved between re-renders, created once then gives current state
      <ul>
        <li><strong>const [statefulVal, setStateFn] = useState(initialVal);</strong> - during initial render statefulVal is the same as the value passed as the initialVal, returns (using "array destructuring" two new variables) current state value and a function that lets you update it, similar to this.state.count and this.setState in a class (except it doesnt merge the old and new state together)</li>
        <li><strong>setStateFn(newStatefulVal);</strong> - update the state with new_stateful_value and enqueues a re-render of the component, during which the first value returned by useState will always be the most recent state after applying updates</li>
        <li>pass a function to setStateFn if the new state is computed using the previous state, function will receive the previous value, and return an updated value</li>
        <li>if you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects</li>
        <li>split state into multiple state variables based on which values tend to change together</li>
        <li>state variables can hold objects and arrays, unlike this.setState in a class, updating a state variable always replaces it instead of merging it</li>
      </ul>
    </li>
    <li><code>useEffect(didUpdate)</code> - perform side effects from a function component: mutations, subscriptions, timers, logging, and other side effects (which are not allowed inside the main body of a function component (referred to as React render phase), leads to confusing bugs and inconsistencies in the UI)
      <ul>
        <li>by default, <strong>runs after every render</strong>, including initial</li>
        <li>didUpdateFn is going to be different on every render, we schedule a different effect, replacing the previous one, effects behave more like a part of the render result - each effect "belongs" to a particular render</li>
        <li>serves the same purpose as componentDidMount, componentDidUpdate, and componentWillUnmount in React classes, but unified into a single API</li>
        <li>declared inside the component so they have access to its props and state</li>
        <li>cleanup effect when the component unmounts by optionally specifying a "cleanup" function, runs before the component is removed from the UI to prevent memory leaks, additionally, if a component renders multiple times previous effect is cleaned up before executing the next effect
          <ul>
            <li>dont require a cleanup - network requests, manual DOM mutations, and logging, ...</li>
            <li>cleanup scenario - unsubscribe subscription, keep the logic close to each other as part of the same effect</li>
          </ul>
        </li>
        <li>organize side effects in a component by what pieces are related (such as adding and removing a subscription), use the effect hook more than once, rather than forcing a split based on lifecycle methods</li>
        <li>React will apply every effect used by the component, in the order they were specified</li>
        <li>effects scheduled with useEffect dont block the browser from updating the screen</li>
        <li>pass an array as an optional second argument to useEffect to skip applying an effect if certain values havent changed between re-renders, compares previous render and next render, also works for effects that have a cleanup phase, make sure the array includes all values from the component scope (such as props and state) that change over time and that are used by the effect</li>
        <li>pass an empty array ([]) as a second argument if you want to run an effect and clean it up only once (on mount and unmount), tells React that effect doesnt depend on any values from props or state (and it should not depend !), so it never needs to re-run, componentDidMount and componentWillUnmount are usually better solutions to avoid re-running effects too often</li>
        <li><u>useEffect - if you dont need to interact with the DOM at all or your DOM changes are unobservable, useLayoutEffect - to mutate the DOM and/or DO need to perform measurementt</u></li>
      </ul>
    </li>
    <li><code>useContext(MyContext)</code> - accepts a context object (object itself, value returned from React.createContext) and returns the current context value for that context, determined by the value prop of the nearest &lt;MyContext.Provider&gt; above the calling component in the tree, when the nearest &lt;MyContext.Provider&gt; above the component updates, this Hook will trigger a rerender with the latest context value passed to that MyContext provider
      <ul>
        <li>component calling useContext will always re-render when the context value changes</li>
        <li>if re-rendering the component is expensive, optimize it by using memoization</li>
        <li>useContext(MyContext) is equivalent to static contextType=MyContext in a class, or to &lt;MyContext.Consumer&gt;, useContext(MyContext) only lets you read the context and subscribe to its changes, you still need a &lt;MyContext.Provider&gt; above in the tree to provide the value for this context</li>
        <li>const locale = useContext(LocaleContext);</li>
        <li>const theme = useContext(ThemeContext);</li>
      </ul>
    </li>
    <li><strong>custom hooks</strong> - reuse stateful behavior and logic (not state itself) between different components
      <ul>
        <li>hide complex logic behind a simple interface, or help untangle a messy component: form handling, animation, declarative subscriptions, timers, ...</li>
        <li>doesnt need to have a specific signature, decide what it takes as arguments, and what, if anything, it should return, its just like a normal function, but uses other hooks inside</li>
        <li>name should always start with "use"</li>
        <li>each call to a Hook has a completely isolated state - use the same custom Hook multiple times in one component</li>
      </ul>
    </li>
    <li>from React point of view, a component using Hooks is just a regular component, if testing solution doesnt rely on React internals <strong>testing components with Hooks shouldnt be different from how you normally test components</strong></li>
    <li><strong>specify a list of dependencies as the last argument to useEffect, useMemo, useCallback, or useImperativeHandle when those participate in the React data flow: ids, state, props</strong>, hooks are not dependency and can be used for updates</li>
    <li>it is only safe to omit a function from the dependency list if nothing in it (or the functions called by it) references props, state, or values derived from them, OR move function inside hook OR if you cant move a function inside an effect, there are a few more options:
      <ul>
        <li>move function outside of component, guaranteed to not reference any props or state, and also doesnt need to be in the list of dependencies</li>
        <li>pure computation function s safe to call while rendering, you may call it outside of the effect instead, and make the effect depend on the returned value</li>
        <li>add a function to effect dependencies but wrap its definition into the useCallback Hook, ensures it doesnt change on every render unless its own dependencies also change</li>
      </ul>
    </li>
  </ul>

  <details><summary>useState(initialState)</summary>
  <div class="example" id="usestate_root"></div>
  <script type="text/babel">
    function StateRootCounter({initialCount}) {
      const [count, setCount] = React.useState(initialCount);
      function handleAlertClick() {
        // you will see count variable at the time you clicked the button !
        setTimeout(() => {
          alert('You clicked on: ' + count);
        }, 3000);
      }
      return (
        <div>
          Count: {count}
          <button onClick={() => setCount(initialCount)}>Reset</button>
          <button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>
          <button onClick={() => setCount(prevCount => prevCount - 1)}>-</button>
          <button onClick={handleAlertClick}>Show alert</button>
        </div>
      );
    }
    const usestate_root = ReactDOM.createRoot(document.getElementById('usestate_root'));
    usestate_root.render(<StateRootCounter initialCount={101}/>);
  </script>
  <pre><code class="">
    function StateRootCounter({initialCount}) {
      const [count, setCount] = React.useState(initialCount);
      // use functional updates on hooks inside event handler
      return (
        &lt;div&gt;
          Count: {count}
          &lt;button onClick={() =&gt; setCount(initialCount)}&gt;Reset&lt;/button&gt;
          &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount + 1)}&gt;+&lt;/button&gt;
          &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount - 1)}&gt;-&lt;/button&gt;
        &lt;/div&gt;
      );
    }
    const usestate_root = ReactDOM.createRoot(document.getElementById('usestate_root'));
    usestate_root.render(&lt;StateRootCounter initialCount={101}/&gt;);

    import React, { useState } from 'react';
    // OR use as React.useState
    function Example() {
      // declare a new state variable "count"
      const [count, setCount] = useState(0);
      // declare multiple
      const [age, setAge] = useState(42);
      const [fruit, setFruit] = useState('banana');
      // var fruitStateVariable = useState('banana'); // Returns a pair
      // var fruit = fruitStateVariable[0]; // First item in a pair
      // var setFruit = fruitStateVariable[1]; // Second item in a pair
      const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);

      // if the initial state is the result of an expensive computation
      // provide a function instead, which will be executed only on the initial render
      const [state, setState] = useState(() => {
        const initialState = someExpensiveComputation(props);
        return initialState;
      });

      // useState does not automatically merge update objects
      // replicate setState method found in class components
      // by combining the function updater form with object spread syntax
      // or useReducer...
      setState(prevState => {
        return {...prevState, ...updatedValues}; // Object.assign would also work
      });

      return (
        &lt;div&gt;
          &lt;p&gt;You clicked {count} times&lt;/p&gt;
          &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
            Click me
          &lt;/button&gt;
        &lt;/div&gt;
      );

    }

    // --- --- ---
    // --- equivalent class example
    class Example extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0
        };
      }
      render() {
        return (
          &lt;div&gt;
            &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;
            &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;
              Click me
            &lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }
    // --- --- ---

    // --- avoid re-creating the ignored initial state, we can pass a function
    function Table(props) {
      const [rows, setRows] = useState(() => createRows(props.count));
      // ...
    }

    // --- store many state variables
    function Box() {
      const [state, setState] = useState(
        { left: 0, top: 0, width: 100, height: 100 }
      );
      // OR
      const [position, setPosition] = useState({ left: 0, top: 0 });
      const [size, setSize] = useState({ width: 100, height: 100 });
      // ...
    }
    // ...
      useEffect(() => {
        function handleWindowMouseMove(e) {
          // Spreading "...state" ensures we don't "lose" width and height
          setState(state => ({ ...state, left: e.pageX, top: e.pageY }));
          // OR
          setPosition({ left: e.pageX, top: e.pageY });
        }
        function useWindowPosition() {
          const [position, setPosition] = useState({ left: 0, top: 0 });
          useEffect(() => {
            // ...
          }, []);
          return position;
        }
        // Note: this implementation is a bit simplified
        window.addEventListener('mousemove', handleWindowMouseMove);
        return () => window.removeEventListener('mousemove', handleWindowMouseMove);
      }, []);
    // ...

    // --- implement getDerivedStateFromProps
    // update the state right during rendering
    // re-run the component with updated state immediately
    // after exiting the first render so it wouldnt be expensive
    function ScrollView({row}) {
      let [isScrollingDown, setIsScrollingDown] = useState(false);
      // store the previous value of the row prop in a state variable so that we can compare
      let [prevRow, setPrevRow] = useState(null);
      if (row !== prevRow) {
        // Row changed since last render. Update isScrollingDown.
        setIsScrollingDown(prevRow !== null && row > prevRow);
        setPrevRow(row);
      }
      return `Scrolling down: ${isScrollingDown}`;
    }

    // --- implement forceUpdate, avoid this pattern if possible
    // ...
      const [ignored, forceUpdate] = useReducer(x => x + 1, 0);
      function handleClick() {
        forceUpdate();
      }
    // ...

    // --- manage component local state with a reducer
    function useReducer(reducer, initialState) {
      const [state, setState] = useState(initialState);
      function dispatch(action) {
        const nextState = reducer(state, action);
        setState(nextState);
      }
      return [state, dispatch];
    }
    // ...
    function Todos() {
      const [todos, dispatch] = useReducer(todosReducer, []);
      function handleAddClick(text) {
        dispatch({ type: 'add', text });
      }
      // ...
    }
  </code></pre></details>

  <details><summary>useEffect(didUpdate)</summary>
  <pre><code class="">
    // not "when does this effect run"
    // "with which state does this effect synchronize with":
    useEffect(fn) // all state
    useEffect(fn, []) // no state
    useEffect(fn, [these, states])

    import React, { useEffect } from 'react';
    function Example() {
      const [count, setCount] = useState(0);
      const [isOnline, setIsOnline] = useState(null);

      // similar to componentDidMount and componentDidUpdate:
      useEffect(() =&gt; {
        document.title = `${count} clicks`; // using browser API
      });
      // only re-run the effect if count changes or any other dependency
      // }, [count]);
      // effect doesnt depend on any values from props or state,
      // so it never needs to re-run, and it should not depend
      // }, []);

      // useEffect hook with clean up, as a multiple hooks scenario
      useEffect(() =&gt; {
        function handleStatusChange(status) {
          setIsOnline(status.isOnline);
        }
        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
        // unsubscribe from ChatAPI when the component unmounts
        // as well as before re-running the effect due to a subsequent render
        // avoid resubscribing for ids
        return () =&gt; {
          ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
        };
      });
      // }, [props.friend.id]); // subscription is recreated only if props.friend.id changes

      useEffect(() => {
        const id = setInterval(() => {
          setCount(c => c + 1); // doesnt depend on "count" variable outside
        }, 1000);
        return () => clearInterval(id);
      }, []); // doesnt use any variables in the component scope

      useEffect(function persistForm() {
        // rules are not breaking this way, condition is inside hook
        if (name !== '') {
          localStorage.setItem('formData', name);
        }
      });

      const onlineStatus = isOnline ? 'Online' : 'Offline';

      return (
        &lt;div&gt;
          &lt;p&gt;You are {onlineStatus} and clicked {count} times&lt;/p&gt;
          &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
            Click me
          &lt;/button&gt;
        &lt;/div&gt;
      );
    }

    // --- class analogue
    class Example extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0,
          isOnline: null
        };
        this.handleStatusChange = this.handleStatusChange.bind(this);
      }

      // duplicates code in lifecycle methods !
      componentDidMount() {
        document.title = `You clicked ${this.state.count} times`;
        ChatAPI.subscribeToFriendStatus(
          this.props.friend.id,
          this.handleStatusChange
        );
      }
      componentDidUpdate() {

        document.title = `You clicked ${this.state.count} times`;
        // extra comparison to avoid performance problem
        // on cleaning up or applying the effect after every render
        if (prevState.count !== this.state.count) {
          document.title = `You clicked ${this.state.count} times`;
        }

        // if the friend prop changes while the component is on the screen
        // our component would continue displaying the online status of a different friend
        // Unsubscribe from the previous friend.id
        ChatAPI.unsubscribeFromFriendStatus(
          prevProps.friend.id,
          this.handleStatusChange
        );
        // Subscribe to the next friend.id
        ChatAPI.subscribeToFriendStatus(
          this.props.friend.id,
          this.handleStatusChange
        );

      }
      componentWillUnmount() {
        ChatAPI.unsubscribeFromFriendStatus(
          this.props.friend.id,
          this.handleStatusChange
        );
      }

      handleStatusChange(status) {
        this.setState({
          isOnline: status.isOnline
        });
      }

      const onlineStatus = isOnline ? 'Online' : 'Offline';

      render() {
        return (
          &lt;div&gt;
            &lt;p&gt;You are {onlineStatus} and clicked {count} times&lt;/p&gt;
            &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;
              Click me
            &lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }

    // --- dependency, function inside effect
    function ProductPage({ productId }) {
      const [product, setProduct] = useState(null);
      useEffect(() => {
        let ignore = false; // handle out-of-order responses
        async function fetchProduct() {
          const response = await fetch('http://myapi/product' + productId);
          const json = await response.json();
          if (!ignore) setProduct(json);
        }
        return () => { ignore = true };
      }, [productId]); // valid because our effect only uses productId
      // ...
    }
    // --- wrapped dependency
    // change in the productId prop of ProductPage
    // automatically triggers a refetch in the ProductDetails component
    function ProductPage({ productId }) {
      // wrap with useCallback to avoid change on every render
      const fetchProduct = useCallback(() => {
        // ... Does something with productId ...
      }, [productId]); // all useCallback dependencies are specified
      return &lt;ProductDetails fetchProduct={fetchProduct} /&gt;;
    }
    function ProductDetails({ fetchProduct }) {
      useEffect(() => {
        fetchProduct();
      }, [fetchProduct]); // all useEffect dependencies are specified
      // ...
    }
  </code></pre></details>

  <details><summary>useContext(MyContext)</summary>
  <pre><code class="">
    const themes = {
      light: {
        foreground: "#000000",
        background: "#eeeeee"
      },
      dark: {
        foreground: "#ffffff",
        background: "#222222"
      }
    };
    const ThemeContext = React.createContext(themes.light);
    function App() {
      return (
        &lt;ThemeContext.Provider value={themes.dark}&gt;
          &lt;Toolbar /&gt;
        &lt;/ThemeContext.Provider&gt;
      );
    }
    function Toolbar(props) {
      return (
        &lt;div&gt;
          &lt;ThemedButton /&gt;
        &lt;/div&gt;
      );
    }
    function ThemedButton() {
      const theme = useContext(ThemeContext);
      return (
        &lt;button style={{ background: theme.background, color: theme.foreground }}&gt;
          I am styled by theme context!
        &lt;/button&gt;
      );
    }
  </code></pre></details>

  <details><summary>custom hooks</summary>
  <pre><code class="">
    // extracts logic from previous examples
    import React, { useState, useEffect } from 'react';
    function useFriendStatus(friendID) {
      const [isOnline, setIsOnline] = useState(null);
      function handleStatusChange(status) {
        setIsOnline(status.isOnline);
      }
      useEffect(() =&gt; {
        ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
        return () =&gt; {
          ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
        };
      });
      return isOnline;
    }
    // and reuse it
    function FriendStatus(props) {
      const isOnline = useFriendStatus(props.friend.id);
      if (isOnline === null) { return 'Loading...'; }
      return isOnline ? 'Online' : 'Offline';
    }
    function FriendListItem(props) {
      const isOnline = useFriendStatus(props.friend.id);
      return (
        &lt;li style={{ color: isOnline ? 'green' : 'black' }}&gt;
          {props.friend.name}
        &lt;/li&gt;
      );
    }

    // --- pass information between hooks
    const friendList = [
      { id: 1, name: 'Phoebe' },
      { id: 2, name: 'Rachel' },
      { id: 3, name: 'Ross' },
    ];
    function ChatRecipientPicker() {
      // recipientID updates resubscribes status
      const [recipientID, setRecipientID] = useState(1);
      const isRecipientOnline = useFriendStatus(recipientID);
      return (
        &lt;&gt;
          &lt;Circle color={isRecipientOnline ? 'green' : 'red'} /&gt;
          &lt;select
            value={recipientID}
            onChange={e =&gt; setRecipientID(Number(e.target.value))}
          &gt;
            {friendList.map(friend =&gt; (
              &lt;option key={friend.id} value={friend.id}&gt;
                {friend.name}
              &lt;/option&gt;
            ))}
          &lt;/select&gt;
        &lt;/&gt;
      );
    }
  </code></pre></details>

  <details><summary>lint plugin</summary>
  <pre><code class="">
    npm install eslint-plugin-react-hooks --save-dev
    //ESLint configuration
    {
      "plugins": [
        // ...
        "react-hooks"
      ],
      "rules": {
        // ...
        "react-hooks/rules-of-hooks": "error", // Checks rules of Hooks
        "react-hooks/exhaustive-deps": "warn" // Checks effect dependencies
      }
    }
  </code></pre></details>

  <h3>additional hooks - specific edge cases, variants of the basic ones</h3>

  <details><summary>useReducer(reducer, initialArg, init)</summary>
  <ul>
    <li>alternative to useState, accepts a reducer of type (state, action) => newState, and returns the current state paired with a dispatch method</li>
    <li>for complex state logic that involves multiple sub-values or when the next state depends on the previous one</li>
    <li>optimize performance for components that trigger deep updates, pass dispatch down instead of callbacks</li>
    <li>create the initial state lazily by passing an init function as the third argument, initial state will be set to init(initialArg), lets you extract the logic for calculating the initial state outside the reducer, handy for resetting the state later in response to an action</li>
    <li>if you return the same value from a Reducer Hook as the current state, React will bail out without rendering the children or firing effects</li>
    <li>identity of the dispatch function from useReducer is always stable - even if the reducer function is declared inside the component and reads its props</li>
  </ul>
  <div class="example" id="usereducer_root"></div>
  <script type="text/babel">
    const initialReducerCounter = {count: 0};
    function reducerForCounter(state, action) {
      switch (action.type) {
        case 'increment':
          return {count: state.count + 1};
        case 'decrement':
          return {count: state.count - 1};
        default:
          throw new Error();
      }
    }
    function UseReducerCounter({initialState}) {
      const [state, dispatch] = React.useReducer(
        reducerForCounter,
        initialState
      );
      return (
        <div>
          Count: {state.count}
          <button onClick={() => dispatch({type: 'increment'})}>+</button>
          <button onClick={() => dispatch({type: 'decrement'})}>-</button>
        </div>
      );
    }
    // const usereducer_root = ReactDOM.createRoot(document.getElementById("usereducer_root"));
    // usereducer_root.render(<UseReducerCounter initialState={initialReducerCounter}/>);

    // --- LAZY
    function initLazyCounter(initialCount) {
      return {count: initialCount};
    }
    function reducerForLazyCounter(state, action) {
      switch (action.type) {
        case 'increment':
          return {count: state.count + 1};
        case 'decrement':
          return {count: state.count - 1};
        case 'reset':
          return initLazyCounter(action.payload);
        default:
          throw new Error();
      }
    }
    function UseReducerLazyCounter({initialState}) {
      const [state, dispatch] = React.useReducer(
        reducerForLazyCounter,
        initialState,
        initLazyCounter
      );
      return (
        <div>
          Count: {state.count}
          <button
            onClick={() => dispatch({type: 'reset', payload: initialState})}>
            Reset
          </button>
          <button onClick={() => dispatch({type: 'increment'})}>+</button>
          <button onClick={() => dispatch({type: 'decrement'})}>-</button>
        </div>
      );
    }
    const usereducer_root = ReactDOM.createRoot(document.getElementById("usereducer_root"));
    usereducer_root.render(<UseReducerLazyCounter initialState={0}/>);
  </script>
  <pre><code class="">
    // --- INITAL STATE
    const initialReducerCounter = {count: 0};
    function reducerForCounter(state, action) {
      switch (action.type) {
        case 'increment':
          return {count: state.count + 1};
        case 'decrement':
          return {count: state.count - 1};
        default:
          throw new Error();
      }
    }
    function UseReducerCounter({initialState}) {
      const [state, dispatch] = React.useReducer(
        reducerForCounter,
        initialState
      );
      return (
        &lt;div&gt;
          Count: {state.count}
          &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/button&gt;
          &lt;button onClick={() =&gt; dispatch({type: 'decrement'})}&gt;-&lt;/button&gt;
        &lt;/div&gt;
      );
    }
    // const usereducer_root = ReactDOM.createRoot(document.getElementById("usereducer_root"));
    // usereducer_root.render(&lt;UseReducerCounter initialState={initialReducerCounter}/&gt;);

    // --- LAZY INIT
    function initLazyCounter(initialCount) {
      return {count: initialCount};
    }
    function reducerForLazyCounter(state, action) {
      switch (action.type) {
        case 'increment':
          return {count: state.count + 1};
        case 'decrement':
          return {count: state.count - 1};
        case 'reset':
          return initLazyCounter(action.payload);
        default:
          throw new Error();
      }
    }
    function UseReducerLazyCounter({initialState}) {
      const [state, dispatch] = React.useReducer(
        reducerForLazyCounter,
        initialState,
        initLazyCounter
      );
      return (
        &lt;div&gt;
          Count: {state.count}
          &lt;button
            onClick={() =&gt; dispatch({type: 'reset', payload: initialState})}&gt;
            Reset
          &lt;/button&gt;
          &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/button&gt;
          &lt;button onClick={() =&gt; dispatch({type: 'decrement'})}&gt;-&lt;/button&gt;
        &lt;/div&gt;
      );
    }
    const usereducer_root = ReactDOM.createRoot(document.getElementById("usereducer_root"));
    usereducer_root.render(&lt;UseReducerLazyCounter initialState={0}/&gt;);

    // --- deep update, passing callbacks through every level of a component tree
    const TodosDispatch = React.createContext(null);
    function TodosApp() {
      // "dispatch" wont change between re-renders
      const [todos, dispatch] = useReducer(todosReducer);
      return (
        &lt;TodosDispatch.Provider value={dispatch}&gt;
          &lt;DeepTree todos={todos} /&gt;
        &lt;/TodosDispatch.Provider&gt;
      );
    }
    function DeepChild(props) {
      // if we want to perform an action, we can get dispatch from context
      // pass actions up to TodosApp
      const dispatch = useContext(TodosDispatch);
      function handleClick() {
        dispatch({ type: 'add', text: 'hello' });
      }
      return (
        &lt;button onClick={handleClick}&gt;Add todo&lt;/button&gt;
      );
    }
  </code></pre>
  </details>

  <details><summary>useCallback(fn, deps)</summary>
  <ul>
    <li>returns a memoized version of the callback that only changes if one of the dependencies has changed</li>
    <li>useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. shouldComponentUpdate)</li>
    <li>is equivalent to useMemo(() => fn, deps)</li>
  </ul>
  <pre><code class="">
    const memoizedCallback = useCallback(
      () =&gt; {
        doSomething(a, b);
      },
      [a, b],
    );

    // --- measure the position or size of a DOM node
    function MeasureExample() {
      const [rect, ref] = useClientRect();
      return (
        &lt;&gt;
          &lt;h1 ref={ref}&gt;Hello, world&lt;/h1&gt;
          {rect !== null &&
            &lt;h2&gt;The above header is {Math.round(rect.height)}px tall&lt;/h2&gt;
          }
        &lt;/&gt;
      );
    }
    function useClientRect() {
      const [rect, setRect] = useState(null);
      const ref = useCallback(node =&gt; {
        if (node !== null) {
          setRect(node.getBoundingClientRect());
        }
      }, []); // callback doesnt change between the re-renders, dont call it unnecessarily
      return [rect, ref];
    }

    // --- read an often-changing value from useCallback
    // function is an event handler and isnt used during rendering
    // using ref as an instance variable, saving the last committed value into it manually
    function Form() {
      const [text, updateText] = useState('');
      const textRef = useRef();
      useEffect(() =&gt; {
        textRef.current = text; // write it to the ref
      });
      const handleSubmit = useCallback(() =&gt; {
        const currentText = textRef.current; // Read it from the ref
        alert(currentText);
      }, [textRef]); // dont recreate handleSubmit like [text] would do
      return (
        &lt;&gt;
          &lt;input value={text} onChange={e =&gt; updateText(e.target.value)} /&gt;
          &lt;ExpensiveTree onSubmit={handleSubmit} /&gt;
        &lt;/&gt;
      );
    }
    // extract to custom hook
    function Form() {
      const [text, updateText] = useState('');
      // will be memoized even if `text` changes:
      const handleSubmit = useEventCallback(() =&gt; {
        alert(text);
      }, [text]);
      return (
        &lt;&gt;
          &lt;input value={text} onChange={e =&gt; updateText(e.target.value)} /&gt;
          &lt;ExpensiveTree onSubmit={handleSubmit} /&gt;
        &lt;/&gt;
      );
    }
    function useEventCallback(fn, dependencies) {
      const ref = useRef(() =&gt; {
        throw new Error('Cannot call an event handler while rendering');
      });
      useEffect(() =&gt; {
        ref.current = fn;
      }, [fn, ...dependencies]);
      return useCallback(() =&gt; {
        const fn = ref.current;
        return fn();
      }, [ref]);
    }
  </code></pre>
  </details>

  <details><summary>useMemo(() => fn, deps)</summary>
  <ul>
    <li>returns a memoized value, equivalent to PureComponent, but it only compares props</li>
    <li>will only recompute the memoized value when one of the dependencies has changed</li>
    <li>helps to avoid expensive calculations on every render</li>
    <li>function passed to useMemo runs during rendering, dont do anything there that you wouldnt normally do while rendering, for example, side effects belong in useEffect, not useMemo</li>
    <li>if no array is provided, a new value will be computed on every render</li>
    <li>rely on useMemo as a performance optimization, not as a semantic guarantee</li>
    <li>write code so that it still works without useMemo - and then add it to optimize performance</li>
  </ul>
  <pre><code class="">
    const memoizedValue = useMemo(
      () => computeExpensiveValue(a, b),
      [a, b]
    );

    const Button = React.memo((props) => {
      // component
    });

    // skip an expensive re-render of a child
    function Parent({ a, b }) {
      // Only re-rendered if "a" changes:
      const child1 = useMemo(() => &lt;Child1 a={a} /&gt;, [a]);
      // Only re-rendered if "b" changes:
      const child2 = useMemo(() => &lt;Child2 b={b} /&gt;, [b]);
      return (
        &lt;&gt;
          {child1}
          {child2}
        &lt;/&gt;
      )
    }

    // avoid unnecessary re-renders
    const CountButton = React.memo(function CountButton({onClick, count}) {
      return &lt;button onClick={onClick}&gt;{count}&lt;/button&gt;;
    })
    function DualCounter() {
      const [count1, setCount1] = React.useState(0);
      const increment1 = React.useCallback(() =&gt; setCount1(c =&gt; c + 1), []);
      const [count2, setCount2] = React.useState(0);
      const increment2 = React.useCallback(() =&gt; setCount2(c =&gt; c + 1), []);
      return (
        &lt;&gt;
          &lt;CountButton count={count1} onClick={increment1} /&gt;
          &lt;CountButton count={count2} onClick={increment2} /&gt;
        &lt;/&gt;
      )
    }
  </code></pre>
  </details>

  <details><summary>useRef(initialValue)</summary>
  <ul>
    <li>returns (holds) a mutable ref object whose .current property is initialized to the passed argument (initialValue)</li>
    <li>returned object will persist for the full lifetime of the component</li>
    <li>doesnt notify you when its content changes, mutating the .current property doesnt cause a re-render, <strong>to run some code when React attaches or detaches a ref to a DOM node, use a callback ref</strong> instead</li>
    <li>common use case is to access a child imperatively</li>
    <li>handy for keeping any mutable value around similar to using instance fields in classes</li>
    <li>the only difference between useRef() and creating a {current: ...} object yourself is that useRef will give you the same ref object on every render</li>
  </ul>
  <div class="example" id="useref_root"></div>
  <script type="text/babel">
    function UseRefExamples() {
      const [count, setCount] = React.useState(0);
      const prevCount = useRefUsePrevious(count);
      const inputEl = React.useRef(null);
      const onButtonClick = () => {
        // "current" points to the mounted text input element
        inputEl.current.focus();
      };
      return (
        <div>
          <input ref={inputEl} type="text" /><br/>
          <button onClick={onButtonClick}>Focus the input</button>
          <div>Now: {count}, before: {prevCount}</div>
          <button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>
          <button onClick={() => setCount(prevCount => prevCount - 1)}>-</button>
        </div>
      );
    }
    function useRefUsePrevious(value) {
      const ref = React.useRef();
      React.useEffect(() => {
        ref.current = value;
      });
      return ref.current;
    }
    const useref_root = ReactDOM.createRoot(document.getElementById("useref_root"));
    useref_root.render(<UseRefExamples/>);
  </script>
  <pre><code class="">
    function UseRefExamples() {
      const [count, setCount] = React.useState(0);
      const prevCount = useRefUsePrevious(count); // store any other calculated value
      const inputEl = React.useRef(null);
      const onButtonClick = () => {
        // "current" points to the mounted text input element
        inputEl.current.focus();
      };
      return (
        &lt;div&gt;
          &lt;input ref={inputEl} type="text" /&gt;&lt;br/&gt;
          &lt;button onClick={onButtonClick}&gt;Focus the input&lt;/button&gt;
          &lt;div&gt;Now: {count}, before: {prevCount}&lt;/div&gt;
          &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount + 1)}&gt;+&lt;/button&gt;
          &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount - 1)}&gt;-&lt;/button&gt;
        &lt;/div&gt;
      );
    }
    function useRefUsePrevious(value) {
      const ref = React.useRef();
      React.useEffect(() =&gt; {
        ref.current = value;
      });
      return ref.current;
    }
    const useref_root = ReactDOM.createRoot(document.getElementById("useref_root"));
    useref_root.render(&lt;UseRefExamples/&gt;);

    // --- avoid re-creating the useRef() initial value
    function Image(props) {
      const ref = useRef(null);
      // IntersectionObserver is created lazily once
      function getObserver() {
        if (ref.current === null) {
          ref.current = new IntersectionObserver(onIntersect);
        }
        return ref.current;
      }
      //call getObserver()
      // ...
    }

    // like instance variables
    // ...
    function Timer() {
      const intervalRef = useRef();
      useEffect(() =&gt; {
        const id = setInterval(() =&gt; {
          // ...
        });
        intervalRef.current = id;
        return () =&gt; {
          clearInterval(intervalRef.current);
        };
      });
      // ...
      function handleCancelClick() {
        clearInterval(intervalRef.current);
      }
      // ...
    }
  </code></pre>
  </details>

  <details><summary>useImperativeHandle(ref, createHandle, [deps])</summary>
  <ul>
    <li>customizes the instance value that is exposed to parent components when using ref</li>
    <li>should be used with forwardRef</li>
    <li>imperative code using refs should be avoided in most cases</li>
    <li>ref to a function component - you may expose some imperative methods to a parent component </li>
  </ul>
  <pre><code class="">
    // parent component that renders &lt;FancyInput ref={fancyInputRef} /&gt;
    // would be able to call fancyInputRef.current.focus()
    function FancyInput(props, ref) {
      const inputRef = useRef();
      useImperativeHandle(ref, () => ({
        focus: () => {
          inputRef.current.focus();
        }
      }));
      return &lt;input ref={inputRef} ... /&gt;;
    }
    FancyInput = forwardRef(FancyInput);
  </code></pre>
  </details>

  <details><summary>useLayoutEffect(didUpdateFn)</summary>
  <ul>
    <li>read layout from the DOM and synchronously re-render</li>
    <li>signature is identical to useEffect, but it fires synchronously after all DOM mutations</li>
    <li>fires in the same phase as componentDidMount and componentDidUpdate</li>
    <li>updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint</li>
    <li>start with useEffect first and only trying useLayoutEffect if that causes a problem, to avoid blocking visual updates</li>
    <li>if you use server rendering, neither useLayoutEffect nor useEffect can run until the JS is downloaded (React warns about useLayoutEffect), either move that logic to useEffect (if it isnt necessary for the first render), or delay showing that component until after the client renders (if the HTML looks broken until useLayoutEffect runs), to exclude a component that needs layout effects from the server-rendered HTML, render it conditionally with showChild && &lt;Child /&gt; and defer showing it with useEffect(() => { setShowChild(true); }, []), UI will not appear broken before hydration</li>
  </ul>
  </details>

  <details><summary>useDebugValue(value[,formattingFn])</summary>
  <ul>
    <li>display a label for custom hooks in React DevTools</li>
    <li>dont add debug values to every custom Hook, valuable for parts of shared libraries</li>
    <li>formattingFn - only called if the Hooks are inspected, receives the debug value as a parameter and should return a formatted display value</li>
  </ul>
  <pre><code class="">
    function useFriendStatus(friendID) {
      const [isOnline, setIsOnline] = useState(null);
      // ...
      // show a label in DevTools next to this Hook
      // e.g. "FriendStatus: Online"
      useDebugValue(isOnline ? 'Online' : 'Offline');
      return isOnline;
    }

    // --- with formattingFn:
    useDebugValue(date, date => date.toDateString());
  </code></pre>
  </details>

  <details><summary>useDeferredValue(value)</summary>
  <ul>
    <li>accepts a value and returns a new copy of the value that will defer to more urgent updates</li>
    <li>if the current render is the result of an urgent update, like user input, React will return the previous value and then render the new value after the urgent render has completed</li>
    <li>similar to user-space hooks which use debouncing or throttling to defer updates, benefits to using useDeferredValue is that React will work on the update as soon as other work finishes (instead of waiting for an arbitrary amount of time), and like startTransition, deferred values can suspend without triggering an unexpected fallback for existing content</li>
  </ul>
  <pre><code class="">
    // memoizing deferred children
    // if you want to prevent a child component from re-rendering during an urgent update,
    // also memoize that component with React.memo or React.useMemo
    function Typeahead() {
      const query = useSearchQuery('');
      const deferredQuery = useDeferredValue(query);
      // Memoizing tells React to only re-render when deferredQuery changes,
      // not when query changes.
      const suggestions = useMemo(() =&gt;
        &lt;SearchSuggestions query={deferredQuery} /&gt;,
        [deferredQuery]
      );
      return (
        &lt;&gt;
          &lt;SearchInput query={query} /&gt;
          &lt;Suspense fallback="Loading results..."&gt;
            {suggestions}
          &lt;/Suspense&gt;
        &lt;/&gt;
      );
    }
    // re-render them when deferredQuery changes and not when query changes
  </code></pre>
  </details>

  <details><summary>useTransition()</summary>
  <ul>
    <li>returns a stateful value for the pending state of the transition, and a function to start it</li>
    <li>lets you mark updates in the provided callback as transitions</li>
    <li>updates in a transition yield to more urgent updates such as clicks</li>
    <li>updates in a transitions will not show a fallback for re-suspended content, this allows the user to continue interacting with the current content while rendering the update</li>
  </ul>
  <pre><code class="">
    function App() {
      const [isPending, startTransition] = useTransition();
      const [count, setCount] = useState(0);
      function handleClick() {
        startTransition(() =&gt; {
          setCount(c =&gt; c + 1);
        })
      }
      return (
        &lt;div&gt;
          {isPending && &lt;Spinner /&gt;}
          &lt;button onClick={handleClick}&gt;{count}&lt;/button&gt;
        &lt;/div&gt;
      );
    }
  </code></pre>
  </details>

  <details><summary>useId()</summary>
  <ul>
    <li>generate unique IDs that are stable across the server and client, while avoiding hydration mismatches</li>
    <li>not for generating keys in a list, keys should be generated from your data</li>
    <li>generates a string that includes the <code>:</code> token, this helps ensure that the token is unique, but is not supported in CSS selectors or APIs like querySelectorAll</li>
    <li>supports an identifierPrefix to prevent collisions in multi-root apps, to configure, see the options for hydrateRoot and ReactDOMServer</li>
  </ul>
  <pre><code class="">
    function Checkbox() {
      const id = useId();
      return (
        &lt;&gt;
          &lt;label htmlFor={id}&gt;Do you like React?&lt;/label&gt;
          &lt;input id={id} type="checkbox" name="react"/&gt;
        &lt;/&gt;
      );
    };
    // for multiple IDs in the same component, append a suffix using the same id
    function NameFields() {
      const id = useId();
      return (
        &lt;div&gt;
          &lt;label htmlFor={id + '-firstName'}&gt;First Name&lt;/label&gt;
          &lt;div&gt;
            &lt;input id={id + '-firstName'} type="text" /&gt;
          &lt;/div&gt;
          &lt;label htmlFor={id + '-lastName'}&gt;Last Name&lt;/label&gt;
          &lt;div&gt;
            &lt;input id={id + '-lastName'} type="text" /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      );
    }
  </code></pre>
  </details>

  <h3>Hooks provided for library authors</h3>

  <details><summary>useSyncExternalStore(subscribe, getSnapshot[, getServerSnapshot])</summary>
  <ul>
    <li>recommended for reading and subscribing from external data sources in a way thats compatible with concurrent rendering features like selective hydration and time slicing</li>
    <li>returns the value of the store and accepts three arguments
      <ul>
        <li>subscribe - function to register a callback that is called whenever the store changes</li>
        <li>getSnapshot - function that returns the current value of the store</li>
        <li>getServerSnapshot - function that returns the snapshot used during server rendering</li>
      </ul>
    </li>
    <li>must return a cached value, if getSnapshot is called multiple times in a row, it must return the same exact value unless there was a store update in between</li>
    <li>shim is provided for supporting multiple React versions published as <code>use-sync-external-store/shim</code>, this shim will prefer useSyncExternalStore when available, and fallback to a user-space implementation when its not</li>
    <li>also is provided a version of the API with automatic support for memoizing the result of getSnapshot published as <code>use-sync-external-store/with-selector</code></li>
  </ul>
  <pre><code class="">
    // subscribes to the entire store:
    const state = useSyncExternalStore(store.subscribe, store.getSnapshot);
    // subscribe to a specific field:
    const selectedField = useSyncExternalStore(
      store.subscribe,
      () => store.getSnapshot().selectedField,
    );
    // when server rendering, serialize the store value used on the server,
    // and provide it to useSyncExternalStore
    // React will use this snapshot during hydration to prevent server mismatches:
    const selectedField = useSyncExternalStore(
      store.subscribe,
      () => store.getSnapshot().selectedField,
      () => INITIAL_SERVER_SNAPSHOT.selectedField,
    );
  </code></pre>
  </details>

  <details><summary>useInsertionEffect(didUpdate)</summary>
  <ul>
    <li>signature is identical to useEffect, but it fires synchronously before all DOM mutations, use to inject styles into the DOM before reading layout in useLayoutEffect</li>
    <li>since this hook is limited in scope, this hook does not have access to refs and cannot schedule updates</li>
    <li>should be limited to css-in-js library authors. Prefer useEffect or useLayoutEffect instead</li>
  </ul>
  </details>



<h2 id="ajax">AJAX</h2>
  <!--
  <ul>
    <li></li>
    <li></li>
    <li></li>
  </ul>
  -->

  <div class="example" id="ajax_root"></div>
  <script type="text/babel">
    class AjaxFetchExample extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          error: null,
          isLoaded: false,
          items: []
        };
      }
      componentDidMount() {
        fetch("php/ajax_json.php")
          .then(res => res.json())
          .then(
            (result) => {
              this.setState({
                isLoaded: true,
                items: result.items.response
              });
            },
            // instead of a catch() block so that we dont swallow
            // exceptions from actual bugs in components
            (error) => {
              this.setState({
                isLoaded: true,
                error
              });
            }
          )
      }
      render() {
        const { error, isLoaded, items } = this.state;
        if (error) {
          return <div>Error: {error.message}</div>;
        } else if (!isLoaded) {
          return <div>Loading...</div>;
        } else {
          return (
            <ul>
              {items.map(item => (
                <li key={item.name}>
                  {item.name} {item.price}
                </li>
              ))}
            </ul>
          );
        }
      }
    }
    const ajax_root = ReactDOM.createRoot(document.getElementById("ajax_root"));
    ajax_root.render(<AjaxFetchExample/>);
  </script>
  <pre><code class="">
    class AjaxFetchExample extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          error: null,
          isLoaded: false,
          items: []
        };
      }
      componentDidMount() {
        fetch("php/ajax_json.php")
          .then(res =&gt; res.json())
          .then(
            (result) =&gt; {
              this.setState({
                isLoaded: true,
                items: result.items.response
              });
            },
            // instead of a catch() block so that we dont swallow
            // exceptions from actual bugs in components
            (error) =&gt; {
              this.setState({
                isLoaded: true,
                error
              });
            }
          )
      }
      render() {
        const { error, isLoaded, items } = this.state;
        if (error) {
          return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
        } else if (!isLoaded) {
          return &lt;div&gt;Loading...&lt;/div&gt;;
        } else {
          return (
            &lt;ul&gt;
              {items.map(item =&gt; (
                &lt;li key={item.name}&gt;
                  {item.name} {item.price}
                &lt;/li&gt;
              ))}
            &lt;/ul&gt;
          );
        }
      }
    }
    const ajax_root = ReactDOM.createRoot(document.getElementById("ajax_root"));
    ajax_root.render(&lt;AjaxFetchExample/&gt;);
  </code></pre>





<br/>
<a href="../index.html" id="main_page_link">Back to Main Page</a>
<br/>
<br/>
<br/>

</body>
</html>
